{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_02.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_02.c", "text": "{ CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); { for (; *data != L'\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_02.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); { { size_t i; for (i=0; i < wcslen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); static void goodB2G2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_34.c", "text": "* Sinks: * GoodSink: free() memory correctly at the start of the buffer * BadSink : free() memory not at the start of the buffer * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) typedef union { wchar_t * unionFirst; wchar_t * unionSecond; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_34_bad() { wchar_t * data; CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_34_unionType myUnion; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_34.c", "text": "wchar_t * data = myUnion.unionSecond; for (; *data != L'\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { wchar_t * data; CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_34_unionType myUnion; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_06.c", "text": "#define SEARCH_CHAR 'S' strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_06.c", "text": "#define SEARCH_CHAR 'S' strcpy(data, BAD_SOURCE_FIXED_STRING); { for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_16.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_16_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_16.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_16_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); { for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_62b.cpp", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #ifndef OMITGOOD void goodB2GSource(wchar_t * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_41.c", "text": "{ for (; *data != L'\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_41_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_01.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_01_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_01.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_01_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_64a.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_64_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_64b_badSink(&data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_81a.cpp", "text": "void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_81a.cpp", "text": "void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); const CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_81_base& baseObject = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_81_bad(); baseObject.action(data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_66a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_66b_badSink(wchar_t * dataArray[]); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_66_bad() { wchar_t * data; wchar_t * dataArray[5]; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_66a.c", "text": "} #endif } dataArray[2] = data; #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_66b_goodB2GSink(wchar_t * dataArray[]); static void goodB2G() { wchar_t * data; wchar_t * dataArray[5]; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_52a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_52b_badSink(wchar_t * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_52_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_52a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_52b_badSink(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_52b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_61b.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } return data; #ifndef OMITGOOD char * CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_61b_goodB2GSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_65a.c", "text": "* Sinks: * GoodSink: free() memory correctly at the start of the buffer * BadSink : free() memory not at the start of the buffer * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_65b_badSink(wchar_t * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_65b_badSink; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_65a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #endif } funcPtr(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_65b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_65b_goodB2GSink; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_17.c", "text": "{ CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); { for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { int k; char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_31.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } { wchar_t * dataCopy = data; wchar_t * data = dataCopy; for (; *data != L'\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_63a.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_63_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_63b_badSink(&data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_82a.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_82_base* baseObject = new CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_82_bad; baseObject->action(data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_66a.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } dataArray[2] = data; static void goodB2G() { char * data; char * dataArray[5]; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_21.c", "text": "static int badStatic = 0; static void badSink(char * data) { for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_21_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_21.c", "text": "static int goodB2G2Static = 0; static void goodB2G1Sink(char * data) { { size_t i; for (i=0; i < strlen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); static void goodB2G1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_21.c", "text": "} static void goodB2G2Sink(char * data) { { size_t i; for (i=0; i < strlen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); static void goodB2G2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_53a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_53b_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_53_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_53a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_53b_badSink(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_53b_goodB2GSink(char * data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67a.c", "text": "} } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } myStruct.structFirst = data; static void goodB2G() { char * data; CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType myStruct; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #include \"std_testcase.h\" /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c", "text": "fscanf (stdin, \"%u\", &data); } if(STATIC_CONST_TRUE) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_04_bad() { unsigned int data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%u\", &data); } if(STATIC_CONST_TRUE) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%u\", &data); } else { if(data > 0) { if (data < (UINT_MAX/2)) { unsigned int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_73a.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_73 void bad() { unsigned int data; list<unsigned int> dataList; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_73a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_73 void bad() { unsigned int data; list<unsigned int> dataList; data = 0; fscanf (stdin, \"%u\", &data); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { unsigned int data; list<unsigned int> dataList; data = 0; data = 2; dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { unsigned int data; list<unsigned int> dataList; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #include \"std_testcase.h\" /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_06_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c", "text": "fscanf (stdin, \"%u\", &data); if(STATIC_CONST_FIVE==5) { { unsigned int result = data + 1; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_06.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_06_bad() { unsigned int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%u\", &data); if(STATIC_CONST_FIVE==5) { { unsigned int result = data + 1; static void goodB2G1() { unsigned int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%u\", &data); else { if (data < UINT_MAX) { unsigned int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_73a.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__unsigned_int_fscanf_square_73 void bad() { unsigned int data; list<unsigned int> dataList; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_73a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__unsigned_int_fscanf_square_73 void bad() { unsigned int data; list<unsigned int> dataList; data = 0; fscanf (stdin, \"%u\", &data); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { unsigned int data; list<unsigned int> dataList; data = 0; data = 2; dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { unsigned int data; list<unsigned int> dataList; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_72a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_72a.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__unsigned_int_fscanf_square_72 void bad() { unsigned int data; vector<unsigned int> dataVector; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_72a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__unsigned_int_fscanf_square_72 void bad() { unsigned int data; vector<unsigned int> dataVector; data = 0; fscanf (stdin, \"%u\", &data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { unsigned int data; vector<unsigned int> dataVector; data = 0; data = 2; dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodB2G() { unsigned int data; vector<unsigned int> dataVector; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_44.c", "text": "unsigned int result = data * data; } } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_44.c", "text": "fscanf (stdin, \"%u\", &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(unsigned int data) { { unsigned int result = data * data; static void goodG2B() { unsigned int data; void (*funcPtr) (unsigned int) = goodG2BSink; data = 0; data = 2; funcPtr(data); } static void goodB2GSink(unsigned int data) { if (abs((long)data) < (long)sqrt((double)UINT_MAX)) { unsigned int result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { unsigned int data; void (*funcPtr) (unsigned int) = goodB2GSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_22a.c", "text": "int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_22a.c", "text": "int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badGlobal = 1; CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G1Sink(unsigned int data); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_22a.c", "text": "int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badGlobal = 1; CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G1Sink(unsigned int data); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G1Global = 0; CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G1Sink(data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_22_goodB2G2Sink(unsigned int data); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #include \"std_testcase.h\" /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07.c", "text": "fscanf (stdin, \"%u\", &data); } if(staticFive==5) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_07_bad() { unsigned int data; data = 0; if(staticFive==5) { fscanf (stdin, \"%u\", &data); } if(staticFive==5) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; if(staticFive==5) { fscanf (stdin, \"%u\", &data); } else { if(data > 0) { if (data < (UINT_MAX/2)) { unsigned int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_67a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_square_67b_badSink(CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_bad() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_67a.c", "text": "typedef struct _CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType { unsigned int structFirst; } CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType; #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_67b_badSink(CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_bad() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct; data = 0; fscanf (stdin, \"%u\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__unsigned_int_fscanf_square_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_67b_goodG2BSink(CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct); static void goodG2B() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct; data = 0; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__unsigned_int_fscanf_square_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_67b_goodB2GSink(CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct); static void goodB2G() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_square_67_structType myStruct; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_10_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c", "text": "fscanf (stdin, \"%u\", &data); if(globalTrue) { { unsigned int result = data * data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_10.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_10_bad() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); if(globalTrue) { { unsigned int result = data * data; static void goodB2G1() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); else { if (abs((long)data) < (long)sqrt((double)UINT_MAX)) { unsigned int result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_17.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_17_bad() { int i,j; unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_17.c", "text": "fscanf (stdin, \"%u\", &data); } for(j = 0; j < 1; j++) { if(data > 0) { unsigned int result = data * 2; static void goodB2G() { int i,k; unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_42.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static unsigned int badSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_42.c", "text": "#ifndef OMITBAD static unsigned int badSource(unsigned int data) { fscanf (stdin, \"%u\", &data); return data; } void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_42_bad() { unsigned int data; data = 0; data = badSource(data); if(data > 0) { unsigned int result = data * 2; #ifndef OMITGOOD static unsigned int goodG2BSource(unsigned int data) { data = 2; return data; static void goodG2B() { unsigned int data; data = 0; data = goodG2BSource(data); if(data > 0) { unsigned int result = data * 2; } static unsigned int goodB2GSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__unsigned_int_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_82 void bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__unsigned_int_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_82 void bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_bad; baseObject->action(data); static void goodG2B() { unsigned int data; data = 0; data = 2; CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_goodG2B; baseObject->action(data); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54b_goodG2BSink(unsigned int data); static void goodG2B() { unsigned int data; data = 0; data = 2; CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_54b_goodB2GSink(unsigned int data); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_18.c", "text": "fscanf (stdin, \"%u\", &data); goto sink; sink: if(data > 0) { unsigned int result = data * 2; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12_bad() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); else { data = 2; } if(globalReturnsTrueOrFalse()) { if(data > 0) { unsigned int result = data * 2; } else { if(data > 0) { if (data < (UINT_MAX/2)) { unsigned int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_12_bad() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); else { data = 2; } if(globalReturnsTrueOrFalse()) { if(data > 0) { unsigned int result = data * 2; } else { if(data > 0) { if (data < (UINT_MAX/2)) { unsigned int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_06.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #include <inttypes.h> /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_06_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(STATIC_CONST_FIVE==5) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_06.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_06_bad() { int64_t data; data = 0LL; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); if(STATIC_CONST_FIVE==5) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX)) { int64_t result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_03.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_03_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(5==5) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_03.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_03_bad() { int64_t data; data = 0LL; if(5==5) { fscanf (stdin, \"%\" SCNd64, &data); if(5==5) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; if(5==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX)) { int64_t result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_14.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_14_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(globalFive==5) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_14.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_14_bad() { int64_t data; data = 0LL; if(globalFive==5) { fscanf (stdin, \"%\" SCNd64, &data); if(globalFive==5) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; if(globalFive==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX)) { int64_t result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_square_81.h\" namespace CWE190_Integer_Overflow__int_fscanf_square_81", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_square_81.h\" namespace CWE190_Integer_Overflow__int_fscanf_square_81 void bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_square_81.h\" namespace CWE190_Integer_Overflow__int_fscanf_square_81 int data; data = 0; fscanf(stdin, \"%d\", &data); const CWE190_Integer_Overflow__int_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__int_fscanf_square_81_bad(); data = 0; data = 2; const CWE190_Integer_Overflow__int_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__int_fscanf_square_81_goodG2B();", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_81a.cpp", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference * */ #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_square_81.h\" namespace CWE190_Integer_Overflow__int_fscanf_square_81 void bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); const CWE190_Integer_Overflow__int_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__int_fscanf_square_81_bad(); baseObject.action(data); static void goodG2B() { int data; data = 0; data = 2; const CWE190_Integer_Overflow__int_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__int_fscanf_square_81_goodG2B(); baseObject.action(data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_41.c", "text": "int result = data * data; } } void CWE190_Integer_Overflow__int_fscanf_square_41_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_41.c", "text": "data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_41.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(int data) { { int result = data * data; static void goodG2B() { int data; data = 0; data = 2; goodG2BSink(data); } static void goodB2GSink(int data) { if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX)) { int result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_add_06.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_add_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_add_66_bad() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_add_66_bad() int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(dataArray); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_66b_goodG2BSink(int dataArray[]); data = 2; dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_add_66b_goodG2BSink(dataArray); } void CWE190_Integer_Overflow__int_fscanf_add_66b_goodB2GSink(int dataArray[]);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_add_66_bad() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(dataArray); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_66b_goodG2BSink(int dataArray[]); static void goodG2B() { int data; int dataArray[5]; data = 0; data = 2; dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_add_66b_goodG2BSink(dataArray); } void CWE190_Integer_Overflow__int_fscanf_add_66b_goodB2GSink(int dataArray[]); static void goodB2G() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_08.c", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_08.c", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(staticReturnsTrue()) { { int result = data + 1; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_08.c", "text": "fscanf(stdin, \"%d\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_08.c", "text": "{ int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(staticReturnsTrue()) { { int result = data + 1; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_67a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_add_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_67a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_add_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_67a.c", "text": "#include \"std_testcase.h\" typedef struct _CWE190_Integer_Overflow__int_fscanf_add_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fscanf_add_67_structType; #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_add_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_67b_goodG2BSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_add_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__int_fscanf_add_67b_goodB2GSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_67a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_add_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_67b_goodG2BSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct; data = 0; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_add_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__int_fscanf_add_67b_goodB2GSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct); static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_square_06.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #include <math.h> /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_22_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_22_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_22_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 1; CWE190_Integer_Overflow__int_fscanf_add_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Sink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_22_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 1; CWE190_Integer_Overflow__int_fscanf_add_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Sink(int data); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_22_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 1; CWE190_Integer_Overflow__int_fscanf_add_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Sink(int data); int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Global = 0; CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Sink(data); } void CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G2Sink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_22a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_22_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_22_badGlobal = 1; CWE190_Integer_Overflow__int_fscanf_add_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__int_fscanf_add_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Sink(int data); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Global = 0; CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G1Sink(data); } void CWE190_Integer_Overflow__int_fscanf_add_22_goodB2G2Sink(int data); static void goodB2G2() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_16.c", "text": "data = 0; while(1) { fscanf(stdin, \"%d\", &data); } while(1) { if(data > 0) { int result = data * 2; static void goodB2G() { int data; data = 0; while(1) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_12.c", "text": "{ int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = 2; } if(globalReturnsTrueOrFalse()) { if(data > 0) { int result = data * 2; } else { if(data > 0) { if (data < (INT_MAX/2)) { int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_12.c", "text": "if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = 2; } if(globalReturnsTrueOrFalse()) { if(data > 0) { int result = data * 2; } else { if(data > 0) { if (data < (INT_MAX/2)) { int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); } else { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_84_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_square_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_square_53_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_square_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_square_53_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_square_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_square_53_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_square_53b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_square_53b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_square_53b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_square_53b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_53a.c", "text": "* Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_square_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_square_53_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_square_53b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_square_53b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_square_53b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_square_53b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_21.c", "text": "static int badStatic = 0; static void badSink(int data) if(badStatic) { { int result = data + 1; } } void CWE190_Integer_Overflow__int_fscanf_add_21_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_21.c", "text": "static int badStatic = 0; static void badSink(int data) if(badStatic) { { int result = data + 1; } } void CWE190_Integer_Overflow__int_fscanf_add_21_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(int data) else { if (data < INT_MAX) { int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_21.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_21.c", "text": "else { if (data < INT_MAX) { int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(int data) if(goodB2G2Static) { if (data < INT_MAX) { int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_14.c", "text": "data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data); } if(globalFive==5) { if(data > 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_14.c", "text": "if(globalFive==5) { fscanf(stdin, \"%d\", &data); } if(globalFive==5) { if(data > 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data); } else { if(data > 0) { if (data < (INT_MAX/2)) { int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_multiply_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_multiply_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_multiply_51_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_multiply_51b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_multiply_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_multiply_51b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_51a.c", "text": "* Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_multiply_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_multiply_51b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_multiply_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_multiply_51b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_10.c", "text": "data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data); } if(globalTrue) { if(data > 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_10.c", "text": "if(globalTrue) { fscanf(stdin, \"%d\", &data); } if(globalTrue) { if(data > 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data); } else { if(data > 0) { if (data < (INT_MAX/2)) { int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_square_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_square_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_square_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_square_68_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_square_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_square_68_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_square_68_badData = data; CWE190_Integer_Overflow__int_fscanf_square_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_square_68b_goodG2BSink(); void CWE190_Integer_Overflow__int_fscanf_square_68b_goodB2GSink(); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_square_68_goodG2BData = data; CWE190_Integer_Overflow__int_fscanf_square_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_68a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_square_68_badData; int CWE190_Integer_Overflow__int_fscanf_square_68_goodG2BData; int CWE190_Integer_Overflow__int_fscanf_square_68_goodB2GData; #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_square_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_square_68_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_square_68_badData = data; CWE190_Integer_Overflow__int_fscanf_square_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_square_68b_goodG2BSink(); void CWE190_Integer_Overflow__int_fscanf_square_68b_goodB2GSink(); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_square_68_goodG2BData = data; CWE190_Integer_Overflow__int_fscanf_square_68b_goodG2BSink(); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_51_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_51b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_add_51b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_51a.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_add_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_51b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_add_51b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_13.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_multiply_13_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_13.c", "text": "fscanf (stdin, \"%hd\", &data); } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { short result = data * 2; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_13.c", "text": "void CWE190_Integer_Overflow__short_fscanf_multiply_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { short result = data * 2; static void goodB2G1() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); } else { if(data > 0) { if (data < (SHRT_MAX/2)) { short result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_83_bad.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__short_fscanf_add_83.h\" namespace CWE190_Integer_Overflow__short_fscanf_add_83 { CWE190_Integer_Overflow__short_fscanf_add_83_bad::CWE190_Integer_Overflow__short_fscanf_add_83_bad(short dataCopy) { data = dataCopy; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_10.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_10_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_10.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalTrue) { { short result = data + 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_10.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, \"%hd\", &data); if(globalTrue) { { short result = data + 1; static void goodB2G1() { short data; data = 0; if(globalTrue) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { short result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_21.c", "text": "static int badStatic = 0; static void badSink(short data) { if(badStatic) { if(data > 0) { short result = data * 2; } } void CWE190_Integer_Overflow__short_fscanf_multiply_21_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_21.c", "text": "{ if(badStatic) { if(data > 0) { short result = data * 2; } } void CWE190_Integer_Overflow__short_fscanf_multiply_21_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(short data) } else { if(data > 0) { if (data < (SHRT_MAX/2)) { short result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_21.c", "text": "if(data > 0) { if (data < (SHRT_MAX/2)) { short result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(short data) { if(goodB2G2Static) { if(data > 0) { if (data < (SHRT_MAX/2)) { short result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_11.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_11_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_11.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalReturnsTrue()) { { short result = data + 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_11.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_11_bad() { short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data); if(globalReturnsTrue()) { { short result = data + 1; static void goodB2G1() { short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { short result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__short_fscanf_multiply_81.h\" namespace CWE190_Integer_Overflow__short_fscanf_multiply_81 void bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__short_fscanf_multiply_81.h\" namespace CWE190_Integer_Overflow__short_fscanf_multiply_81 void bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); const CWE190_Integer_Overflow__short_fscanf_multiply_81_base& baseObject = CWE190_Integer_Overflow__short_fscanf_multiply_81_bad(); baseObject.action(data); static void goodG2B() { short data; data = 0; data = 2; const CWE190_Integer_Overflow__short_fscanf_multiply_81_base& baseObject = CWE190_Integer_Overflow__short_fscanf_multiply_81_goodG2B(); baseObject.action(data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_01.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_multiply_01_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_01.c", "text": "fscanf (stdin, \"%hd\", &data); if(data > 0) { short result = data * 2; static void goodG2B() { short data; data = 0; data = 2; if(data > 0) { short result = data * 2; static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_51a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_square_51b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_square_51_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_51a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_square_51b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_square_51_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE190_Integer_Overflow__short_fscanf_square_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_square_51b_goodG2BSink(short data); static void goodG2B() { short data; data = 0; data = 2; CWE190_Integer_Overflow__short_fscanf_square_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__short_fscanf_square_51b_goodB2GSink(short data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_84_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_84_bad.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__short_fscanf_add_84.h\" namespace CWE190_Integer_Overflow__short_fscanf_add_84 { CWE190_Integer_Overflow__short_fscanf_add_84_bad::CWE190_Integer_Overflow__short_fscanf_add_84_bad(short dataCopy) { data = dataCopy; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_53a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_add_53b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_add_53_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_53a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_53b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_add_53_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE190_Integer_Overflow__short_fscanf_add_53b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_add_53b_goodG2BSink(short data); static void goodG2B() { short data; data = 0; data = 2; CWE190_Integer_Overflow__short_fscanf_add_53b_goodG2BSink(data); } void CWE190_Integer_Overflow__short_fscanf_add_53b_goodB2GSink(short data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_04.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #include <math.h> /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_square_04_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_04.c", "text": "fscanf (stdin, \"%hd\", &data); if(STATIC_CONST_TRUE) { { short result = data * data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_04.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_square_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); if(STATIC_CONST_TRUE) { { short result = data * data; static void goodB2G1() { short data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); else { if (abs((long)data) <= (long)sqrt((double)SHRT_MAX)) { short result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_68a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_add_68b_badSink(); void CWE190_Integer_Overflow__short_fscanf_add_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_68a.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" short CWE190_Integer_Overflow__short_fscanf_add_68_badData; short CWE190_Integer_Overflow__short_fscanf_add_68_goodG2BData; short CWE190_Integer_Overflow__short_fscanf_add_68_goodB2GData; #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_68b_badSink(); void CWE190_Integer_Overflow__short_fscanf_add_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE190_Integer_Overflow__short_fscanf_add_68_badData = data; CWE190_Integer_Overflow__short_fscanf_add_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_add_68b_goodG2BSink(); void CWE190_Integer_Overflow__short_fscanf_add_68b_goodB2GSink(); static void goodG2B() { short data; data = 0; data = 2; CWE190_Integer_Overflow__short_fscanf_add_68_goodG2BData = data; CWE190_Integer_Overflow__short_fscanf_add_68b_goodG2BSink(); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_16.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_16_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_16.c", "text": "fscanf (stdin, \"%hd\", &data); while(1) { { short result = data + 1; static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_14.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_square_14_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_14.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { short result = data * data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_14.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_square_14_bad() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { short result = data * data; static void goodB2G1() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); else { if (abs((long)data) <= (long)sqrt((double)SHRT_MAX)) { short result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_74a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_74a.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__short_fscanf_add_74 void bad() { short data; map<int, short> dataMap; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_74a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__short_fscanf_add_74 void bad() { short data; map<int, short> dataMap; data = 0; fscanf (stdin, \"%hd\", &data); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { short data; map<int, short> dataMap; data = 0; data = 2; dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodB2G() { short data; map<int, short> dataMap; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_08.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_08_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_08.c", "text": "fscanf (stdin, \"%hd\", &data); if(staticReturnsTrue()) { { short result = data + 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_08.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_08_bad() { short data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%hd\", &data); if(staticReturnsTrue()) { { short result = data + 1; static void goodB2G1() { short data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { short result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_43.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #include <inttypes.h> #include \"std_testcase.h\" namespace CWE190_Integer_Overflow__int64_t_fscanf_add_43 #ifndef OMITBAD static void badSource(int64_t &data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_43.cpp", "text": "#include <inttypes.h> #include \"std_testcase.h\" namespace CWE190_Integer_Overflow__int64_t_fscanf_add_43 #ifndef OMITBAD static void badSource(int64_t &data) { fscanf (stdin, \"%\" SCNd64, &data); void bad() { int64_t data; data = 0LL; badSource(data); { int64_t result = data + 1; #ifndef OMITGOOD static void goodG2BSource(int64_t &data) { data = 2; static void goodG2B() { int64_t data; data = 0LL; goodG2BSource(data); { int64_t result = data + 1; } static void goodB2GSource(int64_t &data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_add_54b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_add_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_54a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_54b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_add_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_add_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_add_54b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_add_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__char_fscanf_add_54b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_45.c", "text": "char result = data + 1; } } void CWE190_Integer_Overflow__char_fscanf_add_45_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_45.c", "text": "void CWE190_Integer_Overflow__char_fscanf_add_45_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_add_45_badData = data; static void goodG2BSink() { char data = CWE190_Integer_Overflow__char_fscanf_add_45_goodG2BData; { char result = data + 1; static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_add_45_goodG2BData = data; static void goodB2GSink() { char data = CWE190_Integer_Overflow__char_fscanf_add_45_goodB2GData; if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_32.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_multiply_32_bad() { char data; char *dataPtr1 = &data; char *dataPtr2 = &data; data = ' '; { char data = *dataPtr1; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_32.c", "text": "{ char data = *dataPtr1; fscanf (stdin, \"%c\", &data); *dataPtr1 = data; } { char data = *dataPtr2; if(data > 0) { char result = data * 2; static void goodG2B() { char data; char *dataPtr1 = &data; char *dataPtr2 = &data; data = ' '; { char data = *dataPtr1; data = 2; *dataPtr1 = data; } { char data = *dataPtr2; if(data > 0) { char result = data * 2; static void goodB2G() { char data; char *dataPtr1 = &data; char *dataPtr2 = &data; data = ' '; { char data = *dataPtr1; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_83_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_83_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_83_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_83_goodB2G.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__char_fscanf_multiply_83.h\" namespace CWE190_Integer_Overflow__char_fscanf_multiply_83 { CWE190_Integer_Overflow__char_fscanf_multiply_83_goodB2G::CWE190_Integer_Overflow__char_fscanf_multiply_83_goodB2G(char dataCopy) { data = dataCopy; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_16.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_16_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_16.c", "text": "fscanf (stdin, \"%c\", &data); while(1) { { char result = data + 1; static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c", "text": "{ int64_t result = data * 2; } } void CWE190_Integer_Overflow__int64_t_fscanf_multiply_41_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_41.c", "text": "data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(int64_t data) { if(data > 0) { int64_t result = data * 2; static void goodG2B() { int64_t data; data = 0LL; data = 2; goodG2BSink(data); } static void goodB2GSink(int64_t data) { if(data > 0) { if (data < (LLONG_MAX/2)) { int64_t result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_03.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_multiply_03_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_03.c", "text": "fscanf (stdin, \"%c\", &data); } if(5==5) { if(data > 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_03.c", "text": "void CWE190_Integer_Overflow__char_fscanf_multiply_03_bad() { char data; data = ' '; if(5==5) { fscanf (stdin, \"%c\", &data); } if(5==5) { if(data > 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; if(5==5) { fscanf (stdin, \"%c\", &data); } else { if(data > 0) { if (data < (CHAR_MAX/2)) { char result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_42.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static char badSource(char data) fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_42.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static char badSource(char data) { fscanf (stdin, \"%c\", &data); return data; } void CWE190_Integer_Overflow__char_fscanf_add_42_bad() { char data; data = ' '; data = badSource(data); { char result = data + 1; #ifndef OMITGOOD static char goodG2BSource(char data) { data = 2; return data; static void goodG2B() { char data; data = ' '; data = goodG2BSource(data); { char result = data + 1; } static char goodB2GSource(char data) fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__char_fscanf_add_81.h\" namespace CWE190_Integer_Overflow__char_fscanf_add_81 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__char_fscanf_add_81.h\" namespace CWE190_Integer_Overflow__char_fscanf_add_81 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); const CWE190_Integer_Overflow__char_fscanf_add_81_base& baseObject = CWE190_Integer_Overflow__char_fscanf_add_81_bad(); baseObject.action(data); static void goodG2B() { char data; data = ' '; data = 2; const CWE190_Integer_Overflow__char_fscanf_add_81_base& baseObject = CWE190_Integer_Overflow__char_fscanf_add_81_goodG2B(); baseObject.action(data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_33.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #include <inttypes.h> #include \"std_testcase.h\" namespace CWE190_Integer_Overflow__int64_t_fscanf_add_33 void bad() { int64_t data; int64_t &dataRef = data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_33.cpp", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #include <inttypes.h> #include \"std_testcase.h\" namespace CWE190_Integer_Overflow__int64_t_fscanf_add_33 void bad() { int64_t data; int64_t &dataRef = data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); { int64_t data = dataRef; { int64_t result = data + 1; static void goodG2B() { int64_t data; int64_t &dataRef = data; data = 0LL; data = 2; { int64_t data = dataRef; { int64_t result = data + 1; static void goodB2G() { int64_t data; int64_t &dataRef = data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_12.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_12_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_12_bad() { int64_t data; data = 0LL; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%\" SCNd64, &data); else { data = 2; if(globalReturnsTrueOrFalse()) { { int64_t result = data + 1; else { if (data < LLONG_MAX) { int64_t result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_12.c", "text": "* GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_12_bad() { int64_t data; data = 0LL; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%\" SCNd64, &data); else { data = 2; if(globalReturnsTrueOrFalse()) { { int64_t result = data + 1; else { if (data < LLONG_MAX) { int64_t result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int64_t data; data = 0LL; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%\" SCNd64, &data); fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_51a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_square_51b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_square_51_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_51a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_51b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_square_51_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_square_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_square_51b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_square_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__char_fscanf_square_51b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_05_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { char result = data * data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { char result = data * data; static void goodB2G1() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); else { if (abs((long)data) <= (long)sqrt((double)CHAR_MAX)) { char result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_65a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_square_65b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_square_65_bad() { char data; void (*funcPtr) (char) = CWE190_Integer_Overflow__char_fscanf_square_65b_badSink; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_65a.c", "text": "* Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_65b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_square_65_bad() { char data; void (*funcPtr) (char) = CWE190_Integer_Overflow__char_fscanf_square_65b_badSink; data = ' '; fscanf (stdin, \"%c\", &data); funcPtr(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_square_65b_goodG2BSink(char data); static void goodG2B() { char data; void (*funcPtr) (char) = CWE190_Integer_Overflow__char_fscanf_square_65b_goodG2BSink; data = ' '; data = 2; funcPtr(data); } void CWE190_Integer_Overflow__char_fscanf_square_65b_goodB2GSink(char data); static void goodB2G() { char data; void (*funcPtr) (char) = CWE190_Integer_Overflow__char_fscanf_square_65b_goodB2GSink; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_02.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_02_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(1) { { int64_t result = data + 1; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_02.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_02_bad() { int64_t data; data = 0LL; if(1) { fscanf (stdin, \"%\" SCNd64, &data); if(1) { { int64_t result = data + 1; static void goodB2G1() { int64_t data; data = 0LL; if(1) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data < LLONG_MAX) { int64_t result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_15.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_15_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); { case 7: { int64_t result = data + 1; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_15.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_15_bad() { int64_t data; data = 0LL; { case 6: fscanf (stdin, \"%\" SCNd64, &data); { case 7: { int64_t result = data + 1; static void goodB2G1() { int64_t data; data = 0LL; { case 6: fscanf (stdin, \"%\" SCNd64, &data); break; default: if (data < LLONG_MAX) { int64_t result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_15.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_multiply_15_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_15.c", "text": "fscanf (stdin, \"%c\", &data); switch(7) { case 7: if(data > 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_15.c", "text": "void CWE190_Integer_Overflow__char_fscanf_multiply_15_bad() { char data; data = ' '; { case 6: fscanf (stdin, \"%c\", &data); switch(7) { case 7: if(data > 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; { case 6: fscanf (stdin, \"%c\", &data); printLine(\"Benign, fixed string\"); break; default: if(data > 0) { if (data < (CHAR_MAX/2)) { char result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_multiply_13_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_13.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_multiply_13_bad() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); } else { if(data > 0) { if (data < (LLONG_MAX/2)) { int64_t result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_11.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_multiply_11_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_11.c", "text": "fscanf (stdin, \"%c\", &data); } if(globalReturnsTrue()) { if(data > 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_11.c", "text": "void CWE190_Integer_Overflow__char_fscanf_multiply_11_bad() { char data; data = ' '; if(globalReturnsTrue()) { fscanf (stdin, \"%c\", &data); } if(globalReturnsTrue()) { if(data > 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; if(globalReturnsTrue()) { fscanf (stdin, \"%c\", &data); } else { if(data > 0) { if (data < (CHAR_MAX/2)) { char result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_52a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_add_52b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_add_52_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_52a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_52b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_add_52_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_add_52b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_add_52b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_add_52b_goodG2BSink(data); } void CWE190_Integer_Overflow__char_fscanf_add_52b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_51a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_multiply_51b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_multiply_51_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_51a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_multiply_51b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_multiply_51_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_multiply_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_multiply_51b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_multiply_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__char_fscanf_multiply_51b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_81a.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #include <inttypes.h> #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int64_t_fscanf_add_81.h\" namespace CWE190_Integer_Overflow__int64_t_fscanf_add_81 void bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_81a.cpp", "text": "fscanf (stdin, \"%\" SCNd64, &data); const CWE190_Integer_Overflow__int64_t_fscanf_add_81_base& baseObject = CWE190_Integer_Overflow__int64_t_fscanf_add_81_bad(); baseObject.action(data); static void goodG2B() { int64_t data; data = 0LL; data = 2; const CWE190_Integer_Overflow__int64_t_fscanf_add_81_base& baseObject = CWE190_Integer_Overflow__int64_t_fscanf_add_81_goodG2B(); baseObject.action(data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_63a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_add_63b_badSink(char * dataPtr); void CWE190_Integer_Overflow__char_fscanf_add_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_63a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_63b_badSink(char * dataPtr); void CWE190_Integer_Overflow__char_fscanf_add_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_add_63b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_add_63b_goodG2BSink(char * data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_add_63b_goodG2BSink(&data); } void CWE190_Integer_Overflow__char_fscanf_add_63b_goodB2GSink(char * data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_01.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_postinc_01_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); { data++; int result = data; static void goodG2B() { int data; data = 0; data = 2; { data++; int result = data; static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_64a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__char_fscanf_postinc_64_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_64a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__char_fscanf_postinc_64_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_postinc_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_postinc_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_postinc_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__char_fscanf_postinc_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_31.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_31.c", "text": "* GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); { char dataCopy = data; char data = dataCopy; { data++; char result = data; static void goodG2B() { char data; data = ' '; data = 2; { char dataCopy = data; char data = dataCopy; { data++; char result = data; static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_21.c", "text": "static int badStatic = 0; static void badSink(short data) if(badStatic) { { data++; short result = data; } } void CWE190_Integer_Overflow__short_fscanf_postinc_21_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_21.c", "text": "static int badStatic = 0; static void badSink(short data) if(badStatic) { { data++; short result = data; } } void CWE190_Integer_Overflow__short_fscanf_postinc_21_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(short data) else { if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_21.c", "text": "else { if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(short data) if(goodB2G2Static) { if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_postinc_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_postinc_66_bad() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_postinc_66_bad() int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(dataArray); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_66b_goodG2BSink(int dataArray[]); data = 2; dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_postinc_66b_goodG2BSink(dataArray); } void CWE190_Integer_Overflow__int_fscanf_postinc_66b_goodB2GSink(int dataArray[]);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_66a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int dataArray[]); void CWE190_Integer_Overflow__int_fscanf_postinc_66_bad() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(dataArray); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_66b_goodG2BSink(int dataArray[]); static void goodG2B() { int data; int dataArray[5]; data = 0; data = 2; dataArray[2] = data; CWE190_Integer_Overflow__int_fscanf_postinc_66b_goodG2BSink(dataArray); } void CWE190_Integer_Overflow__int_fscanf_postinc_66b_goodB2GSink(int dataArray[]); static void goodB2G() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_08.c", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(staticReturnsTrue()) { { data++; int result = data; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_08.c", "text": "if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(staticReturnsTrue()) { { data++; int result = data; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { data++; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_06.c", "text": "data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_FIVE==5) { { data++; int result = data; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_06.c", "text": "if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_FIVE==5) { { data++; int result = data; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { data++; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_09.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_09_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_09.c", "text": "fscanf (stdin, \"%c\", &data); if(GLOBAL_CONST_TRUE) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_09.c", "text": "void CWE190_Integer_Overflow__char_fscanf_postinc_09_bad() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%c\", &data); if(GLOBAL_CONST_TRUE) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { data++; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_16.c", "text": "data = 0; while(1) { fscanf(stdin, \"%d\", &data); while(1) { { data++; int result = data; static void goodB2G() { int data; data = 0; while(1) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_postinc_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_postinc_68_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_postinc_68_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_68_badData = data; CWE190_Integer_Overflow__int_fscanf_postinc_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_68b_goodG2BSink(); void CWE190_Integer_Overflow__int_fscanf_postinc_68b_goodB2GSink(); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_68_goodG2BData = data; CWE190_Integer_Overflow__int_fscanf_postinc_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_68a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_postinc_68_badData; int CWE190_Integer_Overflow__int_fscanf_postinc_68_goodG2BData; int CWE190_Integer_Overflow__int_fscanf_postinc_68_goodB2GData; #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_postinc_68_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_68_badData = data; CWE190_Integer_Overflow__int_fscanf_postinc_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_68b_goodG2BSink(); void CWE190_Integer_Overflow__int_fscanf_postinc_68b_goodB2GSink(); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_68_goodG2BData = data; CWE190_Integer_Overflow__int_fscanf_postinc_68b_goodG2BSink(); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_postinc_17_bad() { int i,j; int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_17.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); for(j = 0; j < 1; j++) { { data++; int64_t result = data; static void goodB2G() { int i,k; int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c", "text": "fscanf (stdin, \"%u\", &data); if(staticReturnsTrue()) { { data++; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_08_bad() { unsigned int data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%u\", &data); if(staticReturnsTrue()) { { data++; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%u\", &data); else { if (data < UINT_MAX) { data++; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static unsigned int badSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42.c", "text": "#ifndef OMITBAD static unsigned int badSource(unsigned int data) { fscanf (stdin, \"%u\", &data); return data; } void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42_bad() { unsigned int data; data = 0; data = badSource(data); { data++; unsigned int result = data; #ifndef OMITGOOD static unsigned int goodG2BSource(unsigned int data) { data = 2; return data; static void goodG2B() { unsigned int data; data = 0; data = goodG2BSource(data); { data++; unsigned int result = data; } static unsigned int goodB2GSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_08.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_08_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_08.c", "text": "fscanf (stdin, \"%c\", &data); if(staticReturnsTrue()) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_08.c", "text": "void CWE190_Integer_Overflow__char_fscanf_postinc_08_bad() { char data; data = ' '; if(staticReturnsTrue()) { fscanf (stdin, \"%c\", &data); if(staticReturnsTrue()) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; if(staticReturnsTrue()) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { data++; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_02.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_02_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_02.c", "text": "fscanf (stdin, \"%c\", &data); if(1) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_02.c", "text": "void CWE190_Integer_Overflow__char_fscanf_postinc_02_bad() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); if(1) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { data++; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" unsigned int CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_badData; unsigned int CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_goodG2BData; unsigned int CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_goodB2GData; #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_badData = data; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b_goodG2BSink(); void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b_goodB2GSink(); static void goodG2B() { unsigned int data; data = 0; data = 2; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68_goodG2BData = data; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b_goodG2BSink(); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_68a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__char_fscanf_postinc_68_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_68a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" char CWE190_Integer_Overflow__char_fscanf_postinc_68_badData; char CWE190_Integer_Overflow__char_fscanf_postinc_68_goodG2BData; char CWE190_Integer_Overflow__char_fscanf_postinc_68_goodB2GData; #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_68b_badSink(); void CWE190_Integer_Overflow__char_fscanf_postinc_68_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_postinc_68_badData = data; CWE190_Integer_Overflow__char_fscanf_postinc_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_postinc_68b_goodG2BSink(); void CWE190_Integer_Overflow__char_fscanf_postinc_68b_goodB2GSink(); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_postinc_68_goodG2BData = data; CWE190_Integer_Overflow__char_fscanf_postinc_68b_goodG2BSink(); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_05_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_05.c", "text": "void CWE190_Integer_Overflow__char_fscanf_postinc_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { data++; char result = data; static void goodB2G1() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { data++; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_51a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_51_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_51b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_postinc_51b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_51a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_51b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_postinc_51b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05_bad() { unsigned int data; data = 0; if(staticTrue) { fscanf (stdin, \"%u\", &data); if(staticTrue) { { data++; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_05_bad() { unsigned int data; data = 0; if(staticTrue) { fscanf (stdin, \"%u\", &data); if(staticTrue) { { data++; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; if(staticTrue) { fscanf (stdin, \"%u\", &data); else { if (data < UINT_MAX) { data++; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_45.c", "text": "data++; short result = data; } } void CWE190_Integer_Overflow__short_fscanf_postinc_45_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_45.c", "text": "void CWE190_Integer_Overflow__short_fscanf_postinc_45_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE190_Integer_Overflow__short_fscanf_postinc_45_badData = data; static void goodG2BSink() { short data = CWE190_Integer_Overflow__short_fscanf_postinc_45_goodG2BData; { data++; short result = data; static void goodG2B() { short data; data = 0; data = 2; CWE190_Integer_Overflow__short_fscanf_postinc_45_goodG2BData = data; static void goodB2GSink() { short data = CWE190_Integer_Overflow__short_fscanf_postinc_45_goodB2GData; if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_10.c", "text": "data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data); if(globalTrue) { { data++; int result = data; static void goodB2G1() { int data; data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_10.c", "text": "if(globalTrue) { fscanf(stdin, \"%d\", &data); if(globalTrue) { { data++; int result = data; static void goodB2G1() { int data; data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { data++; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(globalTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_52b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_52_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_52b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_52_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_52b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_52_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_preinc_52b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_preinc_52b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_preinc_52b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_preinc_52b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_preinc_52b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_52_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_preinc_52b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_preinc_52b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_preinc_52b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_preinc_52b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c", "text": "static int badStatic = 0; static void badSink(int64_t data) if(badStatic) { { ++data; int64_t result = data; } } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_21_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c", "text": "static int badStatic = 0; static void badSink(int64_t data) if(badStatic) { { ++data; int64_t result = data; } } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_21_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(int64_t data) else { if (data < LLONG_MAX) { ++data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_21.c", "text": "else { if (data < LLONG_MAX) { ++data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(int64_t data) if(goodB2G2Static) { if (data < LLONG_MAX) { ++data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b_badSink(int64_t data); void CWE190_Integer_Overflow__int64_t_fscanf_preinc_51_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b_badSink(int64_t data); void CWE190_Integer_Overflow__int64_t_fscanf_preinc_51_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b_goodG2BSink(int64_t data); static void goodG2B() { int64_t data; data = 0LL; data = 2; CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b_goodB2GSink(int64_t data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_12.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_preinc_12_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_12.c", "text": "* GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_preinc_12_bad() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%c\", &data); else { data = 2; if(globalReturnsTrueOrFalse()) { { ++data; char result = data; else { if (data < CHAR_MAX) { ++data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_12.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_preinc_12_bad() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%c\", &data); else { data = 2; if(globalReturnsTrueOrFalse()) { { ++data; char result = data; else { if (data < CHAR_MAX) { ++data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%c\", &data); fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65_bad() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_badSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65_bad() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_badSink; data = 0; fscanf (stdin, \"%u\", &data); funcPtr(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_goodG2BSink(unsigned int data); static void goodG2B() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_goodG2BSink; data = 0; data = 2; funcPtr(data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_goodB2GSink(unsigned int data); static void goodB2G() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_65b_goodB2GSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_14.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_preinc_14_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_14.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { ++data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_14.c", "text": "void CWE190_Integer_Overflow__short_fscanf_preinc_14_bad() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { ++data; short result = data; static void goodB2G1() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { ++data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_09.c", "text": "data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); if(GLOBAL_CONST_TRUE) { { ++data; int result = data; static void goodB2G1() { int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_09.c", "text": "if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); if(GLOBAL_CONST_TRUE) { { ++data; int result = data; static void goodB2G1() { int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { ++data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_03.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_preinc_03_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_03.c", "text": "fscanf (stdin, \"%hd\", &data); if(5==5) { { ++data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_03.c", "text": "void CWE190_Integer_Overflow__short_fscanf_preinc_03_bad() { short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); if(5==5) { { ++data; short result = data; static void goodB2G1() { short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { ++data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_preinc_13_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(GLOBAL_CONST_FIVE==5) { { ++data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_13.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_preinc_13_bad() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); if(GLOBAL_CONST_FIVE==5) { { ++data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data < LLONG_MAX) { ++data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_32.c", "text": "int data = *dataPtr1; fscanf(stdin, \"%d\", &data); *dataPtr1 = data; } { int data = *dataPtr2; { ++data; int result = data; static void goodG2B() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = 0; { int data = *dataPtr1; data = 2; *dataPtr1 = data; } { int data = *dataPtr2; { ++data; int result = data; static void goodB2G() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = 0; { int data = *dataPtr1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09.c", "text": "fscanf (stdin, \"%u\", &data); if(GLOBAL_CONST_TRUE) { { ++data; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_09_bad() { unsigned int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%u\", &data); if(GLOBAL_CONST_TRUE) { { ++data; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%u\", &data); else { if (data < UINT_MAX) { ++data; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_67a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct); void CWE190_Integer_Overflow__short_fscanf_preinc_67_bad() { short data; CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_67a.c", "text": "typedef struct _CWE190_Integer_Overflow__short_fscanf_preinc_67_structType { short structFirst; } CWE190_Integer_Overflow__short_fscanf_preinc_67_structType; #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct); void CWE190_Integer_Overflow__short_fscanf_preinc_67_bad() { short data; CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_preinc_67b_goodG2BSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct); static void goodG2B() { short data; CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct; data = 0; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__short_fscanf_preinc_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__short_fscanf_preinc_67b_goodB2GSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct); static void goodB2G() { short data; CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_22a.c", "text": "int CWE190_Integer_Overflow__char_fscanf_preinc_22_badGlobal = 0; void CWE190_Integer_Overflow__char_fscanf_preinc_22_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_preinc_22_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_22a.c", "text": "int CWE190_Integer_Overflow__char_fscanf_preinc_22_badGlobal = 0; void CWE190_Integer_Overflow__char_fscanf_preinc_22_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_preinc_22_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_preinc_22_badGlobal = 1; CWE190_Integer_Overflow__char_fscanf_preinc_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__char_fscanf_preinc_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G1Sink(char data); static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_22a.c", "text": "int CWE190_Integer_Overflow__char_fscanf_preinc_22_badGlobal = 0; void CWE190_Integer_Overflow__char_fscanf_preinc_22_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_preinc_22_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_preinc_22_badGlobal = 1; CWE190_Integer_Overflow__char_fscanf_preinc_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__char_fscanf_preinc_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G1Sink(char data); static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G1Global = 0; CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G1Sink(data); } void CWE190_Integer_Overflow__char_fscanf_preinc_22_goodB2G2Sink(char data); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_aes_encrypted_payload_11.c", "text": "* @description * CWE: 506 Embedded Malicious Code * Sinks: aes_encrypted_payload * GoodSink: Use a plaintext payload in a system call * BadSink : Use an AES encrypted payload in a system call { { BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6}; DWORD payloadLen = strlen((char *)payload); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen)) break; } payload[payloadLen] = '\\0'; if(system((char*)payload) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_aes_encrypted_payload_11.c", "text": "* @description * CWE: 506 Embedded Malicious Code * Sinks: aes_encrypted_payload * GoodSink: Use a plaintext payload in a system call * BadSink : Use an AES encrypted payload in a system call { { BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6}; DWORD payloadLen = strlen((char *)payload); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen)) break; } payload[payloadLen] = '\\0'; if(system((char*)payload) <= 0) { { char * payload = \"calc.exe\"; if(system(payload) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_aes_encrypted_payload_11.c", "text": "* @description * CWE: 506 Embedded Malicious Code * Sinks: aes_encrypted_payload * GoodSink: Use a plaintext payload in a system call * BadSink : Use an AES encrypted payload in a system call { { BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6}; DWORD payloadLen = strlen((char *)payload); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen)) break; } payload[payloadLen] = '\\0'; if(system((char*)payload) <= 0) { { char * payload = \"calc.exe\"; if(system(payload) <= 0) { { char * payload = \"calc.exe\"; if(system(payload) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_email_04.c", "text": "#define MAIL_SERVER \"smtp.gmail.com\" /* The variable below is declared \"const\", so a tool should be able to identify that reads of it will always return its int wsaDataInit = 0; struct sockaddr_in service; struct hostent *hostIP; SOCKET connectSocket = INVALID_SOCKET; char recBuffer[4096] = \"\"; break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr = *((struct in_addr*)*hostIP->h_addr_list); service.sin_port = htons(25); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_email_07.c", "text": "#define MAIL_SERVER \"smtp.gmail.com\" /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of int wsaDataInit = 0; struct sockaddr_in service; struct hostent *hostIP; SOCKET connectSocket = INVALID_SOCKET; char recBuffer[4096] = \"\"; break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr = *((struct in_addr*)*hostIP->h_addr_list); service.sin_port = htons(25); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) if (recv(connectSocket, recBuffer, sizeof(recBuffer), 0) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_11.c", "text": "if(globalReturnsTrue()) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_11.c", "text": "} recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); if(globalReturnsTrue()) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_03.c", "text": "if(5==5) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_03.c", "text": "} recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); if(5==5) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_16.c", "text": "while(1) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_16.c", "text": "} recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); while(1) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE259_Hard_Coded_Password/CWE259_Hard_Coded_Password__w32_char_42.c", "text": "strcpy(password, PASSWORD);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE259_Hard_Coded_Password/CWE259_Hard_Coded_Password__w32_char_21.c", "text": "static int badStatic = 0; static char * badSource(char * password) { if(badStatic) { strcpy(password, PASSWORD);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_62b.cpp", "text": "fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD void goodG2BSource(int &data) { data = 7; } void goodB2GSource(int &data) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_81.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_81", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_81.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_81 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_81.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_81 int data; data = -1; fscanf(stdin, \"%d\", &data); const CWE369_Divide_by_Zero__int_fscanf_modulo_81_base& baseObject = CWE369_Divide_by_Zero__int_fscanf_modulo_81_bad(); data = -1; data = 7; const CWE369_Divide_by_Zero__int_fscanf_modulo_81_base& baseObject = CWE369_Divide_by_Zero__int_fscanf_modulo_81_goodG2B();", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_81.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_81 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); const CWE369_Divide_by_Zero__int_fscanf_modulo_81_base& baseObject = CWE369_Divide_by_Zero__int_fscanf_modulo_81_bad(); baseObject.action(data); static void goodG2B() { int data; data = -1; data = 7; const CWE369_Divide_by_Zero__int_fscanf_modulo_81_base& baseObject = CWE369_Divide_by_Zero__int_fscanf_modulo_81_goodG2B(); baseObject.action(data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_44.c", "text": "printIntLine(100 % data); } void CWE369_Divide_by_Zero__int_fscanf_modulo_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_44.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int data) { printIntLine(100 % data); static void goodG2B() { int data; void (*funcPtr) (int) = goodG2BSink; data = -1; data = 7; funcPtr(data); } static void goodB2GSink(int data) { if( data != 0 ) { printIntLine(100 % data); static void goodB2G() { int data; void (*funcPtr) (int) = goodB2GSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_68a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_badSink(); void CWE369_Divide_by_Zero__int_fscanf_modulo_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_68a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_badSink(); void CWE369_Divide_by_Zero__int_fscanf_modulo_68_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_68a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_badSink(); void CWE369_Divide_by_Zero__int_fscanf_modulo_68_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_68_badData = data; CWE369_Divide_by_Zero__int_fscanf_modulo_68b_badSink(); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_goodG2BSink(); void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_goodB2GSink(); data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_68_goodG2BData = data; CWE369_Divide_by_Zero__int_fscanf_modulo_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_68a.c", "text": "int CWE369_Divide_by_Zero__int_fscanf_modulo_68_badData; int CWE369_Divide_by_Zero__int_fscanf_modulo_68_goodG2BData; int CWE369_Divide_by_Zero__int_fscanf_modulo_68_goodB2GData; #ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_badSink(); void CWE369_Divide_by_Zero__int_fscanf_modulo_68_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_68_badData = data; CWE369_Divide_by_Zero__int_fscanf_modulo_68b_badSink(); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_goodG2BSink(); void CWE369_Divide_by_Zero__int_fscanf_modulo_68b_goodB2GSink(); static void goodG2B() { int data; data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_68_goodG2BData = data; CWE369_Divide_by_Zero__int_fscanf_modulo_68b_goodG2BSink(); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_66a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_badSink(int dataArray[]); void CWE369_Divide_by_Zero__int_fscanf_modulo_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_66a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_badSink(int dataArray[]); void CWE369_Divide_by_Zero__int_fscanf_modulo_66_bad() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_66a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_badSink(int dataArray[]); void CWE369_Divide_by_Zero__int_fscanf_modulo_66_bad() int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE369_Divide_by_Zero__int_fscanf_modulo_66b_badSink(dataArray); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_goodG2BSink(int dataArray[]); data = 7; dataArray[2] = data; CWE369_Divide_by_Zero__int_fscanf_modulo_66b_goodG2BSink(dataArray); } void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_goodB2GSink(int dataArray[]);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_66a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_badSink(int dataArray[]); void CWE369_Divide_by_Zero__int_fscanf_modulo_66_bad() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE369_Divide_by_Zero__int_fscanf_modulo_66b_badSink(dataArray); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_goodG2BSink(int dataArray[]); static void goodG2B() { int data; int dataArray[5]; data = -1; data = 7; dataArray[2] = data; CWE369_Divide_by_Zero__int_fscanf_modulo_66b_goodG2BSink(dataArray); } void CWE369_Divide_by_Zero__int_fscanf_modulo_66b_goodB2GSink(int dataArray[]); static void goodB2G() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_listenSocket_63a.c", "text": "int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = (float)atof(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_listenSocket_07.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_22a.c", "text": "int CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_badSink(float data); void CWE369_Divide_by_Zero__float_fscanf_22_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_22a.c", "text": "int CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_badSink(float data); void CWE369_Divide_by_Zero__float_fscanf_22_bad() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_22a.c", "text": "int CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_badSink(float data); void CWE369_Divide_by_Zero__float_fscanf_22_bad() float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 1; CWE369_Divide_by_Zero__float_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Sink(float data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_22a.c", "text": "int CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_badSink(float data); void CWE369_Divide_by_Zero__float_fscanf_22_bad() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 1; CWE369_Divide_by_Zero__float_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Sink(float data); static void goodB2G1() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_22a.c", "text": "int CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_badSink(float data); void CWE369_Divide_by_Zero__float_fscanf_22_bad() float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 1; CWE369_Divide_by_Zero__float_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Sink(float data); float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Global = 0; CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Sink(data); } void CWE369_Divide_by_Zero__float_fscanf_22_goodB2G2Sink(float data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_22a.c", "text": "void CWE369_Divide_by_Zero__float_fscanf_22_bad() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_22_badGlobal = 1; CWE369_Divide_by_Zero__float_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__float_fscanf_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Sink(float data); static void goodB2G1() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Global = 0; CWE369_Divide_by_Zero__float_fscanf_22_goodB2G1Sink(data); } void CWE369_Divide_by_Zero__float_fscanf_22_goodB2G2Sink(float data); static void goodB2G2() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_64a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_64b_badSink(void * dataVoidPtr); void CWE369_Divide_by_Zero__int_fscanf_divide_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_64a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_64b_badSink(void * dataVoidPtr); void CWE369_Divide_by_Zero__int_fscanf_divide_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_64a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_64b_badSink(void * dataVoidPtr); void CWE369_Divide_by_Zero__int_fscanf_divide_64_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_divide_64b_badSink(&data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_divide_64b_goodG2BSink(void * dataVoidPtr); data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_divide_64b_goodG2BSink(&data); } void CWE369_Divide_by_Zero__int_fscanf_divide_64b_goodB2GSink(void * dataVoidPtr);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_64a.c", "text": "* Sinks: divide * GoodSink: Check for zero before dividing * BadSink : Divide a constant by data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_divide_64b_badSink(void * dataVoidPtr); void CWE369_Divide_by_Zero__int_fscanf_divide_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_divide_64b_badSink(&data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_divide_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int data; data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_divide_64b_goodG2BSink(&data); } void CWE369_Divide_by_Zero__int_fscanf_divide_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_68a.c", "text": "void CWE369_Divide_by_Zero__float_fscanf_68b_badSink(); void CWE369_Divide_by_Zero__float_fscanf_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_68a.c", "text": "void CWE369_Divide_by_Zero__float_fscanf_68b_badSink(); void CWE369_Divide_by_Zero__float_fscanf_68_bad() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_68a.c", "text": "void CWE369_Divide_by_Zero__float_fscanf_68b_badSink(); void CWE369_Divide_by_Zero__float_fscanf_68_bad() float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_68_badData = data; CWE369_Divide_by_Zero__float_fscanf_68b_badSink(); #ifndef OMITGOOD void CWE369_Divide_by_Zero__float_fscanf_68b_goodG2BSink(); void CWE369_Divide_by_Zero__float_fscanf_68b_goodB2GSink(); data = 0.0F; data = 2.0F; CWE369_Divide_by_Zero__float_fscanf_68_goodG2BData = data; CWE369_Divide_by_Zero__float_fscanf_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_68a.c", "text": "float CWE369_Divide_by_Zero__float_fscanf_68_badData; float CWE369_Divide_by_Zero__float_fscanf_68_goodG2BData; float CWE369_Divide_by_Zero__float_fscanf_68_goodB2GData; #ifndef OMITBAD void CWE369_Divide_by_Zero__float_fscanf_68b_badSink(); void CWE369_Divide_by_Zero__float_fscanf_68_bad() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data); CWE369_Divide_by_Zero__float_fscanf_68_badData = data; CWE369_Divide_by_Zero__float_fscanf_68b_badSink(); #ifndef OMITGOOD void CWE369_Divide_by_Zero__float_fscanf_68b_goodG2BSink(); void CWE369_Divide_by_Zero__float_fscanf_68b_goodB2GSink(); static void goodG2B() { float data; data = 0.0F; data = 2.0F; CWE369_Divide_by_Zero__float_fscanf_68_goodG2BData = data; CWE369_Divide_by_Zero__float_fscanf_68b_goodG2BSink(); static void goodB2G() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_12.c", "text": "data = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = 7; if(globalReturnsTrueOrFalse()) { printIntLine(100 / data); else { if( data != 0 ) { printIntLine(100 / data); use the GoodSink */ static void goodB2G() { int data; data = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_12.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_divide_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = 7; if(globalReturnsTrueOrFalse()) { printIntLine(100 / data); else { if( data != 0 ) { printIntLine(100 / data); use the GoodSink */ static void goodB2G() { int data; data = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); } else { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_10.c", "text": "data = 0.0F; if(globalTrue) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_10.c", "text": "data = 0.0F; if(globalTrue) { fscanf (stdin, \"%f\", &data); { { int result = (int)(100.0 / data); static void goodB2G1() { float data; data = 0.0F; if(globalTrue) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_10.c", "text": "fscanf (stdin, \"%f\", &data); data = 0.0F; if(globalTrue) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_10.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__float_fscanf_10_bad() { float data; data = 0.0F; if(globalTrue) { fscanf (stdin, \"%f\", &data); { { int result = (int)(100.0 / data); static void goodB2G1() { float data; data = 0.0F; if(globalTrue) { fscanf (stdin, \"%f\", &data); else { if(fabs(data) > 0.000001) { int result = (int)(100.0 / data); static void goodB2G2() { float data; data = 0.0F; if(globalTrue) { fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_73a.cpp", "text": "* Sinks: divide * GoodSink: Check for zero before dividing * BadSink : Divide a constant by data * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE369_Divide_by_Zero__int_fscanf_divide_73 void bad() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { int data; list<int> dataList; data = -1; data = 7; dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_01.c", "text": "data = 0.0F; fscanf (stdin, \"%f\", &data); { int result = (int)(100.0 / data); static void goodG2B() { float data; data = 0.0F; data = 2.0F; { int result = (int)(100.0 / data); static void goodB2G() { float data; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_43.cpp", "text": "#include \"std_testcase.h\" namespace CWE369_Divide_by_Zero__int_fscanf_divide_43 #ifndef OMITBAD static void badSource(int &data) { fscanf(stdin, \"%d\", &data); void bad() { int data; data = -1; badSource(data); printIntLine(100 / data); #ifndef OMITGOOD static void goodG2BSource(int &data) { data = 7; static void goodG2B() { int data; data = -1; goodG2BSource(data); printIntLine(100 / data); } static void goodB2GSource(int &data) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_07.c", "text": "data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); if(staticFive==5) { printIntLine(100 / data); static void goodB2G1() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_07.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_divide_07_bad() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); if(staticFive==5) { printIntLine(100 / data); static void goodB2G1() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); else { if( data != 0 ) { printIntLine(100 / data); static void goodB2G2() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_67a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_67b_badSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); void CWE369_Divide_by_Zero__int_fscanf_divide_67_bad() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_67a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_67b_badSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); void CWE369_Divide_by_Zero__int_fscanf_divide_67_bad() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_67a.c", "text": "#include \"std_testcase.h\" typedef struct _CWE369_Divide_by_Zero__int_fscanf_divide_67_structType { int structFirst; } CWE369_Divide_by_Zero__int_fscanf_divide_67_structType; #ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_divide_67b_badSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); void CWE369_Divide_by_Zero__int_fscanf_divide_67_bad() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE369_Divide_by_Zero__int_fscanf_divide_67b_badSink(myStruct); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_divide_67b_goodG2BSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); static void goodG2B() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct; data = 7; myStruct.structFirst = data; CWE369_Divide_by_Zero__int_fscanf_divide_67b_goodG2BSink(myStruct); } void CWE369_Divide_by_Zero__int_fscanf_divide_67b_goodB2GSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); static void goodB2G() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_67a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_67b_badSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); void CWE369_Divide_by_Zero__int_fscanf_divide_67_bad() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE369_Divide_by_Zero__int_fscanf_divide_67b_badSink(myStruct); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_divide_67b_goodG2BSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); static void goodG2B() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct; data = -1; data = 7; myStruct.structFirst = data; CWE369_Divide_by_Zero__int_fscanf_divide_67b_goodG2BSink(myStruct); } void CWE369_Divide_by_Zero__int_fscanf_divide_67b_goodB2GSink(CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct); static void goodB2G() { int data; CWE369_Divide_by_Zero__int_fscanf_divide_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_listenSocket_06.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_16.c", "text": "data = 0.0F; while(1) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_16.c", "text": "data = 0.0F; while(1) { fscanf (stdin, \"%f\", &data); { { int result = (int)(100.0 / data); static void goodB2G() { float data; data = 0.0F; while(1) { fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_33.cpp", "text": "* Sinks: divide * GoodSink: Check for zero before dividing * BadSink : Divide a constant by data * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #include \"std_testcase.h\" namespace CWE369_Divide_by_Zero__int_fscanf_divide_33 void bad() { int data; int &dataRef = data; data = -1; fscanf(stdin, \"%d\", &data); { int data = dataRef; printIntLine(100 / data); static void goodG2B() { int data; int &dataRef = data; data = -1; data = 7; { int data = dataRef; printIntLine(100 / data); static void goodB2G() { int data; int &dataRef = data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22b.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_63a.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_73a.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_10.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_10.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_10_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_10.c", "text": "tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_10.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(globalTrue) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_74b.cpp", "text": "short data = dataMap[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_74b.cpp", "text": "short data = dataMap[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void goodG2BSink(map<int, short> dataMap) { short data = dataMap[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_73b.cpp", "text": "short data = dataList.back(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_73b.cpp", "text": "short data = dataList.back(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void goodG2BSink(list<short> dataList) { short data = dataList.back(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_54e.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__negative_memmove_54e_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_54e.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__negative_memmove_54e_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_83_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__negative_memcpy_83_goodG2B::~CWE194_Unexpected_Sign_Extension__negative_memcpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_21.c", "text": "break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } } return data; void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_21.c", "text": "char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD static int goodG2B2Static = 0; static short goodG2B1Source(short data) else { data = 100-1; } return data; static void goodG2B1() { short data; data = 0; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_21.c", "text": "{ char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } static short goodG2B2Source(short data) if(goodG2B2Static) { data = 100-1; } return data; static void goodG2B2() { short data; data = 0; goodG2B2Static = 1; data = goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_72b.cpp", "text": "short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_72b.cpp", "text": "#ifndef OMITBAD void badSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_72b.cpp", "text": "short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void goodG2BSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_72b.cpp", "text": "#ifndef OMITGOOD void goodG2BSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_41.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__negative_memcpy_41_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_41.c", "text": "#ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__negative_memcpy_41_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE194_Unexpected_Sign_Extension__negative_memcpy_41_bad() { short data; data = 0; data = -1; CWE194_Unexpected_Sign_Extension__negative_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__negative_memcpy_41_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_83_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__rand_memmove_83_goodG2B::~CWE194_Unexpected_Sign_Extension__rand_memmove_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_14.c", "text": "data = 0; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_14.c", "text": "data = 0; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_14.c", "text": "{ short data; data = 0; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_14.c", "text": "data = 0; if(globalFive==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_83_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__negative_strncpy_83_goodG2B::~CWE194_Unexpected_Sign_Extension__negative_strncpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_83_goodG2B.cpp", "text": "data = 100-1; } CWE194_Unexpected_Sign_Extension__negative_strncpy_83_goodG2B::~CWE194_Unexpected_Sign_Extension__negative_strncpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_84_bad.cpp", "text": "* GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE194_Unexpected_Sign_Extension__listen_socket_memmove_84_bad::CWE194_Unexpected_Sign_Extension__listen_socket_memmove_84_bad(short dataCopy) { data = dataCopy; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; CWE194_Unexpected_Sign_Extension__listen_socket_memmove_84_bad::~CWE194_Unexpected_Sign_Extension__listen_socket_memmove_84_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_54e.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_memcpy_54e_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_54e.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_memcpy_54e_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61a.c", "text": "short CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61a.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61a.c", "text": "#ifndef OMITBAD short CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD short CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_goodG2BSource(short data); static void goodG2B() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61a.c", "text": "static void goodG2B() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_52c.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_strncpy_52c_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_52c.c", "text": "#ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_strncpy_52c_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_52c.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_strncpy_52c_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_52c.c", "text": "#ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_strncpy_52c_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_83_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__rand_memcpy_83_goodG2B::~CWE194_Unexpected_Sign_Extension__rand_memcpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_31.c", "text": "data = 0; data = (short)RAND32(); { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_31.c", "text": "{ short data; data = 0; data = (short)RAND32(); { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; data = 100-1; { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_11.c", "text": "data = 0; if(globalReturnsTrue()) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_11.c", "text": "data = 0; if(globalReturnsTrue()) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_11.c", "text": "{ short data; data = 0; if(globalReturnsTrue()) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_11.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(globalReturnsTrue()) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_11.c", "text": "data = 0; if(globalReturnsTrue()) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_18.c", "text": "{ short data; data = 0; goto source; source: WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_18.c", "text": "tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_03.c", "text": "data = 0; if(5==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_03.c", "text": "{ short data; data = 0; if(5==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_16.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_16_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_16.c", "text": "tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; while(1) { data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_82_bad.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE194_Unexpected_Sign_Extension__rand_strncpy_82 { void CWE194_Unexpected_Sign_Extension__rand_strncpy_82_bad::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_82_bad.cpp", "text": "namespace CWE194_Unexpected_Sign_Extension__rand_strncpy_82 { void CWE194_Unexpected_Sign_Extension__rand_strncpy_82_bad::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_42.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } #endif } return data; void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_84_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__negative_strncpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__negative_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_84_goodG2B.cpp", "text": "data = 100-1; } CWE194_Unexpected_Sign_Extension__negative_strncpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__negative_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { short data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45.c", "text": "#ifndef OMITBAD static void badSink() { short data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } #endif } CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData = data; static void goodG2BSink() { short data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_83_bad.cpp", "text": "data = -1; CWE194_Unexpected_Sign_Extension__negative_strncpy_83_bad::~CWE194_Unexpected_Sign_Extension__negative_strncpy_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_83_bad.cpp", "text": "data = -1; } CWE194_Unexpected_Sign_Extension__negative_strncpy_83_bad::~CWE194_Unexpected_Sign_Extension__negative_strncpy_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_42.c", "text": "data = -1; return data; void CWE194_Unexpected_Sign_Extension__negative_memmove_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_33.cpp", "text": "short data; short &dataRef = data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_33.cpp", "text": "} else { data = tempInt; #endif } { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; short &dataRef = data; data = 0; data = 100-1; { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_10.c", "text": "data = 0; if(globalTrue) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_10.c", "text": "data = 0; if(globalTrue) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_10.c", "text": "{ short data; data = 0; if(globalTrue) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_84_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__negative_memcpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__negative_memcpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_16.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_16_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_16.c", "text": "tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; while(1) { data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_21.c", "text": "static int badStatic = 0; static short badSource(short data) if(badStatic) { data = (short)RAND32(); } return data; void CWE194_Unexpected_Sign_Extension__rand_memmove_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_81_bad.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE194_Unexpected_Sign_Extension__negative_memmove_81 { void CWE194_Unexpected_Sign_Extension__negative_memmove_81_bad::action(short data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_15.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_15_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_15.c", "text": "tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_44.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_44.c", "text": "static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE194_Unexpected_Sign_Extension__rand_memmove_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; data = (short)RAND32(); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_34.c", "text": "short data; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_34_unionType myUnion; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } #endif } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_34.c", "text": "} else { data = tempInt; } #endif } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_34_unionType myUnion; data = 0; data = 100-1; myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_83_bad.cpp", "text": "* GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_83_bad::CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_83_bad(short dataCopy) { data = dataCopy; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_83_bad::~CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_42.c", "text": "data = -1; return data; void CWE194_Unexpected_Sign_Extension__negative_strncpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_42.c", "text": "void CWE194_Unexpected_Sign_Extension__negative_strncpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_43.cpp", "text": "data = -1; void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82_bad.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82 { void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82_bad::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82_bad.cpp", "text": "namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82 { void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82_bad::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_43.cpp", "text": "data = (short)RAND32(); void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_82_bad.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE194_Unexpected_Sign_Extension__listen_socket_memmove_82 { void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_82_bad::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_32.c", "text": "data = 0; { short data = *dataPtr1; data = -1; *dataPtr1 = data; } { short data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_01.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_01_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_01.c", "text": "inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_84_bad.cpp", "text": "{ CWE194_Unexpected_Sign_Extension__connect_socket_memmove_84_bad::CWE194_Unexpected_Sign_Extension__connect_socket_memmove_84_bad(short dataCopy) { data = dataCopy; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; CWE194_Unexpected_Sign_Extension__connect_socket_memmove_84_bad::~CWE194_Unexpected_Sign_Extension__connect_socket_memmove_84_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_22b.c", "text": "extern int CWE194_Unexpected_Sign_Extension__fscanf_malloc_22_badGlobal; short CWE194_Unexpected_Sign_Extension__fscanf_malloc_22_badSource(short data) { if(CWE194_Unexpected_Sign_Extension__fscanf_malloc_22_badGlobal)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_22b.c", "text": "extern int CWE194_Unexpected_Sign_Extension__fscanf_malloc_22_badGlobal; short CWE194_Unexpected_Sign_Extension__fscanf_malloc_22_badSource(short data) { if(CWE194_Unexpected_Sign_Extension__fscanf_malloc_22_badGlobal) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_10.c", "text": "{ short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_10.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_02.c", "text": "data = 0; if(1) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61a.c", "text": "short CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61a.c", "text": "short CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD short CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61b_goodG2BSource(short data); static void goodG2B() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61b_goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_64b.c", "text": "void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_64b.c", "text": "void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_64b_goodG2BSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81.h\" namespace CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81 { void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_81_bad::action(short data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_72b.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_82_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_82_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fscanf_memmove_82.h\" namespace CWE194_Unexpected_Sign_Extension__fscanf_memmove_82 { void CWE194_Unexpected_Sign_Extension__fscanf_memmove_82_goodG2B::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82_goodG2B.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82 { void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82_goodG2B::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c.c", "text": "void CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c_goodG2BSink(short data) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_74b.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad.cpp", "text": "* GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fgets_strncpy_84.h\" #define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_strncpy_84 { CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad::CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad(short dataCopy) { data = dataCopy; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad::~CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad.cpp", "text": "#define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_strncpy_84 { CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad::CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad(short dataCopy) data = dataCopy; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad::~CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_bad() dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_42.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_42.c", "text": "fscanf (stdin, \"%hd\", &data); return data; } void CWE194_Unexpected_Sign_Extension__fscanf_memmove_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_31.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_31.c", "text": "data = 0; fscanf (stdin, \"%hd\", &data); { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_31.c", "text": "short data; data = 0; fscanf (stdin, \"%hd\", &data); { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; data = 100-1; { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_33.cpp", "text": "short data; short &dataRef = data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_05.c", "text": "data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_05.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_05.c", "text": "data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_05.c", "text": "{ short data; data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_54c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_52a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #include \"std_testcase.h\" typedef struct _CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType; #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c", "text": "#include \"std_testcase.h\" typedef struct _CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType; #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b_goodG2BSink(CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b_goodG2BSink(CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_66a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_13.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_18.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_18.c", "text": "data = 0; goto source; source: fscanf (stdin, \"%hd\", &data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_18.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_18_bad() { short data; data = 0; goto source; source: fscanf (stdin, \"%hd\", &data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_54d.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_52a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_51a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct); void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_bad() { short data; CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct); void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_bad() { short data; CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_67a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_04.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_18.c", "text": "data = 0; goto source; source: WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_16.c", "text": "{ short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_33.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_33.cpp", "text": "data = 0; fscanf (stdin, \"%hd\", &data); { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_33.cpp", "text": "short data; short &dataRef = data; data = 0; fscanf (stdin, \"%hd\", &data); { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; short &dataRef = data; data = 0; data = 100-1; { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_02.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_02.c", "text": "data = 0; if(1) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_02.c", "text": "{ short data; data = 0; if(1) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81.h\" namespace CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81 { void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81_goodG2B::action(short data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_67a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_67a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__fscanf_memmove_67_structType myStruct); void CWE194_Unexpected_Sign_Extension__fscanf_memmove_67_bad() { short data; CWE194_Unexpected_Sign_Extension__fscanf_memmove_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_67a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__fscanf_memmove_67_structType myStruct); void CWE194_Unexpected_Sign_Extension__fscanf_memmove_67_bad() { short data; CWE194_Unexpected_Sign_Extension__fscanf_memmove_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_83_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_83_bad.cpp", "text": "* GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fgets_memmove_83.h\" #define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_memmove_83 { CWE194_Unexpected_Sign_Extension__fgets_memmove_83_bad::CWE194_Unexpected_Sign_Extension__fgets_memmove_83_bad(short dataCopy) { data = dataCopy; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } CWE194_Unexpected_Sign_Extension__fgets_memmove_83_bad::~CWE194_Unexpected_Sign_Extension__fgets_memmove_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_83_bad.cpp", "text": "{ CWE194_Unexpected_Sign_Extension__connect_socket_memmove_83_bad::CWE194_Unexpected_Sign_Extension__connect_socket_memmove_83_bad(short dataCopy) { data = dataCopy; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; CWE194_Unexpected_Sign_Extension__connect_socket_memmove_83_bad::~CWE194_Unexpected_Sign_Extension__connect_socket_memmove_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_08.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_64b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_64b.c", "text": "* GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_memcpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fgets_memcpy_64b_goodG2BSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_52c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_52c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_memcpy_52c_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_52c.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fgets_memcpy_52c_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fgets_strncpy_82.h\" namespace CWE194_Unexpected_Sign_Extension__fgets_strncpy_82 { void CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_goodG2B::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_06.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_06.c", "text": "#ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_memcpy_06_bad() { short data; data = 0; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_02.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_51b.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_51b_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_51b.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_51b_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63b_badSink(short * dataPtr); void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63b_badSink(short * dataPtr); void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_63_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_16.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_16.c", "text": "data = 0; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_16.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; while(1) { data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_61b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_51a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_54c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66b_badSink(short dataArray[]); void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66b_badSink(short dataArray[]); void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_66_bad() { short data; short dataArray[5]; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_33.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_33.cpp", "text": "data = 0; fscanf (stdin, \"%hd\", &data); { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_33.cpp", "text": "short data; short &dataRef = data; data = 0; fscanf (stdin, \"%hd\", &data); { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; short &dataRef = data; data = 0; data = 100-1; { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_54c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_07.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_07.c", "text": "data = 0; if(staticFive==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_07.c", "text": "{ short data; data = 0; if(staticFive==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_45.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_45.c", "text": "#ifndef OMITBAD static void badSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_45.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } #endif } CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_45_badData = data; static void goodG2BSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_62b.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_09.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_09.c", "text": "data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_09.c", "text": "{ short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_goodG2B.cpp", "text": "data = 100-1; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__fgets_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21.c", "text": "static int badStatic = 0; static short badSource(short data) { if(badStatic) { fscanf (stdin, \"%hd\", &data); } return data; } void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21.c", "text": "fscanf (stdin, \"%hd\", &data); return data; } void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_21_bad() dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_53a.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_environment_53b_badSink(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_environment_53_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_53a.c", "text": "#define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE427_Uncontrolled_Search_Path_Element__char_environment_53b_badSink(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_environment_53_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } CWE427_Uncontrolled_Search_Path_Element__char_environment_53b_badSink(data); #ifndef OMITGOOD void CWE427_Uncontrolled_Search_Path_Element__char_environment_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45.c", "text": "PUTENV(data); void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45_badData = data; static void goodG2BSink() { char * data = CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_45_goodG2BData; PUTENV(data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_42.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_42_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; data = badSource(data); PUTENV(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_68a.c", "text": "* GoodSource: Use a hardcoded path * Sink: * BadSink : Set the environment variable * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_file_68_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE427_Uncontrolled_Search_Path_Element__char_file_68_badData = data; static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_72a.cpp", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; vector<char *> dataVector; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_73a.cpp", "text": "void badSink(list<wchar_t *> dataList); void bad() { wchar_t * data; list<wchar_t *> dataList; wchar_t dataBuffer[250] = L\"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_07.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #endif size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_64a.c", "text": "{ char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_14.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_file_14_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_14.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE427_Uncontrolled_Search_Path_Element__char_environment_14_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_14.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_environment_14_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; else { strcat(data, NEW_PATH); } PUTENV(data); static void goodG2B2() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_74a.cpp", "text": "void bad() { char * data; map<int, char *> dataMap; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_14.c", "text": "#define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_console_14_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_54a.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_54b_badSink(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_54_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_54a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_54b_badSink(data); #ifndef OMITGOOD void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_badSink(&data); #ifndef OMITGOOD void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_21.c", "text": "static int badStatic = 0; static wchar_t * badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_53a.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_53b_badSink(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_53_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_53a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_53b_badSink(data); #ifndef OMITGOOD void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE780_Use_of_RSA_Algorithm_Without_OAEP/CWE780_Use_of_RSA_Algorithm_Without_OAEP__w32_08.c", "text": "#pragma comment (lib, \"Advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"String to be encrypted\" if(staticReturnsTrue()) { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE780_Use_of_RSA_Algorithm_Without_OAEP/CWE780_Use_of_RSA_Algorithm_Without_OAEP__w32_08.c", "text": "#pragma comment (lib, \"Advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"String to be encrypted\" if(staticReturnsTrue()) { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); else { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE780_Use_of_RSA_Algorithm_Without_OAEP/CWE780_Use_of_RSA_Algorithm_Without_OAEP__w32_08.c", "text": "HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); else { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); if(staticReturnsTrue()) { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE780_Use_of_RSA_Algorithm_Without_OAEP/CWE780_Use_of_RSA_Algorithm_Without_OAEP__w32_07.c", "text": "HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); else { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); if(staticFive==5) { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_10.c", "text": "if(globalTrue) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_10.c", "text": "} recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); if(globalTrue) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_08.c", "text": "if(staticReturnsTrue()) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_08.c", "text": "} recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); if(staticReturnsTrue()) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_22b.c", "text": "extern int CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_badGlobal; char * CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_badSource(char * data) WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_22b.c", "text": "extern int CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_badGlobal; char * CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_badSource(char * data) SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; } } } return data; extern int CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_goodG2B2Global; char * CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_goodG2B1Source(char * data) strcpy(data, \"hostname\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_22b.c", "text": "extern int CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_badGlobal; char * CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_badSource(char * data) SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; } } } return data; extern int CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_goodG2B2Global; char * CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_goodG2B1Source(char * data) else { strcpy(data, \"hostname\"); } return data; } char * CWE15_External_Control_of_System_or_Configuration_Setting__w32_22_goodG2B2Source(char * data) strcpy(data, \"hostname\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_18.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_18.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; WSACleanup(); } } if (!SetComputerNameA(data)) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"hostname\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_53a.c", "text": "* GoodSource: Get the hostname from a string literal * Sink: * BadSink : Set the hostname * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE15_External_Control_of_System_or_Configuration_Setting__w32_53b_badSink(char * data); void CWE15_External_Control_of_System_or_Configuration_Setting__w32_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_53a.c", "text": "#ifndef OMITBAD void CWE15_External_Control_of_System_or_Configuration_Setting__w32_53b_badSink(char * data); void CWE15_External_Control_of_System_or_Configuration_Setting__w32_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; WSACleanup(); } } CWE15_External_Control_of_System_or_Configuration_Setting__w32_53b_badSink(data); #ifndef OMITGOOD void CWE15_External_Control_of_System_or_Configuration_Setting__w32_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"hostname\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_73a.cpp", "text": "* GoodSource: Get the hostname from a string literal * Sinks: * BadSink : Set the hostname * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void bad() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_73a.cpp", "text": "void bad() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; WSACleanup(); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"hostname\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_31.c", "text": "* GoodSource: Get the hostname from a string literal * Sinks: * BadSink : Set the hostname * Flow Variant: 31 Data flow using a copy of data within the same function void CWE15_External_Control_of_System_or_Configuration_Setting__w32_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_31.c", "text": "* GoodSource: Get the hostname from a string literal * Sinks: * BadSink : Set the hostname * Flow Variant: 31 Data flow using a copy of data within the same function void CWE15_External_Control_of_System_or_Configuration_Setting__w32_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; if (!SetComputerNameA(data)) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"hostname\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_05.c", "text": "data = -1; if(staticTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_05.c", "text": "{ int data; data = -1; if(staticTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_05.c", "text": "{ int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { int data; data = -1; if(staticTrue) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B.cpp", "text": "data = 100-1; CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: rand Set data to result of rand(), which may be zero * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_63b_goodG2BSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14.c", "text": "{ int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { int data; data = -1; if(globalFive==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b.c", "text": "int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_64b.c", "text": "int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_33.cpp", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void bad() { int data; int &dataRef = data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_33.cpp", "text": "inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; int &dataRef = data; data = -1; data = 100-1; { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_12.c", "text": "data = -1; if(globalReturnsTrueOrFalse()) { data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_12.c", "text": "else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); * both branches use the GoodSource */ static void goodG2B() { int data; data = -1; if(globalReturnsTrueOrFalse()) { data = 100-1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad.cpp", "text": "data = RAND32(); CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18.c", "text": "data = -1; goto source; source: data = RAND32(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_18_bad() { int data; data = -1; goto source; source: data = RAND32(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_43.cpp", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD static void badSource(int &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_42.c", "text": "data = -1; return data; void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_06.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_06.c", "text": "{ int data; data = -1; if(STATIC_CONST_FIVE==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_15.c", "text": "data = -1; { case 6: data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_15.c", "text": "{ int data; data = -1; { case 6: data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_15.c", "text": "{ int data; data = -1; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { int data; data = -1; { case 6: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42.c", "text": "data = RAND32(); return data; void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_32.c", "text": "int *dataPtr1 = &data; int *dataPtr2 = &data; data = -1; { int data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } *dataPtr1 = data; } { int data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_32.c", "text": "*dataPtr1 = data; } { int data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = -1; { int data = *dataPtr1; data = 100-1; *dataPtr1 = data; } { int data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_08.c", "text": "data = -1; if(staticReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_08.c", "text": "data = -1; if(staticReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_08.c", "text": "{ int data; data = -1; if(staticReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34.c", "text": "data = -1; data = -1; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34.c", "text": "data = -1; data = -1; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_34_unionType myUnion; data = -1; data = 100-1; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: rand Set data to result of rand(), which may be zero * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e.c", "text": "#ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_54e_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_15.c", "text": "data = -1; { case 6: data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_15.c", "text": "{ int data; data = -1; { case 6: data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_16.c", "text": "data = -1; while(1) { data = RAND32(); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_16.c", "text": "while(1) { data = RAND32(); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_16.c", "text": "data = -1; while(1) { data = RAND32(); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; while(1) { data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_09.c", "text": "{ int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { int data; data = -1; if(GLOBAL_CONST_TRUE) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_43.cpp", "text": "data = RAND32(); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_12.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_12_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: rand Set data to result of rand(), which may be zero * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_53d_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03.c", "text": "data = -1; if(5==5) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03.c", "text": "data = -1; if(5==5) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03.c", "text": "{ int data; data = -1; if(5==5) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_03.c", "text": "data = -1; if(5==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14.c", "text": "data = -1; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14.c", "text": "data = -1; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14.c", "text": "{ int data; data = -1; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_14.c", "text": "data = -1; if(globalFive==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31.c", "text": "data = -1; data = -1; { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31.c", "text": "data = -1; data = -1; { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31.c", "text": "{ int data; data = -1; data = -1; { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; data = 100-1; { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_31.c", "text": "data = -1; data = 100-1; { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_73b.cpp", "text": "int data = dataList.back(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_73b.cpp", "text": "int data = dataList.back(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void goodG2BSink(list<int> dataList) { int data = dataList.back(); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_81_bad.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_81_bad::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_goodG2B.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: rand Set data to result of rand(), which may be zero * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_goodG2B::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_goodG2B.cpp", "text": "namespace CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_82_goodG2B::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_07.c", "text": "data = -1; if(staticFive==5) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_07.c", "text": "{ int data; data = -1; if(staticFive==5) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34.c", "text": "data = -1; data = RAND32(); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34.c", "text": "data = -1; data = RAND32(); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_34_unionType myUnion; data = -1; data = 100-1; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_03.c", "text": "data = -1; if(5==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_03.c", "text": "{ int data; data = -1; if(5==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41.c", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41.c", "text": "{ int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_badSink(data); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_41_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22a.c", "text": "int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22a.c", "text": "data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Global = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Source(int data); static void goodG2B1() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22a.c", "text": "{ int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } int CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Source(int data); static void goodG2B2() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Global = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_22_goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_64b.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_02.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_02_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b.c", "text": "* GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b_goodG2BSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22a.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22a.c", "text": "int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22a.c", "text": "data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Global = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Source(int data); static void goodG2B1() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22a.c", "text": "{ int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Source(int data); static void goodG2B2() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Global = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_22_goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13.c", "text": "data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13.c", "text": "fscanf(stdin, \"%d\", &data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_13.c", "text": "{ int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17.c", "text": "data = -1; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_17.c", "text": "int i; int data; data = -1; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int h; int data; data = -1; for(h = 0; h < 1; h++) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_82_goodG2B.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_82_goodG2B::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_83.h /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84.h /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21.c", "text": "static int badStatic = 0; static int badSource(int data) { if(badStatic) { fscanf(stdin, \"%d\", &data); } return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_21.c", "text": "static int badStatic = 0; static int badSource(int data) { if(badStatic) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83.h /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_03.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45.c", "text": "if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\\0'; } } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_45_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_52b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14.c", "text": "data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_14.c", "text": "{ int data; data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_14.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_14_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b.c", "text": "* GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b_goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04.c", "text": "data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_04.c", "text": "{ int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09.c", "text": "data = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09.c", "text": "{ int data; data = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b.c", "text": "#ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_72b.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82.h\" namespace CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07.c", "text": "data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07.c", "text": "{ int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_goodG2BSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b.c", "text": "#ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_goodG2BSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34.c", "text": "{ int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_unionType myUnion; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34.c", "text": "inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_34_unionType myUnion; data = -1; data = 100-1; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_73b.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61a.c", "text": "int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61_bad() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61a.c", "text": "int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61_bad() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_goodG2BSource(int data); static void goodG2B() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61b_goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b.c", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_72b.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11.c", "text": "data = -1; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11.c", "text": "{ int data; data = -1; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_43.cpp", "text": "#ifndef OMITBAD static void badSource(int &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82.h /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad.cpp", "text": "* GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83 { CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad(int dataCopy) { data = dataCopy; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_11.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b.c", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b.c", "text": "#ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b.c", "text": "#ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_51b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_72a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_33.cpp", "text": "void bad() { int data; int &dataRef = data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81.h\" namespace CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81.h\" namespace CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_81 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b.c", "text": "int data = dataArray[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b_goodG2BSink(int dataArray[]) { int data = dataArray[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34.c", "text": "{ int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_unionType myUnion; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34.c", "text": "inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_unionType myUnion; data = -1; data = 100-1; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_badSink(int * dataPtr); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63b_badSink(int * dataPtr); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_63_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_62a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_42.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } return data; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45.c", "text": "#ifndef OMITBAD static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45.c", "text": "{ int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02.c", "text": "data = -1; if(1) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02.c", "text": "{ int data; data = -1; if(1) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_83a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_badSink(data); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_41_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44.c", "text": "if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\\0'; } } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08.c", "text": "data = -1; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_08.c", "text": "{ int data; data = -1; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_17.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" for(j = 0; j < 1; j++) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_17.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" for(j = 0; j < 1; j++) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); for(k = 0; k < 1; k++) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_14.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" if(globalFive==5) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_14.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" if(globalFive==5) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); else { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_14.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" if(globalFive==5) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); else { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING); printLine(dest); if(globalFive==5) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_04.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their if(STATIC_CONST_TRUE) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_04.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); else { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING); printLine(dest); if(STATIC_CONST_TRUE) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_15.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" { case 6: { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_15.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" { case 6: { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); break; default: { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_15.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" { case 6: { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); break; default: { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING); printLine(dest); { case 6: { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_41.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sink: * BadSink : Remove element from list * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE123_Write_What_Where_Condition__listen_socket_41_badSink(badStruct data) * (because prev is the second field in 'list' hence * 4 bytes away on 32b machines), write prev/WHERE\" */ linkedListPrev = data.list.prev; linkedListNext = data.list.next; void CWE123_Write_What_Where_Condition__listen_socket_41_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__connect_socket_43.cpp", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(badStruct &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__connect_socket_68a.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sink: * BadSink : Remove element from list * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE123_Write_What_Where_Condition__connect_socket_68_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_52a.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sink: * BadSink : Remove element from list * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE123_Write_What_Where_Condition__listen_socket_52b_badSink(badStruct data); void CWE123_Write_What_Where_Condition__listen_socket_52_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_67a.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE123_Write_What_Where_Condition__listen_socket_67_bad() { badStruct data; CWE123_Write_What_Where_Condition__listen_socket_67_structType myStruct; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_14.c", "text": "void CWE123_Write_What_Where_Condition__listen_socket_14_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__connect_socket_09.c", "text": "void CWE123_Write_What_Where_Condition__connect_socket_09_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__connect_socket_63a.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE123_Write_What_Where_Condition__connect_socket_63_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__connect_socket_67a.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE123_Write_What_Where_Condition__connect_socket_67_bad() { badStruct data; CWE123_Write_What_Where_Condition__connect_socket_67_structType myStruct; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__connect_socket_17.c", "text": "void CWE123_Write_What_Where_Condition__connect_socket_17_bad() { int i; badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_32.c", "text": "char dataBuffer[100]; data = dataBuffer; { char * data = *dataPtr1; ; *dataPtr1 = data; } { char * data = *dataPtr2; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_32.c", "text": "; *dataPtr1 = data; } { char * data = *dataPtr2; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_32.c", "text": "char dataBuffer[100]; data = dataBuffer; { char * data = *dataPtr1; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_32.c", "text": "data = dataBuffer; { char * data = *dataPtr1; ; *dataPtr1 = data; } { char * data = *dataPtr2; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100]; data = dataBuffer; { char * data = *dataPtr1; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_13.c", "text": "void CWE665_Improper_Initialization__char_ncat_13_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_13.c", "text": "if(GLOBAL_CONST_FIVE!=5) { printLine(\"Benign, fixed string\"); } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_13.c", "text": "* BadSource: Do not initialize data properly * GoodSource: Initialize data * Sink: ncat * BadSink : Copy string to data using strncat void CWE665_Improper_Initialization__char_ncat_13_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_13.c", "text": "static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_13.c", "text": "sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_81_goodG2B.cpp", "text": "* * */ #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE665_Improper_Initialization__char_cat_81.h\" namespace CWE665_Improper_Initialization__char_cat_81 { void CWE665_Improper_Initialization__char_cat_81_goodG2B::action(char * data) const { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_04.c", "text": "sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(STATIC_CONST_TRUE) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_21.c", "text": "return data; } void CWE665_Improper_Initialization__char_ncat_21_bad() { char * data; char dataBuffer[100]; data = dataBuffer; badStatic = 1; data = badSource(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { ; } return data; void CWE665_Improper_Initialization__char_ncat_21_bad() { char * data; char dataBuffer[100]; data = dataBuffer; badStatic = 1; data = badSource(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_21.c", "text": "return data; } static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_21.c", "text": "data = badSource(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); #ifndef OMITGOOD static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { data[0] = '\\0'; } return data; static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_21.c", "text": "return data; } static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2B2Static = 1; data = goodG2B2Source(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_21.c", "text": "char dataBuffer[100]; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); } } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { data[0] = '\\0'; } return data; static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2B2Static = 1; data = goodG2B2Source(data); { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_14.c", "text": "void CWE665_Improper_Initialization__char_ncat_14_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalFive==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_14.c", "text": "if(globalFive!=5) { printLine(\"Benign, fixed string\"); } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_14.c", "text": "* BadSource: Do not initialize data properly * GoodSource: Initialize data * Sink: ncat * BadSink : Copy string to data using strncat void CWE665_Improper_Initialization__char_ncat_14_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalFive==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_14.c", "text": "static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalFive==5) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_14.c", "text": "sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalFive==5) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_45.c", "text": "#include \"std_testcase.h\" #include <wchar.h> static char * CWE665_Improper_Initialization__char_cat_45_badData; static char * CWE665_Improper_Initialization__char_cat_45_goodG2BData; #ifndef OMITBAD static void badSink() { char * data = CWE665_Improper_Initialization__char_cat_45_badData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_45.c", "text": "CWE665_Improper_Initialization__char_cat_45_badData = data; badSink(); } #endif #ifndef OMITGOOD static void goodG2BSink() { char * data = CWE665_Improper_Initialization__char_cat_45_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_45.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); void CWE665_Improper_Initialization__char_cat_45_bad() { char * data; char dataBuffer[100]; data = dataBuffer; ; CWE665_Improper_Initialization__char_cat_45_badData = data; static void goodG2BSink() { char * data = CWE665_Improper_Initialization__char_cat_45_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_05.c", "text": "; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_05.c", "text": "sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticTrue) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_04.c", "text": "* BadSource: Do not initialize data properly * GoodSource: Initialize data * Sink: cat * BadSink : Copy string to data using strcat #include <wchar.h> ; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_04.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(STATIC_CONST_TRUE) { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_11.c", "text": "void CWE665_Improper_Initialization__char_ncat_11_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_11.c", "text": "if(globalReturnsFalse()) { printLine(\"Benign, fixed string\"); } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_11.c", "text": "* BadSource: Do not initialize data properly * GoodSource: Initialize data * Sink: ncat * BadSink : Copy string to data using strncat void CWE665_Improper_Initialization__char_ncat_11_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_11.c", "text": "static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_11.c", "text": "sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_52c.c", "text": "#include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE665_Improper_Initialization__char_ncat_52c_badSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_52c.c", "text": "} } #endif #ifndef OMITGOOD void CWE665_Improper_Initialization__char_ncat_52c_goodG2BSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_52c.c", "text": "source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); #ifndef OMITGOOD void CWE665_Improper_Initialization__char_ncat_52c_goodG2BSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_51b.c", "text": "#include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE665_Improper_Initialization__char_ncat_51b_badSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_51b.c", "text": "} } #endif #ifndef OMITGOOD void CWE665_Improper_Initialization__char_ncat_51b_goodG2BSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_51b.c", "text": "source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); #ifndef OMITGOOD void CWE665_Improper_Initialization__char_ncat_51b_goodG2BSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_65b.c", "text": "* */ #include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE665_Improper_Initialization__char_ncat_65b_badSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_65b.c", "text": "} } #endif #ifndef OMITGOOD void CWE665_Improper_Initialization__char_ncat_65b_goodG2BSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_65b.c", "text": "source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); #ifndef OMITGOOD void CWE665_Improper_Initialization__char_ncat_65b_goodG2BSink(char * data) { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_09.c", "text": "#ifndef OMITBAD void CWE665_Improper_Initialization__char_cat_09_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_TRUE) { ; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_09.c", "text": "char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FALSE) { printLine(\"Benign, fixed string\"); } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_09.c", "text": "* @description * CWE: 665 Improper Initialization * BadSource: Do not initialize data properly * GoodSource: Initialize data * Sink: cat * BadSink : Copy string to data using strcat void CWE665_Improper_Initialization__char_cat_09_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_TRUE) { ; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_09.c", "text": "static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_TRUE) { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_09.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_TRUE) { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_52a.c", "text": "void CWE197_Numeric_Truncation_Error__short_fscanf_52b_badSink(short data); void CWE197_Numeric_Truncation_Error__short_fscanf_52_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_52a.c", "text": "void CWE197_Numeric_Truncation_Error__short_fscanf_52b_badSink(short data); void CWE197_Numeric_Truncation_Error__short_fscanf_52_bad() { short data; data = -1; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_08.c", "text": "data = -1; if(staticReturnsTrue()) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_51a.c", "text": "void CWE197_Numeric_Truncation_Error__short_fscanf_51b_badSink(short data); void CWE197_Numeric_Truncation_Error__short_fscanf_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_51a.c", "text": "void CWE197_Numeric_Truncation_Error__short_fscanf_51b_badSink(short data); void CWE197_Numeric_Truncation_Error__short_fscanf_51_bad() { short data; data = -1; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_03.c", "text": "data = -1; if(5==5) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_74a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82.h\" namespace CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82.h\" namespace CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64b_badSink(void * dataVoidPtr); void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64b_badSink(void * dataVoidPtr); void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64b_badSink(void * dataVoidPtr); void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64b_badSink(void * dataVoidPtr); void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65b_badSink(int data); void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65_bad() { int data; void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65b_badSink(int data); void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65_bad() { int data; void (*funcPtr) (int) = CWE197_Numeric_Truncation_Error__int_fscanf_to_short_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE242_Use_of_Inherently_Dangerous_Function/CWE242_Use_of_Inherently_Dangerous_Function__basic_02.c", "text": "* @description * CWE: 242 Use of Inherently Dangerous Function * Sinks: * GoodSink: Use fgets() for bounded user input * BadSink : Use gets() for user input if(1) { { char dest[DEST_SIZE]; char *result; /* INCIDENTAL CWE120 Buffer Overflow since gets is inherently dangerous and is result = gets(dest);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE242_Use_of_Inherently_Dangerous_Function/CWE242_Use_of_Inherently_Dangerous_Function__basic_03.c", "text": "* @description * CWE: 242 Use of Inherently Dangerous Function * Sinks: * GoodSink: Use fgets() for bounded user input * BadSink : Use gets() for user input if(5==5) { { char dest[DEST_SIZE]; char *result; /* INCIDENTAL CWE120 Buffer Overflow since gets is inherently dangerous and is result = gets(dest);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_81_goodG2B.cpp", "text": "/* * @description * CWE: 78 OS Command Injection * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_73a.cpp", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void badSink(list<wchar_t *> dataList); void bad() { wchar_t * data; list<wchar_t *> dataList; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_53a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_53b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_53_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnv * BadSink : execute command with wspawnv * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_64_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_10.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_52a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_52b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_63a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_63b_badSink(wchar_t * * dataPtr); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_63_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_41.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_41_badSink(char * data) void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_41.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_65a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_65b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_65b_badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_51a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_51b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_68a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #define EXECLP execlp #endif wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_68_badData; wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_68_goodG2BData; void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_68_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_51a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_51b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_32.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_52a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_52b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_74a.cpp", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void badSink(map<int, wchar_t *> dataMap); void bad() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_13.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_44.c", "text": "#define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_31.c", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with wspawnl * Flow Variant: 31 Data flow using a copy of data within the same function #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_31_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_65a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_65b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_65b_badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_67a.c", "text": "char * data; CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_53a.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_53a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_51a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_51b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_63a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_31.c", "text": "* GoodSource: Fixed string * Sinks: execl * BadSink : execute command with wexecl * Flow Variant: 31 Data flow using a copy of data within the same function #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_31_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_12.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_32.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_32_bad() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { wchar_t * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_04.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_45.c", "text": "#include <process.h> #define EXECV _wexecv static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_45_badData; static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_45_goodG2BData; static void badSink() { wchar_t * data = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_45_badData; { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_52a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_52b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_34.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data typedef union { wchar_t * unionFirst; wchar_t * unionSecond; void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_34_bad() { wchar_t * data; CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_34_unionType myUnion; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_41.c", "text": "#define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_41_badSink(wchar_t * data) { { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_41_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_52a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_52b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_67a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data typedef struct _CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_67_structType { wchar_t * structFirst; void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_67_bad() { wchar_t * data; CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_67_structType myStruct; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_21.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_21.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_65a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_65b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_65b_badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_53a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_53b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_53_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_32.c", "text": "char * data = *dataPtr1; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_11.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_11.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_01.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execlp_01_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_33.cpp", "text": "void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_54a.c", "text": "{ char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_popen_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_popen_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_62b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); #ifndef OMITGOOD void goodG2BSource(char * &data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_65a.c", "text": "void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_w32_spawnv_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_spawnv_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_w32_spawnv_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execv_68a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_execv_68_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_execv_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_52a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_spawnvp_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_spawnvp_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_14.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32spawnl_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_08.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_popen_08_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_08.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_31.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32spawnl_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_63a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execl_63_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_execl_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_execl_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_82a.cpp", "text": "* GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE78_OS_Command_Injection__char_console_popen_82_base* baseObject = new CWE78_OS_Command_Injection__char_console_popen_82_bad; baseObject->action(data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_51a.c", "text": "void CWE78_OS_Command_Injection__char_environment_popen_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_popen_51_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_51a.c", "text": "* GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_popen_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_popen_51_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_popen_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_popen_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_72a.cpp", "text": "* GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; vector<char *> dataVector; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_21.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE78_OS_Command_Injection__char_console_w32_spawnv_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_21.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE78_OS_Command_Injection__char_console_w32_spawnv_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_65a.c", "text": "void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_system_65b_badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_system_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_system_65b_goodG2BSink; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_22b.c", "text": "* BadSource: console Read input from the console * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() extern int CWE78_OS_Command_Injection__char_console_popen_22_badGlobal; char * CWE78_OS_Command_Injection__char_console_popen_22_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_popen_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_22b.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_popen_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_console_popen_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_65a.c", "text": "void CWE78_OS_Command_Injection__char_environment_execl_65b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_execl_65_bad() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execl_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_65a.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_execl_65b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_execl_65_bad() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execl_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_execl_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_environment_execl_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_82a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnv * BadSink : execute command with spawnv * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE78_OS_Command_Injection__char_console_w32_spawnv_82_base* baseObject = new CWE78_OS_Command_Injection__char_console_w32_spawnv_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_67a.c", "text": "void CWE78_OS_Command_Injection__char_console_system_67_bad() { char * data; CWE78_OS_Command_Injection__char_console_system_67_structType myStruct; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_console_system_67_structType myStruct; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_17.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_popen_17_bad() { int i; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { int h; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(h = 0; h < 1; h++) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_33.cpp", "text": "char * data; char * &dataRef = data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char * &dataRef = data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_04.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } if (SYSTEM(data) != 0) static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnlp_06.c", "text": "#include <process.h> void CWE78_OS_Command_Injection__char_console_w32_spawnlp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_83_goodG2B.cpp", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE78_OS_Command_Injection__char_environment_execlp_83_goodG2B::CWE78_OS_Command_Injection__char_environment_execlp_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_52a.c", "text": "void CWE78_OS_Command_Injection__char_environment_popen_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_popen_52_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_52a.c", "text": "* GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_popen_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_popen_52_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_popen_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_popen_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_41.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_spawnvp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_spawnvp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_73a.cpp", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_22b.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data extern int CWE78_OS_Command_Injection__char_console_w32_execvp_22_badGlobal; char * CWE78_OS_Command_Injection__char_console_w32_execvp_22_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_w32_execvp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_w32_execvp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_22b.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_w32_execvp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_w32_execvp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_console_w32_execvp_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_console_w32_execvp_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_41.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_popen_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_popen_41_goodG2BSink(char * data) { { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_18.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_spawnv_18_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; source: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_44.c", "text": "pipe = POPEN(data, \"w\"); void CWE78_OS_Command_Injection__char_environment_popen_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_44.c", "text": "{ FILE *pipe; pipe = POPEN(data, \"w\"); void CWE78_OS_Command_Injection__char_environment_popen_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_53a.c", "text": "{ char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_popen_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_popen_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_21.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE78_OS_Command_Injection__char_console_w32_execvp_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_21.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE78_OS_Command_Injection__char_console_w32_execvp_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_21.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; void CWE78_OS_Command_Injection__char_environment_execlp_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_21.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; void CWE78_OS_Command_Injection__char_environment_execlp_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_environment_popen_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_popen_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_popen_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_22b.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE78_OS_Command_Injection__char_environment_popen_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_popen_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_popen_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE78_OS_Command_Injection__char_environment_popen_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_environment_popen_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_22b.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE78_OS_Command_Injection__char_environment_popen_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_popen_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_popen_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE78_OS_Command_Injection__char_environment_popen_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_environment_popen_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_environment_popen_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_environment_popen_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_68a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32spawnl_68_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32spawnl_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_08.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_06.c", "text": "#include <process.h> void CWE78_OS_Command_Injection__char_console_w32_spawnv_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnlp_51a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_spawnlp_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_spawnlp_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_10.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_execvp_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_63a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_execvp_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_execvp_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_84_goodG2B.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnv * BadSink : execute command with spawnv * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE78_OS_Command_Injection__char_console_w32_spawnv_84_goodG2B::CWE78_OS_Command_Injection__char_console_w32_spawnv_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_11.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_11.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_33.cpp", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32_execvp_45.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data static void badSink() { char * data = CWE78_OS_Command_Injection__char_file_w32_execvp_45_badData; void CWE78_OS_Command_Injection__char_file_w32_execvp_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_execvp_45_badData = data; static void goodG2BSink() { char * data = CWE78_OS_Command_Injection__char_file_w32_execvp_45_goodG2BData; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_31.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32spawnl_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_33.cpp", "text": "* GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char * &dataRef = data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_08.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_08.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_67a.c", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sinks: system * BadSink : Execute command in data using system() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE78_OS_Command_Injection__char_file_system_67_bad() { char * data; CWE78_OS_Command_Injection__char_file_system_67_structType myStruct; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_file_system_67_structType myStruct; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_09.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32spawnl_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_09.c", "text": "void CWE78_OS_Command_Injection__char_file_w32spawnl_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_64_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32spawnl_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnv_31.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnv_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52a.c", "text": "void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_03.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execlp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_03.c", "text": "void CWE78_OS_Command_Injection__char_file_execlp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_42.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; void CWE78_OS_Command_Injection__char_environment_w32_execv_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_45.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv static void badSink() { char * data = CWE78_OS_Command_Injection__char_environment_w32spawnl_45_badData; void CWE78_OS_Command_Injection__char_environment_w32spawnl_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32spawnl_45_badData = data; static void goodG2BSink() { char * data = CWE78_OS_Command_Injection__char_environment_w32spawnl_45_goodG2BData; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53a.c", "text": "void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32_execvp_06.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define EXECVP _execvp void CWE78_OS_Command_Injection__char_file_w32_execvp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32_execvp_06.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_execvp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_14.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execl_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_14.c", "text": "void CWE78_OS_Command_Injection__char_file_execl_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_84_goodG2B.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with execvp * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE78_OS_Command_Injection__char_environment_w32_execvp_84_goodG2B::CWE78_OS_Command_Injection__char_environment_w32_execvp_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE78_OS_Command_Injection__char_file_popen_21_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; badStatic = 1; data = badSource(data); { FILE *pipe; pipe = POPEN(data, \"w\"); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_12.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_12.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_12.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\"); } else { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_13.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_13.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_64a.c", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE78_OS_Command_Injection__char_file_popen_64_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_popen_64b_badSink(&data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_82a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with execvp * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_execvp_82_base* baseObject = new CWE78_OS_Command_Injection__char_environment_w32_execvp_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_02.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32spawnl_02_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_02.c", "text": "void CWE78_OS_Command_Injection__char_file_w32spawnl_02_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(1) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_06.c", "text": "#endif void CWE78_OS_Command_Injection__char_file_system_06_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_06.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } if (SYSTEM(data) != 0) static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_12.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_12.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_12.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\"); } else { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_34.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execl_34_bad() { char * data; CWE78_OS_Command_Injection__char_file_execl_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_file_execl_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_01.c", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() void CWE78_OS_Command_Injection__char_file_popen_01_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_44.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) void CWE78_OS_Command_Injection__char_environment_w32spawnl_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_32.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_03.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_03.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_54a.c", "text": "* GoodSource: Fixed string * Sink: system * BadSink : Execute command in data using system() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_system_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_system_54_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_system_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_system_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_13.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_13.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_16.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32spawnl_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_10.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_10.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_42.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_04.c", "text": "#define EXECVP _execvp size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_81a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } const CWE78_OS_Command_Injection__char_environment_w32spawnl_81_base& baseObject = CWE78_OS_Command_Injection__char_environment_w32spawnl_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_12.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execl_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_12.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execl_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_12.c", "text": "void CWE78_OS_Command_Injection__char_file_execl_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\"); } else { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_22b.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data extern int CWE78_OS_Command_Injection__char_file_execl_22_badGlobal; char * CWE78_OS_Command_Injection__char_file_execl_22_badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_file_execl_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_file_execl_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_file_execl_22_badGlobal; char * CWE78_OS_Command_Injection__char_file_execl_22_badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_file_execl_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_file_execl_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_file_execl_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_file_execl_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_14.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_14.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_12.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_12.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_12.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { strcat(data, \"*.*\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"*.*\"); } else { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_81a.cpp", "text": "{ char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE78_OS_Command_Injection__char_listen_socket_popen_81_base& baseObject = CWE78_OS_Command_Injection__char_listen_socket_popen_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_81a.cpp", "text": "/* * @description * CWE: 78 OS Command Injection * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_54a.c", "text": "void CWE78_OS_Command_Injection__char_listen_socket_popen_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_popen_54_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_54a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_popen_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_popen_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_81a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE78_OS_Command_Injection__char_file_w32_spawnlp_81_base& baseObject = CWE78_OS_Command_Injection__char_file_w32_spawnlp_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_09.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_execv_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_09.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_execv_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execl_82a.cpp", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE78_OS_Command_Injection__char_listen_socket_execl_82_base* baseObject = new CWE78_OS_Command_Injection__char_listen_socket_execl_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_42.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void CWE78_OS_Command_Injection__char_listen_socket_popen_42_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; data = badSource(data); { FILE *pipe; pipe = POPEN(data, \"w\"); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_system_82.h", "text": "/* * @description * CWE: 78 OS Command Injection * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Fixed string * BadSink : Execute command in data using system()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_34.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_listen_socket_w32_execv_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_12.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnvp_18.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnvp_18_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_52a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32_spawnlp_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_w32_spawnlp_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_spawnlp_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32_spawnlp_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_72a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_02.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnlp_02_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_02.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_spawnlp_02_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(1) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnvp_53a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32_spawnvp_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_w32_spawnvp_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_spawnvp_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32_spawnvp_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_05.c", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_system_11.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } if (SYSTEM(data) != 0) static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_15.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_15.c", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; switch(6) { case 6: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_31.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_execv_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51a.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_61b.c", "text": "#ifndef OMITBAD char * CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_61b_badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_53a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32_spawnlp_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_w32_spawnlp_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_spawnlp_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32_spawnlp_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_45.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data static void badSink() { char * data = CWE78_OS_Command_Injection__char_file_w32_execv_45_badData; void CWE78_OS_Command_Injection__char_file_w32_execv_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_execv_45_badData = data; static void goodG2BSink() { char * data = CWE78_OS_Command_Injection__char_file_w32_execv_45_goodG2BData; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_04.c", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_15.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_execv_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_11.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_execv_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_11.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_execv_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_53a.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_53a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_system_14.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } if (SYSTEM(data) != 0) static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnvp_54a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32_spawnvp_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_w32_spawnvp_54_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_spawnvp_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32_spawnvp_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_07.c", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_53a.c", "text": "* GoodSource: Fixed string * Sink: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_53a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_62b.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnv * BadSink : execute command with spawnv * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_13.c", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(GLOBAL_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_82a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE78_OS_Command_Injection__char_file_w32_spawnlp_82_base* baseObject = new CWE78_OS_Command_Injection__char_file_w32_spawnlp_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_17.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { int h; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(h = 0; h < 1; h++) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_10.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_81a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE78_OS_Command_Injection__char_connect_socket_execlp_81_base& baseObject = CWE78_OS_Command_Injection__char_connect_socket_execlp_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_09.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execv_32.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execv_32.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_08.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execlp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_connect_socket_execlp_22_badGlobal; char * CWE78_OS_Command_Injection__char_connect_socket_execlp_22_badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_22b.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; extern int CWE78_OS_Command_Injection__char_connect_socket_execlp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_connect_socket_execlp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_22b.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; extern int CWE78_OS_Command_Injection__char_connect_socket_execlp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_connect_socket_execlp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_connect_socket_execlp_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_connect_socket_execlp_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_02.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(1) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_system_67a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_connect_socket_system_67_structType myStruct; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_67a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnv * BadSink : execute command with spawnv * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_67_bad() { char * data; CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_67a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_17.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execl_17_bad() { int i; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B() { int h; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; for(h = 0; h < 1; h++) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_45.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data static void badSink() { char * data = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_45_badData; void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_45.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_45_badData = data; static void goodG2BSink() { char * data = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_45_goodG2BData; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_41.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_execlp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_execlp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_12.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_22b.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data extern int CWE78_OS_Command_Injection__char_console_execl_22_badGlobal; char * CWE78_OS_Command_Injection__char_console_execl_22_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_execl_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_execl_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_22b.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_execl_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_execl_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_console_execl_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_console_execl_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_01.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execlp_01_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_44.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD static void badSink(char * data) void CWE78_OS_Command_Injection__char_connect_socket_execl_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_45.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_execlp_45_badData = data; static void goodG2BSink() { char * data = CWE78_OS_Command_Injection__char_console_execlp_45_goodG2BData; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_63a.c", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_execlp_63_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_63a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_execlp_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_execlp_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_68a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execl_68_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_execl_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_system_32.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } *dataPtr1 = data; } { char * data = *dataPtr2; if (SYSTEM(data) != 0) static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char data_buf[100] = FULL_COMMAND; data = data_buf; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_66a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_21.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void CWE78_OS_Command_Injection__char_connect_socket_popen_21_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; badStatic = 1; data = badSource(data); { FILE *pipe; pipe = POPEN(data, \"w\"); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_31.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 31 Data flow using a copy of data within the same function #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_15.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41_badSink(char * data) void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_54a.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_popen_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_popen_54_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_54a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_popen_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_61b.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD char * CWE78_OS_Command_Injection__char_console_execl_61b_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_console_execl_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_45.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_execl_45_badData = data; static void goodG2BSink() { char * data = CWE78_OS_Command_Injection__char_console_execl_45_goodG2BData; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_72a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with execvp * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void bad() { char * data; vector<char *> dataVector; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_34.c", "text": "void CWE78_OS_Command_Injection__char_console_execl_34_bad() { char * data; CWE78_OS_Command_Injection__char_console_execl_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_console_execl_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_65a.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_popen_65b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_popen_65_bad() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_popen_65b_badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_65a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_popen_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_popen_65b_goodG2BSink; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_31.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execlp_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_41.c", "text": "* GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink(char * data) { { FILE *pipe; pipe = POPEN(data, \"w\"); void CWE78_OS_Command_Injection__char_connect_socket_popen_41_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_41.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_popen_41_goodG2BSink(char * data) { { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_34.c", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_execlp_34_bad() { char * data; CWE78_OS_Command_Injection__char_connect_socket_execlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_34.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_connect_socket_execlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with execvp * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_64_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_64a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_63a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_execlp_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_execlp_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68a.c", "text": "* GoodSource: Fixed string * Sink: w32_execvp * BadSink : execute command with wexecvp * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #include <process.h> #define EXECVP _wexecvp wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68_badData; wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68_goodG2BData; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_68_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_65a.c", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with wspawnl * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_65b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32spawnl_65b_badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_22b.c", "text": "extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_22_badGlobal; wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54a.c", "text": "* GoodSource: Fixed string * Sink: w32_execvp * BadSink : execute command with wexecvp * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_54_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_system_53a.c", "text": "void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_53b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_53_bad() { wchar_t * data; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_system_63a.c", "text": "void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_63b_badSink(wchar_t * * dataPtr); void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_63_bad() { wchar_t * data; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_44.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_68a.c", "text": "* GoodSource: Fixed string * Sink: execlp * BadSink : execute command with wexeclp * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #define EXECLP execlp #endif wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_68_badData; wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_68_goodG2BData; void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_68_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_22b.c", "text": "extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_22_badGlobal; wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_44.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_67a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnv * BadSink : execute command with wspawnv * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data typedef struct _CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_67_structType { wchar_t * structFirst; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_67_bad() { wchar_t * data; CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_67_structType myStruct; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_52a.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnv * BadSink : execute command with wspawnv * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_52b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_45.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #include <process.h> static wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_45_badData; static wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_45_goodG2BData; static void badSink() { wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_45_badData; { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_73a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with wspawnlp * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void badSink(list<wchar_t *> dataList); void bad() { wchar_t * data; list<wchar_t *> dataList; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_74a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with wexecv * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void badSink(map<int, wchar_t *> dataMap); void bad() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__connect_socket_fwrite_31.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__connect_socket_fwrite_31.c", "text": "service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_17.c", "text": "count = -1; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_17.c", "text": "count = -1; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &count); } for(j = 0; j < 1; j++) { SLEEP(count); static void goodB2G() { int i,k; int count; count = -1; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_51a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_sleep_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_51a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_sleep_51_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_51a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_sleep_51_bad() int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(count); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodG2BSink(int count); count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodG2BSink(count); } void CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodB2GSink(int count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_51a.c", "text": "* GoodSource: Assign count to be a relatively small number * Sinks: sleep * GoodSink: Validate count before using it as a parameter in sleep function * BadSink : Use count as the parameter for sleep withhout checking it's size first #ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_sleep_51_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_sleep_51b_badSink(count); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodG2BSink(int count); static void goodG2B() { int count; count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodG2BSink(count); } void CWE400_Resource_Exhaustion__fscanf_sleep_51b_goodB2GSink(int count); static void goodB2G() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_84_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_12.c", "text": "count = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_12.c", "text": "#ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_12_bad() { int count; count = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &count); else { count = 20; { exit(1); } for (i = 0; i < (size_t)count; i++) size_t i = 0; FILE *pFile = NULL; const char *filename = \"output_good.txt\"; if (count > 0 && count <= 20) { exit(1); } for (i = 0; i < (size_t)count; i++) use the GoodSink */ static void goodB2G() { int count; count = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_12.c", "text": "fscanf(stdin, \"%d\", &count); count = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_12.c", "text": "{ int count; count = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &count); else { count = 20; { exit(1); } for (i = 0; i < (size_t)count; i++) size_t i = 0; FILE *pFile = NULL; const char *filename = \"output_good.txt\"; if (count > 0 && count <= 20) { exit(1); } for (i = 0; i < (size_t)count; i++) use the GoodSink */ static void goodB2G() { int count; count = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &count); } else { fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_84_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_09.c", "text": "count = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &count); { { size_t i = 0; for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_09.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_09_bad() { int count; count = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &count); { { size_t i = 0; for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &count); { { size_t i = 0; if (count > 0 && count <= 20) { for (i = 0; i < (size_t)count; i++) static void goodB2G2() { int count; count = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c", "text": "int CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c", "text": "int CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c", "text": "int CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad() int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 1; CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(count); #ifndef OMITGOOD int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(int count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c", "text": "int CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 1; CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(count); #ifndef OMITGOOD int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(int count); static void goodB2G1() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c", "text": "int CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad() int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 1; CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(count); #ifndef OMITGOOD int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(int count); int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global = 0; CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(count); } void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Sink(int count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_22a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_22_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_22_badGlobal = 1; CWE400_Resource_Exhaustion__fscanf_for_loop_22_badSink(count); #ifndef OMITGOOD int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Global = 0; int CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodG2BGlobal = 0; void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(int count); static void goodB2G1() { int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Global = 0; CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G1Sink(count); } void CWE400_Resource_Exhaustion__fscanf_for_loop_22_goodB2G2Sink(int count); static void goodB2G2() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_83_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_07.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #define SENTENCE \"This is the sentence we are printing to the file. \" /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_54e.c", "text": "#define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" #endif #ifdef _WIN32 #define SYSTEM system #else #define SYSTEM system #endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_system_54e_badSink(char * data) { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_54e.c", "text": "if (SYSTEM(data) <= 0) { printLine(\"command execution failed!\"); exit(1); } } #endif #ifndef OMITGOOD void CWE426_Untrusted_Search_Path__char_system_54e_goodG2BSink(char * data) { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_53a.c", "text": "* GoodSource: Specify the full path in the OS command * Sink: popen * BadSink : Execute the popen function * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_popen_53b_badSink(char * data); void CWE426_Untrusted_Search_Path__char_popen_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_53a.c", "text": "* GoodSource: Specify the full path in the OS command * Sink: popen * BadSink : Execute the popen function * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files * and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_popen_53b_badSink(char * data); void CWE426_Untrusted_Search_Path__char_popen_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); CWE426_Untrusted_Search_Path__char_popen_53b_badSink(data); #ifndef OMITGOOD void CWE426_Untrusted_Search_Path__char_popen_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_17.c", "text": "#define SYSTEM system #endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_system_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { strcpy(data, BAD_OS_COMMAND); } /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_17.c", "text": "#endif #ifndef OMITGOOD static void goodG2B() { int h; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(h = 0; h < 1; h++) { strcpy(data, GOOD_OS_COMMAND); } /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_17.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void CWE426_Untrusted_Search_Path__char_system_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_17.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_system_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { strcpy(data, BAD_OS_COMMAND); } if (SYSTEM(data) <= 0) static void goodG2B() { int h; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_84_bad.cpp", "text": "#define SYSTEM system #else #define SYSTEM system #endif namespace CWE426_Untrusted_Search_Path__char_system_84 { CWE426_Untrusted_Search_Path__char_system_84_bad::CWE426_Untrusted_Search_Path__char_system_84_bad(char * dataCopy) { data = dataCopy; strcpy(data, BAD_OS_COMMAND); } CWE426_Untrusted_Search_Path__char_system_84_bad::~CWE426_Untrusted_Search_Path__char_system_84_bad() { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_84_bad.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: system * BadSink : Execute the system function * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE426_Untrusted_Search_Path__char_system_84_bad::CWE426_Untrusted_Search_Path__char_system_84_bad(char * dataCopy) { data = dataCopy; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_02.c", "text": "#endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_popen_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(1) { strcpy(data, BAD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_02.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(0) { printLine(\"Benign, fixed string\"); } else { strcpy(data, GOOD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_02.c", "text": "} } static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(1) { strcpy(data, GOOD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_02.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void CWE426_Untrusted_Search_Path__char_popen_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_02.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(1) { strcpy(data, BAD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_02.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(1) { strcpy(data, BAD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, GOOD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_52c.c", "text": "#define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" #endif #ifdef _WIN32 #define SYSTEM system #else #define SYSTEM system #endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_system_52c_badSink(char * data) { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_52c.c", "text": "if (SYSTEM(data) <= 0) { printLine(\"command execution failed!\"); exit(1); } } #endif #ifndef OMITGOOD void CWE426_Untrusted_Search_Path__char_system_52c_goodG2BSink(char * data) { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_22b.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" extern int CWE426_Untrusted_Search_Path__char_popen_22_badGlobal; char * CWE426_Untrusted_Search_Path__char_popen_22_badSource(char * data) strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_22b.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" extern int CWE426_Untrusted_Search_Path__char_popen_22_badGlobal; char * CWE426_Untrusted_Search_Path__char_popen_22_badSource(char * data) if(CWE426_Untrusted_Search_Path__char_popen_22_badGlobal) { strcpy(data, BAD_OS_COMMAND); } return data; extern int CWE426_Untrusted_Search_Path__char_popen_22_goodG2B2Global; char * CWE426_Untrusted_Search_Path__char_popen_22_goodG2B1Source(char * data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_22b.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" extern int CWE426_Untrusted_Search_Path__char_popen_22_badGlobal; char * CWE426_Untrusted_Search_Path__char_popen_22_badSource(char * data) if(CWE426_Untrusted_Search_Path__char_popen_22_badGlobal) { strcpy(data, BAD_OS_COMMAND); } return data; extern int CWE426_Untrusted_Search_Path__char_popen_22_goodG2B2Global; char * CWE426_Untrusted_Search_Path__char_popen_22_goodG2B1Source(char * data) else { strcpy(data, GOOD_OS_COMMAND); } return data; } char * CWE426_Untrusted_Search_Path__char_popen_22_goodG2B2Source(char * data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_64b.c", "text": "#endif #ifdef _WIN32 #define SYSTEM system #else #define SYSTEM system #endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_system_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_64b.c", "text": "printLine(\"command execution failed!\"); exit(1); } } #endif #ifndef OMITGOOD void CWE426_Untrusted_Search_Path__char_system_64b_goodG2BSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_45.c", "text": "#define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static char * CWE426_Untrusted_Search_Path__char_popen_45_badData; static char * CWE426_Untrusted_Search_Path__char_popen_45_goodG2BData; #ifndef OMITBAD static void badSink() { char * data = CWE426_Untrusted_Search_Path__char_popen_45_badData; { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_45.c", "text": "strcpy(data, BAD_OS_COMMAND); CWE426_Untrusted_Search_Path__char_popen_45_badData = data; badSink(); } #endif #ifndef OMITGOOD static void goodG2BSink() { char * data = CWE426_Untrusted_Search_Path__char_popen_45_goodG2BData; { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_45.c", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" static void badSink() { char * data = CWE426_Untrusted_Search_Path__char_popen_45_badData; FILE *pipe; pipe = POPEN(data, \"wb\"); void CWE426_Untrusted_Search_Path__char_popen_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_45.c", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file * and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" static void badSink() { char * data = CWE426_Untrusted_Search_Path__char_popen_45_badData; FILE *pipe; pipe = POPEN(data, \"wb\"); void CWE426_Untrusted_Search_Path__char_popen_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); CWE426_Untrusted_Search_Path__char_popen_45_badData = data; static void goodG2BSink() { char * data = CWE426_Untrusted_Search_Path__char_popen_45_goodG2BData; FILE *pipe; pipe = POPEN(data, \"wb\"); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_74a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_74a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files * and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_81_bad.cpp", "text": "#ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif namespace CWE426_Untrusted_Search_Path__char_popen_81 { void CWE426_Untrusted_Search_Path__char_popen_81_bad::action(char * data) const { { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_22b.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" extern int CWE426_Untrusted_Search_Path__char_system_22_badGlobal; char * CWE426_Untrusted_Search_Path__char_system_22_badSource(char * data) strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_22b.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" extern int CWE426_Untrusted_Search_Path__char_system_22_badGlobal; char * CWE426_Untrusted_Search_Path__char_system_22_badSource(char * data) if(CWE426_Untrusted_Search_Path__char_system_22_badGlobal) { strcpy(data, BAD_OS_COMMAND); } return data; extern int CWE426_Untrusted_Search_Path__char_system_22_goodG2B2Global; char * CWE426_Untrusted_Search_Path__char_system_22_goodG2B1Source(char * data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_22b.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" extern int CWE426_Untrusted_Search_Path__char_system_22_badGlobal; char * CWE426_Untrusted_Search_Path__char_system_22_badSource(char * data) if(CWE426_Untrusted_Search_Path__char_system_22_badGlobal) { strcpy(data, BAD_OS_COMMAND); } return data; extern int CWE426_Untrusted_Search_Path__char_system_22_goodG2B2Global; char * CWE426_Untrusted_Search_Path__char_system_22_goodG2B1Source(char * data) else { strcpy(data, GOOD_OS_COMMAND); } return data; } char * CWE426_Untrusted_Search_Path__char_system_22_goodG2B2Source(char * data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_81a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: system * BadSink : Execute the system function * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_81a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: system * BadSink : Execute the system function * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); const CWE426_Untrusted_Search_Path__char_system_81_base& baseObject = CWE426_Untrusted_Search_Path__char_system_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_16.c", "text": "#define SYSTEM system #endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_system_16_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { strcpy(data, BAD_OS_COMMAND); break; } /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_16.c", "text": "#endif #ifndef OMITGOOD static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { strcpy(data, GOOD_OS_COMMAND); break; } /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_16.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void CWE426_Untrusted_Search_Path__char_system_16_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_16.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_system_16_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { strcpy(data, BAD_OS_COMMAND); } if (SYSTEM(data) <= 0) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_61a.c", "text": "#define PCLOSE pclose #endif #ifndef OMITBAD char * CWE426_Untrusted_Search_Path__char_popen_61b_badSource(char * data); void CWE426_Untrusted_Search_Path__char_popen_61_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE426_Untrusted_Search_Path__char_popen_61b_badSource(data); { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_61a.c", "text": "#endif #ifndef OMITGOOD char * CWE426_Untrusted_Search_Path__char_popen_61b_goodG2BSource(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE426_Untrusted_Search_Path__char_popen_61b_goodG2BSource(data); { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE223_Omission_of_Security_Relevant_Information/CWE223_Omission_of_Security_Relevant_Information__w32_10.c", "text": "* @description * CWE: 223 Omission of Security Relevant Information * Sinks: * GoodSink: Log the username WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; char username[USERNAME_SZ+1]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))", "label": 1}
{"id": null, "file": "../../C/testcases/CWE223_Omission_of_Security_Relevant_Information/CWE223_Omission_of_Security_Relevant_Information__w32_10.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0)) { break; } username[USERNAME_SZ] = '\\0'; fprintf(stderr, \"Attempted login\\n\"); if (LogonUserA( username, } } while (0); if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; char username[USERNAME_SZ+1]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))", "label": 1}
{"id": null, "file": "../../C/testcases/CWE223_Omission_of_Security_Relevant_Information/CWE223_Omission_of_Security_Relevant_Information__w32_10.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0)) { break; } username[USERNAME_SZ] = '\\0'; fprintf(stderr, \"Attempted login by %s\\n\", username); if (LogonUserA( username, } } while (0); if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; char username[USERNAME_SZ+1]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s05/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_open_54a.cpp", "text": "void badSink_b(wchar_t * data); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s05/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_open_05.cpp", "text": "void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s05/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_open_63a.cpp", "text": "void badSink(wchar_t * * dataPtr); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s05/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_w32CreateFile_44.cpp", "text": "hFile = CreateFileW(data, void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s05/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_open_65a.cpp", "text": "void badSink(wchar_t * data); void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_31.cpp", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_31.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_12.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_12.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); else { strcat(data, \"file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_12.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); else { strcat(data, \"file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"file.txt\"); strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_51a.cpp", "text": "void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_51a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: open * BadSink : Open the file named in data using open() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_18.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_82a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE23_Relative_Path_Traversal__char_file_ofstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_file_ofstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_17.cpp", "text": "int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_open_12.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); else { strcat(data, \"file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_open_12.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); else { strcat(data, \"file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"file.txt\"); strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_31.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_09.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_09.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_fopen_54a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_15.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_15.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; break; default: strcat(data, \"file.txt\"); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_66a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_82a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } CWE23_Relative_Path_Traversal__char_environment_ofstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_environment_ofstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_61b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_04.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #include <windows.h> size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_04.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_52a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_15.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_15.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; break; default: strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_06.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_w32CreateFile_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_w32CreateFile_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) else { strcat(data, \"file.txt\"); } return data; } char * goodG2B2Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_open_41.cpp", "text": "{ int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_13.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_13.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_43.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_33.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * data = dataRef; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_84_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE23_Relative_Path_Traversal__char_environment_ofstream_84_goodG2B::CWE23_Relative_Path_Traversal__char_environment_ofstream_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_53a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_open_82a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE23_Relative_Path_Traversal__char_file_open_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_file_open_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_08.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_08.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_09.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_09.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_w32CreateFile_07.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #include <windows.h> size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_31.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_61b.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_31.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_21.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_74a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) else { strcat(data, \"file.txt\"); } return data; } char * goodG2B2Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_17.cpp", "text": "int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_42.cpp", "text": "* GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_16.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_45.cpp", "text": "{ static wchar_t * badData; static wchar_t * goodG2BData; static void badSink() { wchar_t * data = badData; { HANDLE hFile; hFile = CreateFileW(data, void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_32.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } *dataPtr1 = data; } { char * data = *dataPtr2; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_open_41.cpp", "text": "* GoodSource: Use a fixed file name * Sink: open * BadSink : Open the file named in data using open() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(wchar_t * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_fopen_41.cpp", "text": "* GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(wchar_t * data) { FILE *pFile = NULL; pFile = FOPEN(data, L\"wb+\"); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_open_16.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_open_02.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_open_02.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_07.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_07.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_18.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_ifstream_21.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_82a.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE23_Relative_Path_Traversal__char_console_ifstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_console_ifstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_74a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_01.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_w32CreateFile_22b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_fopen_22b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_81a.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE23_Relative_Path_Traversal__char_console_ifstream_81_base& baseObject = CWE23_Relative_Path_Traversal__char_console_ifstream_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_83_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE23_Relative_Path_Traversal__char_environment_fopen_83_goodG2B::CWE23_Relative_Path_Traversal__char_environment_fopen_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_open_84_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE23_Relative_Path_Traversal__char_console_open_84_goodG2B::CWE23_Relative_Path_Traversal__char_console_open_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_84_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE23_Relative_Path_Traversal__char_console_ifstream_84_goodG2B::CWE23_Relative_Path_Traversal__char_console_ifstream_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_82a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } CWE23_Relative_Path_Traversal__char_environment_fopen_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_environment_fopen_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_fopen_81a.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE23_Relative_Path_Traversal__char_console_fopen_81_base& baseObject = CWE23_Relative_Path_Traversal__char_console_fopen_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_fopen_84_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE23_Relative_Path_Traversal__char_console_fopen_84_goodG2B::CWE23_Relative_Path_Traversal__char_console_fopen_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_16.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_84_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE23_Relative_Path_Traversal__char_console_ofstream_84_goodG2B::CWE23_Relative_Path_Traversal__char_console_ofstream_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_64a.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_15.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; break; default: strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_51a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_05.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_05.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_10.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_10.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_w32CreateFile_17.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_31.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_11.c", "text": "data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_11.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_ncpy_11_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_11.c", "text": "dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_07.c", "text": "data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_07.c", "text": "#include <wchar.h> data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_07.c", "text": "strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B2() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_61a.c", "text": "char * CWE127_Buffer_Underread__malloc_char_memcpy_61b_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_memcpy_61_bad() { char * data; data = NULL; data = CWE127_Buffer_Underread__malloc_char_memcpy_61b_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_61a.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE127_Buffer_Underread__malloc_char_memcpy_61b_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_memcpy_61_bad() { char * data; data = NULL; data = CWE127_Buffer_Underread__malloc_char_memcpy_61b_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); char * CWE127_Buffer_Underread__malloc_char_memcpy_61b_goodG2BSource(char * data); static void goodG2B() { char * data; data = NULL; data = CWE127_Buffer_Underread__malloc_char_memcpy_61b_goodG2BSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_52c.c", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void CWE127_Buffer_Underread__malloc_wchar_t_memcpy_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_18.c", "text": "data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_18.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memmove_18_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_42.c", "text": "data = dataBuffer - 8; } return data; } void CWE127_Buffer_Underread__malloc_char_memmove_42_bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_42.c", "text": "data = dataBuffer - 8; } return data; } void CWE127_Buffer_Underread__malloc_char_memmove_42_bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer; } return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_52c.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_ncpy_52c_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_73b.cpp", "text": "*/ wchar_t * data = dataList.back(); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void goodG2BSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_51b.c", "text": "dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_memmove_51b_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_65b.c", "text": "dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_memcpy_65b_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_51b.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_ncpy_51b_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_05.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memmove_05_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_68b.c", "text": "dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); void CWE127_Buffer_Underread__malloc_char_cpy_68b_goodG2BSink() { char * data = CWE127_Buffer_Underread__malloc_char_cpy_68_goodG2BData; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_83_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__malloc_char_ncpy_83_goodG2B::~CWE127_Buffer_Underread__malloc_char_ncpy_83_goodG2B() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_41.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_cpy_41_badSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); data = dataBuffer - 8; } CWE127_Buffer_Underread__malloc_char_cpy_41_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__malloc_char_cpy_41_goodG2BSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_84_bad.cpp", "text": "data = dataBuffer - 8; } } CWE127_Buffer_Underread__malloc_char_ncpy_84_bad::~CWE127_Buffer_Underread__malloc_char_ncpy_84_bad() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_01.c", "text": "data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_01.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy #ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_cpy_01_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_07.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_ncpy_07_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void (*funcPtr) (char *) = badSink; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_32.c", "text": "data = dataBuffer - 8; } *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_32.c", "text": "data = dataBuffer - 8; } *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = NULL; { wchar_t * data = *dataPtr1; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_03.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_ncpy_03_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_73b.cpp", "text": "char * data = dataList.back(); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_73b.cpp", "text": "char * data = dataList.back(); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_12.c", "text": "data = dataBuffer - 8; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_12.c", "text": "} { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_11.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memcpy_11_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_42.c", "text": "data = dataBuffer - 8; } return data; } void CWE127_Buffer_Underread__malloc_char_cpy_42_bad() { char * data; data = NULL; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_42.c", "text": "data = dataBuffer - 8; } return data; } void CWE127_Buffer_Underread__malloc_char_cpy_42_bad() { char * data; data = NULL; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); data = dataBuffer; } return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_32.c", "text": "data = dataBuffer - 8; } *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_32.c", "text": "data = dataBuffer - 8; } *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_22a.c", "text": "int CWE127_Buffer_Underread__malloc_char_memmove_22_badGlobal = 0; char * CWE127_Buffer_Underread__malloc_char_memmove_22_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_memmove_22_bad() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memmove_22_badGlobal = 1; data = CWE127_Buffer_Underread__malloc_char_memmove_22_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_22a.c", "text": "int CWE127_Buffer_Underread__malloc_char_memmove_22_badGlobal = 0; char * CWE127_Buffer_Underread__malloc_char_memmove_22_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_memmove_22_bad() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memmove_22_badGlobal = 1; data = CWE127_Buffer_Underread__malloc_char_memmove_22_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); int CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Global = 0; int CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B2Global = 0; char * CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Global = 0; data = CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_22a.c", "text": "#ifndef OMITGOOD int CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Global = 0; int CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B2Global = 0; char * CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Global = 0; data = CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B1Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); char * CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B2Global = 1; data = CWE127_Buffer_Underread__malloc_char_memmove_22_goodG2B2Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_72b.cpp", "text": "char * data = dataVector[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_72b.cpp", "text": "char * data = dataVector[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_83_bad.cpp", "text": "data = dataBuffer - 8; } } CWE127_Buffer_Underread__malloc_char_memcpy_83_bad::~CWE127_Buffer_Underread__malloc_char_memcpy_83_bad() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_22a.c", "text": "int CWE127_Buffer_Underread__malloc_char_ncpy_22_badGlobal = 0; char * CWE127_Buffer_Underread__malloc_char_ncpy_22_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_ncpy_22_bad() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_ncpy_22_badGlobal = 1; data = CWE127_Buffer_Underread__malloc_char_ncpy_22_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_22a.c", "text": "int CWE127_Buffer_Underread__malloc_char_ncpy_22_badGlobal = 0; char * CWE127_Buffer_Underread__malloc_char_ncpy_22_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_ncpy_22_bad() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_ncpy_22_badGlobal = 1; data = CWE127_Buffer_Underread__malloc_char_ncpy_22_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); int CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Global = 0; int CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B2Global = 0; char * CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Global = 0; data = CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_22a.c", "text": "#ifndef OMITGOOD int CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Global = 0; int CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B2Global = 0; char * CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Global = 0; data = CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B1Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); char * CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B2Global = 1; data = CWE127_Buffer_Underread__malloc_char_ncpy_22_goodG2B2Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_01.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memcpy_01_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_68b.cpp", "text": "dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); void goodG2BSink() { char * data = CWE127_Buffer_Underread__new_char_cpy_68_goodG2BData; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_53d.cpp", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void goodG2BSink_d(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_42.cpp", "text": "data = dataBuffer - 8; } return data; void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_42.cpp", "text": "data = dataBuffer - 8; } return data; void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); data = dataBuffer; } return data; static void goodG2B() { wchar_t * data; data = NULL; data = goodG2BSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_83_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__new_char_memmove_83_goodG2B::~CWE127_Buffer_Underread__new_char_memmove_83_goodG2B() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_13.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_13.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_07.cpp", "text": "static int staticFive = 5; namespace CWE127_Buffer_Underread__new_wchar_t_memmove_07 void bad() { wchar_t * data; data = NULL; if(staticFive==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_07.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(staticFive==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_07.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(staticFive==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_41.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #include <wchar.h> namespace CWE127_Buffer_Underread__new_char_cpy_41 #ifndef OMITBAD void badSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); data = dataBuffer - 8; } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_84_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__new_char_ncpy_84_goodG2B::~CWE127_Buffer_Underread__new_char_ncpy_84_goodG2B() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_45.cpp", "text": "namespace CWE127_Buffer_Underread__new_wchar_t_memcpy_45 { static wchar_t * badData; static wchar_t * goodG2BData; static void badSink() { wchar_t * data = badData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); data = dataBuffer - 8; } badData = data; static void goodG2BSink() { wchar_t * data = goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_53d.cpp", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink_d(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_11.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_11.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_42.cpp", "text": "data = dataBuffer - 8; } return data; void bad() { char * data; data = NULL; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_42.cpp", "text": "memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } return data; void bad() { char * data; data = NULL; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); data = dataBuffer; } return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_07.cpp", "text": "static int staticFive = 5; namespace CWE127_Buffer_Underread__new_char_ncpy_07 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_07.cpp", "text": "this will always give its initialized value. */ static int staticFive = 5; namespace CWE127_Buffer_Underread__new_char_ncpy_07 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_06.cpp", "text": "static const int STATIC_CONST_FIVE = 5; namespace CWE127_Buffer_Underread__new_char_ncpy_06 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_06.cpp", "text": "value. */ static const int STATIC_CONST_FIVE = 5; namespace CWE127_Buffer_Underread__new_char_ncpy_06 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_84_bad.cpp", "text": "data = dataBuffer - 8; } } CWE127_Buffer_Underread__new_wchar_t_memmove_84_bad::~CWE127_Buffer_Underread__new_wchar_t_memmove_84_bad() { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_63b.cpp", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_11.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_ncpy_11 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_21.cpp", "text": "static int badStatic = 0; static wchar_t * badSource(wchar_t * data) if(badStatic) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } return data; void bad() { wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_21.cpp", "text": "wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static wchar_t * goodG2B1Source(wchar_t * data) else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } return data; static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_21.cpp", "text": "wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static wchar_t * goodG2B2Source(wchar_t * data) if(goodG2B2Static) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } return data; static void goodG2B2() { wchar_t * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_18.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_memcpy_18 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_61a.cpp", "text": "wchar_t * badSource(wchar_t * data); void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_61a.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 61 Data flow: data returned from one function to another in different source files #include <wchar.h> namespace CWE127_Buffer_Underread__new_wchar_t_memmove_61 #ifndef OMITBAD wchar_t * badSource(wchar_t * data); void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); wchar_t * goodG2BSource(wchar_t * data); static void goodG2B() { wchar_t * data; data = NULL; data = goodG2BSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_33.cpp", "text": "{ char * data; char * &dataRef = data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; char * &dataRef = data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE127_Buffer_Underread__new_char_cpy_05 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE127_Buffer_Underread__new_char_cpy_05 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_17.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_memmove_17 void bad() { int i; char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_16.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_cpy_16 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; break; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_06.cpp", "text": "static const int STATIC_CONST_FIVE = 5; namespace CWE127_Buffer_Underread__new_char_memcpy_06 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_06.cpp", "text": "value. */ static const int STATIC_CONST_FIVE = 5; namespace CWE127_Buffer_Underread__new_char_memcpy_06 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_61a.cpp", "text": "char * badSource(char * data); void bad() { char * data; data = NULL; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_61a.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 61 Data flow: data returned from one function to another in different source files #include <wchar.h> namespace CWE127_Buffer_Underread__new_char_cpy_61 #ifndef OMITBAD char * badSource(char * data); void bad() { char * data; data = NULL; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); char * goodG2BSource(char * data); static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_21.cpp", "text": "static int badStatic = 0; static wchar_t * badSource(wchar_t * data) if(badStatic) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } return data; void bad() { wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_21.cpp", "text": "wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static wchar_t * goodG2B1Source(wchar_t * data) else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } return data; static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_21.cpp", "text": "wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static wchar_t * goodG2B2Source(wchar_t * data) if(goodG2B2Static) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } return data; static void goodG2B2() { wchar_t * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_66b.cpp", "text": "*/ wchar_t * data = dataArray[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_67b.cpp", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink(structType myStruct) { char * data = myStruct.structFirst; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_84_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__new_char_memmove_84_goodG2B::~CWE127_Buffer_Underread__new_char_memmove_84_goodG2B() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_41.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_ncpy_41 #ifndef OMITBAD void badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer - 8; } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memcpy_08.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_declare_memcpy_08_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(staticReturnsTrue()) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memcpy_08.c", "text": "memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(staticReturnsTrue()) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_03.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_declare_memmove_03_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(5==5) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_03.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(5==5) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_68b.c", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_68b_goodG2BSink() { wchar_t * data = CWE127_Buffer_Underread__wchar_t_alloca_memcpy_68_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_52c.c", "text": "dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_alloca_memmove_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_31.c", "text": "data = dataBuffer - 8; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_declare_memmove_31_bad() { wchar_t * data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_08.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_08_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(staticReturnsTrue()) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_08.c", "text": "memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(staticReturnsTrue()) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memcpy_05.c", "text": "data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memcpy_05.c", "text": "memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(staticTrue) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_07.c", "text": "#include <wchar.h> data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_07.c", "text": "memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(staticFive==5) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_11.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_declare_memmove_11_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(globalReturnsTrue()) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_11.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(globalReturnsTrue()) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_65b.c", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_65b_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_01.c", "text": "data = dataBuffer - 8; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_01.c", "text": "data = dataBuffer - 8; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_45.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include <wchar.h> static wchar_t * CWE127_Buffer_Underread__wchar_t_declare_memmove_45_badData; static wchar_t * CWE127_Buffer_Underread__wchar_t_declare_memmove_45_goodG2BData; static void badSink() { wchar_t * data = CWE127_Buffer_Underread__wchar_t_declare_memmove_45_badData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); } } void CWE127_Buffer_Underread__wchar_t_declare_memmove_45_bad() { wchar_t * data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; CWE127_Buffer_Underread__wchar_t_declare_memmove_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE127_Buffer_Underread__wchar_t_declare_memmove_45_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_52c.c", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_68b.c", "text": "dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_alloca_memmove_68b_goodG2BSink() { wchar_t * data = CWE127_Buffer_Underread__wchar_t_alloca_memmove_68_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_18.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_declare_memmove_18_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; goto source; source: data = dataBuffer - 8; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; goto source; source: data = dataBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_02.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_alloca_memmove_02_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(1) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_02.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(1) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_02.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_declare_memmove_02_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(1) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_02.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(1) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_14.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_14_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalFive==5) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_14.c", "text": "memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalFive==5) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memmove_05.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memmove_05.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(staticTrue) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_51a.c", "text": "void CWE127_Buffer_Underread__CWE839_listen_socket_51b_badSink(int data); void CWE127_Buffer_Underread__CWE839_listen_socket_51_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_51a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE127_Buffer_Underread__CWE839_listen_socket_51b_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_listen_socket_51b_goodG2BSink(int data); data = 7; CWE127_Buffer_Underread__CWE839_listen_socket_51b_goodG2BSink(data); } void CWE127_Buffer_Underread__CWE839_listen_socket_51b_goodB2GSink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_52a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_52b_badSink(int data); void CWE127_Buffer_Underread__CWE839_fscanf_52_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_52a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_52b_badSink(int data); void CWE127_Buffer_Underread__CWE839_fscanf_52_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_52a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_52b_badSink(int data); void CWE127_Buffer_Underread__CWE839_fscanf_52_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_52b_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_fscanf_52b_goodG2BSink(int data); data = 7; CWE127_Buffer_Underread__CWE839_fscanf_52b_goodG2BSink(data); } void CWE127_Buffer_Underread__CWE839_fscanf_52b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_52a.c", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking to see if the value is negative * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_52b_badSink(int data); void CWE127_Buffer_Underread__CWE839_fscanf_52_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_52b_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_fscanf_52b_goodG2BSink(int data); static void goodG2B() { int data; data = -1; data = 7; CWE127_Buffer_Underread__CWE839_fscanf_52b_goodG2BSink(data); } void CWE127_Buffer_Underread__CWE839_fscanf_52b_goodB2GSink(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_45.c", "text": "if (data < 10) { printIntLine(buffer[data]); } } void CWE127_Buffer_Underread__CWE839_fscanf_45_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_45.c", "text": "*/ data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_45_badData = data; static void goodG2BSink() { int data = CWE127_Buffer_Underread__CWE839_fscanf_45_goodG2BData; data = 7; CWE127_Buffer_Underread__CWE839_fscanf_45_goodG2BData = data; static void goodB2GSink() { int data = CWE127_Buffer_Underread__CWE839_fscanf_45_goodB2GData; { int buffer[10] = { 0 };", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_45.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_45_badData = data; static void goodG2BSink() { int data = CWE127_Buffer_Underread__CWE839_fscanf_45_goodG2BData; int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); static void goodG2B() { int data; data = -1; data = 7; CWE127_Buffer_Underread__CWE839_fscanf_45_goodG2BData = data; static void goodB2GSink() { int data = CWE127_Buffer_Underread__CWE839_fscanf_45_goodB2GData; { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_03.c", "text": "data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(5==5) { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_13.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy data to string using strncpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_ncpy_13_bad() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_13.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_53d.c", "text": "dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_cpy_53d_goodG2BSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_05.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_connect_socket_05_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_11.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_memcpy_11_bad() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_11.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_54a.c", "text": "void CWE127_Buffer_Underread__CWE839_listen_socket_54b_badSink(int data); void CWE127_Buffer_Underread__CWE839_listen_socket_54_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_54a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE127_Buffer_Underread__CWE839_listen_socket_54b_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_listen_socket_54b_goodG2BSink(int data); data = 7; CWE127_Buffer_Underread__CWE839_listen_socket_54b_goodG2BSink(data); } void CWE127_Buffer_Underread__CWE839_listen_socket_54b_goodB2GSink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_cpy_64b_goodG2BSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_42.c", "text": "/* * @description * CWE: 127 Buffer Underread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_42.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); return data; } void CWE127_Buffer_Underread__CWE839_listen_socket_42_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_53d.c", "text": "dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_cpy_53d_goodG2BSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_14.c", "text": "data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(globalFive==5) { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_44.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); } } void CWE127_Buffer_Underread__char_alloca_memcpy_44_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_02.c", "text": "/* * @description * CWE: 127 Buffer Underread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_listen_socket_02_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_63b.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_ncpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memmove_18.c", "text": "data = dataBuffer - 8; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; dataBuffer[100-1] = '\\0'; goto source; source: data = dataBuffer; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_33.cpp", "text": "data = dataBuffer - 8; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_33.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__char_alloca_ncpy_33 void bad() { char * data; char * &dataRef = data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; char * &dataRef = data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_44.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); } } void CWE127_Buffer_Underread__char_declare_cpy_44_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memmove_16.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_memmove_16_bad() { char * data; dataBuffer[100-1] = '\\0'; while(1) { data = dataBuffer - 8; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; dataBuffer[100-1] = '\\0'; while(1) { data = dataBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memmove_09.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_memmove_09_bad() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_TRUE) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memmove_09.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_TRUE) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_66b.c", "text": "char * data = dataArray[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_ncpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_73a.cpp", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking to see if the value is negative * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE127_Buffer_Underread__CWE839_fscanf_73 void bad() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { int data; list<int> dataList; data = -1; data = 7; dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_63b.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_ncpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_06.c", "text": "data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); static void goodB2G1() { int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_06.c", "text": "fscanf(stdin, \"%d\", &data); data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); { { int buffer[10] = { 0 };", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_06.c", "text": "{ int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); static void goodB2G1() { int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); { { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); static void goodB2G2() { int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_41.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy data to string using strncpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_ncpy_41_badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); } } void CWE127_Buffer_Underread__char_alloca_ncpy_41_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE127_Buffer_Underread__char_alloca_ncpy_41_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_ncpy_41_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_18.c", "text": "data = dataBuffer - 8; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_18.c", "text": "data = dataBuffer - 8; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; dataBuffer[100-1] = '\\0'; goto source; source: data = dataBuffer; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_03.c", "text": "/* * @description * CWE: 127 Buffer Underread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_listen_socket_03_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_45.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: ncpy * BadSink : Copy data to string using strncpy * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include <wchar.h> static char * CWE127_Buffer_Underread__char_alloca_ncpy_45_badData; static char * CWE127_Buffer_Underread__char_alloca_ncpy_45_goodG2BData; static void badSink() { char * data = CWE127_Buffer_Underread__char_alloca_ncpy_45_badData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); } } void CWE127_Buffer_Underread__char_alloca_ncpy_45_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE127_Buffer_Underread__char_alloca_ncpy_45_badData = data; static void goodG2BSink() { char * data = CWE127_Buffer_Underread__char_alloca_ncpy_45_goodG2BData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_68a.c", "text": "void CWE127_Buffer_Underread__CWE839_listen_socket_68b_badSink(); void CWE127_Buffer_Underread__CWE839_listen_socket_68_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_68a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE127_Buffer_Underread__CWE839_listen_socket_68_badData = data; CWE127_Buffer_Underread__CWE839_listen_socket_68b_badSink(); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_listen_socket_68b_goodG2BSink(); void CWE127_Buffer_Underread__CWE839_listen_socket_68b_goodB2GSink(); data = 7; CWE127_Buffer_Underread__CWE839_listen_socket_68_goodG2BData = data; CWE127_Buffer_Underread__CWE839_listen_socket_68b_goodG2BSink(); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memmove_08.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_memmove_08_bad() { char * data; dataBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_08.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy data to string using strncpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_ncpy_08_bad() { char * data; dataBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_08.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_14.c", "text": "data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); static void goodB2G1() { int data; data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_14.c", "text": "fscanf(stdin, \"%d\", &data); data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data); { { int buffer[10] = { 0 };", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_14.c", "text": "{ int data; data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); static void goodB2G1() { int data; data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data); { { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); static void goodB2G2() { int data; data = -1; if(globalFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_66b.c", "text": "char * data = dataArray[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_memcpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_64a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE127_Buffer_Underread__CWE839_fscanf_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_64a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE127_Buffer_Underread__CWE839_fscanf_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_64a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE127_Buffer_Underread__CWE839_fscanf_64_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_64b_badSink(&data); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_fscanf_64b_goodG2BSink(void * dataVoidPtr); data = 7; CWE127_Buffer_Underread__CWE839_fscanf_64b_goodG2BSink(&data); } void CWE127_Buffer_Underread__CWE839_fscanf_64b_goodB2GSink(void * dataVoidPtr);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_64a.c", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking to see if the value is negative * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE127_Buffer_Underread__CWE839_fscanf_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_64b_badSink(&data); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_fscanf_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int data; data = -1; data = 7; CWE127_Buffer_Underread__CWE839_fscanf_64b_goodG2BSink(&data); } void CWE127_Buffer_Underread__CWE839_fscanf_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_44.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); } } void CWE127_Buffer_Underread__char_declare_memcpy_44_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_54e.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_ncpy_54e_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_17.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_cpy_17_bad() { int i; char * data; dataBuffer[100-1] = '\\0'; for(i = 0; i < 1; i++) { data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B() { int h; char * data; dataBuffer[100-1] = '\\0'; for(h = 0; h < 1; h++) { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memmove_53d.c", "text": "dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_memmove_53d_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_64b.c", "text": "*/ char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_memcpy_64b_goodG2BSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_62b.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_53a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sink: * BadSink : Load a dynamic link library * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE114_Process_Control__w32_char_relativePath_53b_badSink(char * data); void CWE114_Process_Control__w32_char_relativePath_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_53a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sink: * BadSink : Load a dynamic link library * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE114_Process_Control__w32_char_relativePath_53b_badSink(char * data); void CWE114_Process_Control__w32_char_relativePath_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\"); CWE114_Process_Control__w32_char_relativePath_53b_badSink(data); #ifndef OMITGOOD void CWE114_Process_Control__w32_char_relativePath_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_wchar_t_listen_socket_72a.cpp", "text": "void badSink(vector<wchar_t *> dataVector); void bad() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_09.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE114_Process_Control__w32_char_environment_09_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_09.c", "text": "void CWE114_Process_Control__w32_char_environment_09_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_connect_socket_51a.c", "text": "void CWE114_Process_Control__w32_char_connect_socket_51b_badSink(char * data); void CWE114_Process_Control__w32_char_connect_socket_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_connect_socket_51a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE114_Process_Control__w32_char_connect_socket_51b_badSink(data); #ifndef OMITGOOD void CWE114_Process_Control__w32_char_connect_socket_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_10.c", "text": "void CWE114_Process_Control__w32_char_console_10_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_22b.c", "text": "extern int CWE114_Process_Control__w32_char_environment_22_badGlobal; char * CWE114_Process_Control__w32_char_environment_22_badSource(char * data) if(CWE114_Process_Control__w32_char_environment_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_22b.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE114_Process_Control__w32_char_environment_22_badGlobal; char * CWE114_Process_Control__w32_char_environment_22_badSource(char * data) if(CWE114_Process_Control__w32_char_environment_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE114_Process_Control__w32_char_environment_22_goodG2B2Global; char * CWE114_Process_Control__w32_char_environment_22_goodG2B1Source(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_22b.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE114_Process_Control__w32_char_environment_22_badGlobal; char * CWE114_Process_Control__w32_char_environment_22_badSource(char * data) if(CWE114_Process_Control__w32_char_environment_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE114_Process_Control__w32_char_environment_22_goodG2B2Global; char * CWE114_Process_Control__w32_char_environment_22_goodG2B1Source(char * data) else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); } return data; } char * CWE114_Process_Control__w32_char_environment_22_goodG2B2Source(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_18.c", "text": "void CWE114_Process_Control__w32_char_file_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_82a.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_82a.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\"); CWE114_Process_Control__w32_char_relativePath_82_base* baseObject = new CWE114_Process_Control__w32_char_relativePath_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_03.c", "text": "void CWE114_Process_Control__w32_char_file_03_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_wchar_t_connect_socket_65a.c", "text": "void CWE114_Process_Control__w32_wchar_t_connect_socket_65b_badSink(wchar_t * data); void CWE114_Process_Control__w32_wchar_t_connect_socket_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE114_Process_Control__w32_wchar_t_connect_socket_65b_badSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_61b.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE114_Process_Control__w32_char_relativePath_61b_badSource(char * data) strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_61b.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE114_Process_Control__w32_char_relativePath_61b_badSource(char * data) { strcpy(data, \"winsrv.dll\"); return data; #ifndef OMITGOOD char * CWE114_Process_Control__w32_char_relativePath_61b_goodG2BSource(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_81a.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } const CWE114_Process_Control__w32_char_environment_81_base& baseObject = CWE114_Process_Control__w32_char_environment_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_82a.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE114_Process_Control__w32_char_file_82_base* baseObject = new CWE114_Process_Control__w32_char_file_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_12.c", "text": "break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_12.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_12.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_66a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE114_Process_Control__w32_char_file_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_74a.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_74a.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\"); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_61b.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE114_Process_Control__w32_char_listen_socket_61b_badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * CWE114_Process_Control__w32_char_listen_socket_61b_goodG2BSource(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_18.c", "text": "void CWE114_Process_Control__w32_char_console_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_12.c", "text": "void CWE114_Process_Control__w32_char_console_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_12.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_12.c", "text": "{ { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_wchar_t_connect_socket_74a.cpp", "text": "void badSink(map<int, wchar_t *> dataMap); void bad() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_64a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE114_Process_Control__w32_char_relativePath_64_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_64a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE114_Process_Control__w32_char_relativePath_64_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\"); CWE114_Process_Control__w32_char_relativePath_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_54a.c", "text": "void CWE114_Process_Control__w32_char_environment_54b_badSink(char * data); void CWE114_Process_Control__w32_char_environment_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_54a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sink: * BadSink : Load a dynamic link library * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE114_Process_Control__w32_char_environment_54b_badSink(char * data); void CWE114_Process_Control__w32_char_environment_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE114_Process_Control__w32_char_environment_54b_badSink(data); #ifndef OMITGOOD void CWE114_Process_Control__w32_char_environment_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_10.c", "text": "void CWE114_Process_Control__w32_char_file_10_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_45.c", "text": "hModule = LoadLibraryA(data); void CWE114_Process_Control__w32_char_listen_socket_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_45.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE114_Process_Control__w32_char_listen_socket_45_badData = data; static void goodG2BSink() { char * data = CWE114_Process_Control__w32_char_listen_socket_45_goodG2BData; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_02.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(1) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_02.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(1) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_16.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_16.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_16_bad() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; while(1) { data = dataBadBuffer; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; while(1) { data = dataGoodBuffer; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_18.c", "text": "twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; goto source; source: data = dataBadBuffer; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; goto source; source: data = dataGoodBuffer; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void goodG2BSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_17.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_17_bad() { int i; wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; for(i = 0; i < 1; i++) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { int h; wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; for(h = 0; h < 1; h++) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_64b.c", "text": "twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr; twoIntsStruct * data = (*dataPtr); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_64b.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_64b_badSink(void * dataVoidPtr) { twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr; twoIntsStruct * data = (*dataPtr); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_64b_goodG2BSink(void * dataVoidPtr) { twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr; twoIntsStruct * data = (*dataPtr); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_33.cpp", "text": "data = dataBadBuffer; data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_33.cpp", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBadBuffer; data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataGoodBuffer; data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_06_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_06.c", "text": "#include <wchar.h> void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_06_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_06.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(STATIC_CONST_FIVE==5) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_34.c", "text": "data = dataBadBuffer; myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { twoIntsStruct * data; CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_34_unionType myUnion; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; data = dataGoodBuffer; myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_11.c", "text": "{ twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; if(globalReturnsTrue()) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_11.c", "text": "{ twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; if(globalReturnsTrue()) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_04.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(STATIC_CONST_TRUE) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_04.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(STATIC_CONST_TRUE) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_66b.c", "text": "twoIntsStruct * data = dataArray[2]; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_66b.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_66b_badSink(twoIntsStruct * dataArray[]) { twoIntsStruct * data = dataArray[2]; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_66b_goodG2BSink(twoIntsStruct * dataArray[]) { twoIntsStruct * data = dataArray[2]; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_32.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_32.c", "text": "{ wchar_t * data = *dataPtr1; data = dataBadBuffer; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); { wchar_t * data = *dataPtr1; data = dataGoodBuffer; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_05.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_05.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(staticTrue) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_65b.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_65b_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_14.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(globalFive==5) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_14.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(globalFive==5) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_45.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include <wchar.h> static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_45_badData; static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_45_goodG2BData; static void badSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_45_badData; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_45_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBadBuffer; data[0] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_45_goodG2BData; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54e.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54e_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_16.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_16_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); while(1) { data = dataBadBuffer; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); while(1) { data = dataGoodBuffer; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_17.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_17_bad() { int i; wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; for(i = 0; i < 1; i++) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { int h; wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; for(h = 0; h < 1; h++) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_17.c", "text": "int i; twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; for(i = 0; i < 1; i++) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { int h; twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; for(h = 0; h < 1; h++) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_63b.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memmove * BadSink : Copy twoIntsStruct array to data using memmove * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_63b_badSink(twoIntsStruct * * dataPtr) { twoIntsStruct * data = *dataPtr; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_63b_goodG2BSink(twoIntsStruct * * dataPtr) { twoIntsStruct * data = *dataPtr; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_05.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_05.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; if(staticTrue) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_04.c", "text": "/* * @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_04.c", "text": "data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_04.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() #define SRC_STRING \"AAAAAAAAAA\" data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_04.c", "text": "data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); static void goodG2B2() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_01.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_01.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54e.c", "text": "memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54e.c", "text": "memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54e_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_04.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() #define SRC_STRING \"AAAAAAAAAA\" data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_31.c", "text": "/* * @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_31.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_31.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char dataGoodBuffer[10+1]; data = dataGoodBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_15.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; break; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_15.c", "text": "* BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_15_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); case 6: data = dataBadBuffer; data[0] = L'\\0'; break; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); default: data = dataGoodBuffer; data[0] = L'\\0'; break; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_15.c", "text": "memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); default: data = dataGoodBuffer; data[0] = L'\\0'; break; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); case 6: data = dataGoodBuffer; data[0] = L'\\0'; break; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_65b.c", "text": "memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_65b_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_18.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_18_bad() { char * data; char dataBadBuffer[10]; char dataGoodBuffer[10+1]; goto source; source: data = dataBadBuffer; data[0] = '\\0'; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { char * data; char dataBadBuffer[10]; char dataGoodBuffer[10+1]; goto source; source: data = dataGoodBuffer; data[0] = '\\0'; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_51b.c", "text": "strcpy(data, source); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_51b_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_16.c", "text": "data = dataBadBuffer; data[0] = '\\0'; break; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; break; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_44.c", "text": "strncpy(data, source, strlen(source) + 1); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_44_bad() { char * data; char dataGoodBuffer[10+1]; data = dataBadBuffer; data[0] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_12.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_12.c", "text": "* BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_12_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_12.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_12.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_12_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68b.c", "text": "memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68_goodG2BData; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_33.cpp", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataGoodBuffer[10+1]; data = dataBadBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char dataGoodBuffer[10+1]; data = dataGoodBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68b.c", "text": "memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68_goodG2BData; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_45.c", "text": "strncpy(data, source, strlen(source) + 1); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_45_bad() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_45_badData = data; static void goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_45_goodG2BData; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_01.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68b.c", "text": "strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_68_goodG2BData; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_03.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B2() { char * data; if(5==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_34.c", "text": "data = dataBadBuffer; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_34.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_34_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataBadBuffer; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataGoodBuffer; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_44.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_44_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataBadBuffer; data[0] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_17.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_17_bad() { int i; char * data; for(i = 0; i < 1; i++) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { int h; char * data; for(h = 0; h < 1; h++) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_65b.c", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_05.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_05.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(staticTrue) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_44.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: ncat * BadSink : Copy string to data using strncat * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_44_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_15.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_15_bad() { char * data; { case 6: data = dataBadBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; break; default: data = dataGoodBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_15.c", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; break; default: data = dataGoodBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; { case 6: data = dataGoodBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_31.c", "text": "* GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_31_bad() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; data = dataBadBuffer; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; data = dataGoodBuffer; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_05.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: ncpy * BadSink : Copy string to data using strncpy data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_05.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(staticTrue) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_03.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_03_bad() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_13.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_13_bad() { char * data; if(GLOBAL_CONST_FIVE==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45.c", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45_badData = data; static void goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_44.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_44_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_17.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_17_bad() { int i; char * data; for(i = 0; i < 1; i++) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { int h; char * data; for(h = 0; h < 1; h++) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_34.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_34_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataBadBuffer; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataGoodBuffer; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_08.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_08_bad() { char * data; if(staticReturnsTrue()) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_08.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(staticReturnsTrue()) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_52c.c", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_52c_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_33.cpp", "text": "* GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; data = dataBadBuffer; data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; data = dataGoodBuffer; data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_65b.c", "text": "memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_65b_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_51b.c", "text": "memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_51b_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54e.c", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54e_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_32.c", "text": "{ char * data = *dataPtr1; data = dataBadBuffer; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBadBuffer[50]; char dataGoodBuffer[100]; { char * data = *dataPtr1; data = dataGoodBuffer; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08_bad() { char * data; if(staticReturnsTrue()) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_08.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(staticReturnsTrue()) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_31.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_31.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_31_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_18.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_18.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_18_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); goto source; source: data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); goto source; source: data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_14.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_14_bad() { char * data; if(globalFive==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_18.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_18_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; goto source; source: data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; goto source; source: data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45.c", "text": "#define SRC_STRING L\"AAAAAAAAAA\" static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_badData; static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_goodG2BData; static void badSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_badData; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define SRC_STRING L\"AAAAAAAAAA\" static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_badData; static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_goodG2BData; static void badSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_badData; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_bad() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; data = dataBadBuffer; data[0] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45_goodG2BData; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_10.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_10_bad() { char * data; if(globalTrue) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_16.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_16_bad() { char * data; while(1) { data = dataBadBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; while(1) { data = dataGoodBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_41.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_41_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_41_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataBadBuffer; data[0] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_41_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_12.c", "text": "{ wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataBadBuffer; data[0] = L'\\0'; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); * both branches use the GoodSource */ static void goodG2B() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataGoodBuffer; data[0] = L'\\0'; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_10.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_10_bad() { char * data; if(globalTrue) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_05.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_05.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(staticTrue) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53d.c", "text": "memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53d_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_06_bad() { char * data; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_06.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: ncat * BadSink : Copy string to data using strncat #include <wchar.h> void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_06_bad() { char * data; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_06.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B2() { char * data; if(STATIC_CONST_FIVE==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_16.c", "text": "* BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_16_bad() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataBadBuffer; data[0] = L'\\0'; break; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataGoodBuffer; data[0] = L'\\0'; break; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_82_bad.cpp", "text": "memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_12.c", "text": "data = dataBadBuffer; else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_12.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy int64_t array to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_12_bad() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; if(globalReturnsTrueOrFalse()) { data = dataBadBuffer; else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); * both branches use the GoodSource */ static void goodG2B() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; if(globalReturnsTrueOrFalse()) { data = dataGoodBuffer; else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_16.c", "text": "data = dataBadBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_16.c", "text": "data = dataBadBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; while(1) { data = dataGoodBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_14.c", "text": "data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_14.c", "text": "data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_14.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); if(globalFive==5) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_12.c", "text": "data = dataBadBuffer; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_12.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy int array to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_12_bad() { int * data; if(globalReturnsTrueOrFalse()) { data = dataBadBuffer; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); * both branches use the GoodSource */ static void goodG2B() { int * data; if(globalReturnsTrueOrFalse()) { data = dataGoodBuffer; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_10.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(globalTrue) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_10.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(globalTrue) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_18.c", "text": "data = dataBadBuffer; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; int dataBadBuffer[50]; int dataGoodBuffer[100]; goto source; source: data = dataGoodBuffer; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53d.c", "text": "memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53d_goodG2BSink(int64_t * data) { { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_04.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy int64_t array to data using memcpy #include \"std_testcase.h\" data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_04.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); if(STATIC_CONST_TRUE) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_17.c", "text": "data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int h; int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); for(h = 0; h < 1; h++) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_41.c", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_41_bad() { int * data; int dataBadBuffer[50]; int dataGoodBuffer[100]; data = dataBadBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_41_goodG2BSink(int * data) { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34.c", "text": "data = dataBadBuffer; myUnion.unionFirst = data; { int64_t * data = myUnion.unionSecond; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy int64_t array to data using memcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) typedef union { int64_t * unionFirst; int64_t * unionSecond; void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34_bad() { int64_t * data; CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34_unionType myUnion; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; data = dataBadBuffer; myUnion.unionFirst = data; { int64_t * data = myUnion.unionSecond; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34_unionType myUnion; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; data = dataGoodBuffer; myUnion.unionFirst = data; { int64_t * data = myUnion.unionSecond; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_05.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_05_bad() { int * data; if(staticTrue) { data = dataBadBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(staticTrue) { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_64b.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_64b_badSink(void * dataVoidPtr) { twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr; twoIntsStruct * data = (*dataPtr); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_64b_goodG2BSink(void * dataVoidPtr) { twoIntsStruct * * dataPtr = (twoIntsStruct * *)dataVoidPtr; twoIntsStruct * data = (*dataPtr); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_34.c", "text": "data = dataBadBuffer; myUnion.unionFirst = data; { int * data = myUnion.unionSecond; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_34.c", "text": "data = dataBadBuffer; myUnion.unionFirst = data; { int * data = myUnion.unionSecond; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int)); int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int)); data = dataGoodBuffer; myUnion.unionFirst = data; { int * data = myUnion.unionSecond; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74b.cpp", "text": "int64_t * data = dataMap[2]; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74b.cpp", "text": "int64_t * data = dataMap[2]; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); #ifndef OMITGOOD void goodG2BSink(map<int, int64_t *> dataMap) { int64_t * data = dataMap[2]; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_64b.c", "text": "int64_t * * dataPtr = (int64_t * *)dataVoidPtr; int64_t * data = (*dataPtr); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_64b.c", "text": "int64_t * * dataPtr = (int64_t * *)dataVoidPtr; int64_t * data = (*dataPtr); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_64b_goodG2BSink(void * dataVoidPtr) { int64_t * * dataPtr = (int64_t * *)dataVoidPtr; int64_t * data = (*dataPtr); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_32.c", "text": "{ twoIntsStruct * data = *dataPtr2; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { twoIntsStruct * data; twoIntsStruct * *dataPtr1 = &data; twoIntsStruct * *dataPtr2 = &data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); { twoIntsStruct * data = *dataPtr1; data = dataGoodBuffer; *dataPtr1 = data; } { twoIntsStruct * data = *dataPtr2; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_01.c", "text": "data = dataBadBuffer; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; data = dataGoodBuffer; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_31.c", "text": "data = dataBadBuffer; { int * dataCopy = data; int * data = dataCopy; { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; int dataBadBuffer[50]; int dataGoodBuffer[100]; data = dataGoodBuffer; { int * dataCopy = data; int * data = dataCopy; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_65b.c", "text": "memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_65b_goodG2BSink(int64_t * data) { { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_02.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(1) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_02.c", "text": "{ twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); if(1) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_18.c", "text": "data = dataBadBuffer; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); goto source; source: data = dataGoodBuffer; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63b.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63b_badSink(twoIntsStruct * * dataPtr) { twoIntsStruct * data = *dataPtr; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63b_goodG2BSink(twoIntsStruct * * dataPtr) { twoIntsStruct * data = *dataPtr; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_41.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_41_bad() { int * data; int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int)); int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int)); data = dataBadBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_41_goodG2BSink(int * data) { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_02.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); if(1) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_14.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; if(globalFive==5) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_64b.c", "text": "int64_t * * dataPtr = (int64_t * *)dataVoidPtr; int64_t * data = (*dataPtr); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_64b_goodG2BSink(void * dataVoidPtr) { int64_t * * dataPtr = (int64_t * *)dataVoidPtr; int64_t * data = (*dataPtr); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_01.c", "text": "data = dataBadBuffer; { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int)); int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int)); data = dataGoodBuffer; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_33.cpp", "text": "data = dataBadBuffer; { int * data = dataRef; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; int * &dataRef = data; int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int)); int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int)); data = dataGoodBuffer; { int * data = dataRef; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_66b.c", "text": "int64_t * data = dataArray[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_66b_goodG2BSink(int64_t * dataArray[]) { int64_t * data = dataArray[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02_bad() { int * data; if(1) { data = dataBadBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(1) { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_01.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_01_bad() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); data = dataBadBuffer; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); data = dataGoodBuffer; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_33.cpp", "text": "data = dataBadBuffer; { int64_t * data = dataRef; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; int64_t * &dataRef = data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; data = dataGoodBuffer; { int64_t * data = dataRef; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_13.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_13_bad() { int * data; if(GLOBAL_CONST_FIVE==5) { data = dataBadBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(GLOBAL_CONST_FIVE==5) { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_18.c", "text": "data = dataBadBuffer; { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; int dataBadBuffer[50]; int dataGoodBuffer[100]; goto source; source: data = dataGoodBuffer; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_12.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy int array to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_12_bad() { int * data; if(globalReturnsTrueOrFalse()) { data = dataBadBuffer; else { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); * both branches use the GoodSource */ static void goodG2B() { int * data; if(globalReturnsTrueOrFalse()) { data = dataGoodBuffer; else { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68b.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68b_goodG2BSink() { int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68_goodG2BData; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_82_goodG2B.cpp", "text": "/* * @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_82_goodG2B.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_82 { void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_82_goodG2B::action(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_14.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_14_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45.c", "text": "if (data >= 0) { buffer[data] = 1; } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_badData = data; static void goodG2BSink() { int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodG2BData; data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodG2BData = data; static void goodB2GSink() { int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodB2GData;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_badData = data; static void goodG2BSink() { int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodG2BData; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; static void goodG2B() { int data; data = -1; data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodG2BData = data; static void goodB2GSink() { int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_goodB2GData; int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_44.c", "text": "strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_44_bad() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_15.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_15_bad() { int * data; data = NULL; { case 6: data = (int *)ALLOCA(10); break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_15.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_15_bad() { int * data; data = NULL; { case 6: data = (int *)ALLOCA(10); break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; break; default: data = (int *)ALLOCA(10*sizeof(int)); break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_15.c", "text": "{ case 6: data = (int *)ALLOCA(10); break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; break; default: data = (int *)ALLOCA(10*sizeof(int)); break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; data = NULL; { case 6: data = (int *)ALLOCA(10*sizeof(int)); break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_04.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_04_bad() { int * data; data = NULL; if(STATIC_CONST_TRUE) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; else { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; data = NULL; if(STATIC_CONST_TRUE) { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_03.c", "text": "if(5==5) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodB2G2() { void * data; data = NULL; if(5==5) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodG2B1() { void * data; data = NULL; } else { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_03.c", "text": "if(5==5) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodG2B1() { void * data; data = NULL; } else { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data); printLine((char *)dest); static void goodG2B2() { void * data; data = NULL; if(5==5) { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_54e.c", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE135_54e_badSink(void * data) { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printLine((char *)dest); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE135_54e_goodG2BSink(void * data) { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_18.c", "text": "data = -1; goto source; source: fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; static void goodB2G() { int data; data = -1; goto source; source: fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_17.c", "text": "for(i = 0; i < 1; i++) { data = (void *)WIDE_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printLine((char *)dest); static void goodB2G() { int i,k; void * data; data = NULL; for(i = 0; i < 1; i++) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodG2B() { int h,j; void * data; data = NULL; for(h = 0; h < 1; h++) { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_01_bad() { int * data; data = NULL; data = (int *)ALLOCA(10); { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_01_bad() { int * data; data = NULL; data = (int *)ALLOCA(10); { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; data = NULL; data = (int *)ALLOCA(10*sizeof(int)); { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_05.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() data = (int *)ALLOCA(10); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_05.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() data = (int *)ALLOCA(10); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; else { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_05.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_05_bad() { int * data; data = NULL; if(staticTrue) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; else { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; data = NULL; if(staticTrue) { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53d.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53d_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53d.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53d_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53d_goodG2BSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(GLOBAL_CONST_TRUE) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(GLOBAL_CONST_TRUE) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_09.c", "text": "#endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(GLOBAL_CONST_TRUE) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); if(GLOBAL_CONST_TRUE) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_badSink(void * dataVoidPtr); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_badSink(void * dataVoidPtr); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_badSink(void * dataVoidPtr); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_badSink(&data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_goodG2BSink(void * dataVoidPtr); data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_goodG2BSink(&data); } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_goodB2GSink(void * dataVoidPtr);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a.c", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking the upper bound * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_badSink(void * dataVoidPtr); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_badSink(&data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int data; data = -1; data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_goodG2BSink(&data); } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_73b.cpp", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<void *> dataList) { void * data = dataList.back(); { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy((wchar_t *)dest, (wchar_t *)data); printLine((char *)dest); void goodG2BSink(list<void *> dataList) { void * data = dataList.back(); { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy((char *)dest, (char *)data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63b_badSink(int * * dataPtr) { int * data = *dataPtr; { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63b_badSink(int * * dataPtr) { int * data = *dataPtr; { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63b_goodG2BSink(int * * dataPtr) { int * data = *dataPtr; { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01_bad() { int * data; data = NULL; data = (int *)ALLOCA(10); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01_bad() { int * data; data = NULL; data = (int *)ALLOCA(10); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; data = NULL; data = (int *)ALLOCA(10*sizeof(int)); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_16.c", "text": "while(1) { data = (void *)WIDE_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printLine((char *)dest); static void goodB2G() { void * data; data = NULL; while(1) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodG2B() { void * data; data = NULL; while(1) { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34.c", "text": "data = dataBadBuffer; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_31.c", "text": "{ int data; data = -1; fscanf(stdin, \"%d\", &data); { int dataCopy = data; int data = dataCopy; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; static void goodG2B() { int data; data = -1; data = 7; { int dataCopy = data; int data = dataCopy; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_41.c", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD static void badSink(void * data) { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printLine((char *)dest); void CWE121_Stack_Based_Buffer_Overflow__CWE135_41_bad() { void * data; data = NULL; data = (void *)WIDE_STRING; badSink(data); #ifndef OMITGOOD static void goodG2BSink(void * data) { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_18.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_18_bad() { int * data; data = NULL; goto source; source: data = (int *)ALLOCA(10); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_18.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_18_bad() { int * data; data = NULL; goto source; source: data = (int *)ALLOCA(10); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B() { int * data; data = NULL; goto source; source: data = (int *)ALLOCA(10*sizeof(int)); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_84_goodB2G.cpp", "text": "data = (void *)WIDE_STRING; CWE121_Stack_Based_Buffer_Overflow__CWE135_84_goodB2G::~CWE121_Stack_Based_Buffer_Overflow__CWE135_84_goodB2G() { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} memcpy(dest, data, (dataLen+1)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct) { int * data = myStruct.structFirst; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct) { int * data = myStruct.structFirst; { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct) { int * data = myStruct.structFirst; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21.c", "text": "static int badStatic = 0; static void badSink(int data) int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21.c", "text": "static int badStatic = 0; static void badSink(int data) int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(int data) int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21.c", "text": "fscanf(stdin, \"%d\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(int data) int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(int data) int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_82_goodG2B.cpp", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE121_Stack_Based_Buffer_Overflow__CWE135_82 { void CWE121_Stack_Based_Buffer_Overflow__CWE135_82_goodG2B::action(void * data) { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy((char *)dest, (char *)data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_09.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncat * BadSink : Copy data to string using strncat void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_09_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_TRUE) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_09.c", "text": "{ char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_TRUE) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_34.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_34.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: ncat * BadSink : Copy data to string using strncat * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_34_bad() { char * data; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_34_unionType myUnion; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_34_unionType myUnion; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_12.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_12.c", "text": "data = dataBuffer; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_33.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_33.cpp", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: ncpy * BadSink : Copy data to string using strncpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_32.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_32.c", "text": "{ char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100]; data = dataBuffer; { char * data = *dataPtr1; memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100]; data = dataBuffer; { char * data = *dataPtr1; memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53d.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53d_goodG2BSink(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove #include <wchar.h> void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_06.c", "text": "{ char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34_bad() { char * data; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34_unionType myUnion; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_34_unionType myUnion; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_84_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_84_goodG2B::~CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_84_goodG2B() { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_32.c", "text": "{ char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; { char * data = *dataPtr1; memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; { char * data = *dataPtr1; memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; goodG2BSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_10.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_10_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(globalTrue) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_10.c", "text": "{ char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(globalTrue) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_31.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: ncpy * BadSink : Copy data to string using strncpy * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_31_bad() { char * data; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_74b.cpp", "text": "char * data = dataMap[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_74b.cpp", "text": "char * data = dataMap[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_65b.c", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_65b_goodG2BSink(char * data) { { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_11.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncat * BadSink : Copy data to string using strncat void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_11_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_11.c", "text": "{ char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_18.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; goto source; source: memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badGlobal = 0; char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badSource(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badGlobal = 0; char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badSource(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); int CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B2Global = 0; char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B1Source(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22a.c", "text": "data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_badSource(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); int CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B2Global = 0; char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B1Source(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); } char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B2Global = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_22_goodG2B2Source(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_83_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_83_bad::~CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_83_bad() { { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_84_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_84_goodG2B::~CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_84_goodG2B() { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_32.c", "text": "{ char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100]; data = dataBuffer; { char * data = *dataPtr1; memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100]; data = dataBuffer; { char * data = *dataPtr1; memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_14.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncat * BadSink : Copy data to string using strncat void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_14_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(globalFive==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_14.c", "text": "{ char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(globalFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_67b.c", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_07.c", "text": "{ char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_12.c", "text": "data = dataBuffer; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21.c", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; goodG2B2Static = 1; data = goodG2B2Source(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_18.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_18.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cat * BadSink : Copy string to data using strcat void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_18_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); goto source; source: data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); goto source; source: data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_03.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; if(5==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_67b.c", "text": "strcat(dest, data); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_12.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_12.c", "text": "{ char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_03.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(5==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_18.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cat * BadSink : Copy string to data using strcat void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_18_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; goto source; source: data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; goto source; source: data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_12.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_12_bad() { char * data; if(globalReturnsTrueOrFalse()) { data = dataBadBuffer; data[0] = '\\0'; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; if(globalReturnsTrueOrFalse()) { data = dataGoodBuffer; data[0] = '\\0'; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68b.c", "text": "strcat(dest, data); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68_goodG2BData; { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_83_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_83_bad::~CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_83_bad() { { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badGlobal = 0; char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badGlobal = 0; char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badSource(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); int CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B2Global = 0; char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B1Source(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22a.c", "text": "char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_badSource(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); int CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B2Global = 0; char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B1Source(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); } char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B2Global = 1; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_22_goodG2B2Source(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_13.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45.c", "text": "strcat(dest, data); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45_bad() { char * data; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45_badData = data; static void goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45_goodG2BData; { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_33.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_33.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_01.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_01.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_18.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_18_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; goto source; source: data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; goto source; source: data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_15.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_15_bad() { char * data; char dataBuffer[100]; data = dataBuffer; switch(6) { case 6: memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_15.c", "text": "char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; switch(6) { case 6: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_63b.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: cat * BadSink : Copy data to string using strcat * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34_bad() { char * data; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34_unionType myUnion; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B() { char * data; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34_unionType myUnion; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_05.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cpy * BadSink : Copy string to data using strcpy data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_05.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; if(staticTrue) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_51b.c", "text": "strcpy(dest, data); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_51b_goodG2BSink(char * data) { { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_41.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_41_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_41_bad() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataBadBuffer; data[0] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_41_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_10.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(globalTrue) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_18.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_18_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); goto source; source: data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); goto source; source: data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_16.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_16_bad() { char * data; char dataBuffer[100]; data = dataBuffer; while(1) { memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; while(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61a.c", "text": "char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61b_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61b_badSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61a.c", "text": "char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61b_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61b_badSource(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); #ifndef OMITGOOD char * CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61b_goodG2BSource(char * data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_61b_goodG2BSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_67b.c", "text": "strcpy(dest, data); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_84_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_84_goodG2B::~CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_84_goodG2B() { { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_13.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_FIVE==5) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_13.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_FIVE==5) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_13.c", "text": "#endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_FIVE==5) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); if(GLOBAL_CONST_FIVE==5) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_51b.c", "text": "strcpy(dest, data); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_51b_goodG2BSink(char * data) { { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_07.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; } charVoid; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); if(staticFive==5) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_41_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_63b.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_63b_goodG2BSink(wchar_t * * dataPtr) { wchar_t * data = *dataPtr; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_31.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_31.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_31_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_42.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; return data; void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_42_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; data = badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_42.c", "text": "#ifndef OMITBAD static wchar_t * badSource(wchar_t * data) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; return data; void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_42_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; data = badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD static wchar_t * goodG2BSource(wchar_t * data) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; return data; static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; data = goodG2BSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_01.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_11.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_11_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_11.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(globalReturnsTrue()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_16.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_16.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_16_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; while(1) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; while(1) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_43.cpp", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; void bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_43.cpp", "text": "* GoodSource: Initialize data as a small string * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(wchar_t * &data) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; void bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD static void goodG2BSource(wchar_t * &data) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; goodG2BSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_68b.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_68b_goodG2BSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_68_goodG2BData; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_43.cpp", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; void bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_43.cpp", "text": "* GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(wchar_t * &data) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; void bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD static void goodG2BSource(wchar_t * &data) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; goodG2BSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_01.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_33.cpp", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t * data = dataRef; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_33.cpp", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100]; data = dataBuffer; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t * data = dataRef; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100]; data = dataBuffer; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t * data = dataRef; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_08.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_08_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_08.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_41.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_41_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_41_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_02.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_02_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(1) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_02.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(1) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_65b.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_65b_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_63b.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_63b_goodG2BSink(wchar_t * * dataPtr) { wchar_t * data = *dataPtr; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_18.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; goto source; source: wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_74b.cpp", "text": "wchar_t * data = dataMap[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_74b.cpp", "text": "wchar_t * data = dataMap[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void goodG2BSink(map<int, wchar_t *> dataMap) { wchar_t * data = dataMap[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_13.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_13_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_13.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_17.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { int h; wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; for(h = 0; h < 1; h++) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_08.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_08_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(staticReturnsTrue()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_08.c", "text": "{ wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(staticReturnsTrue()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_65b.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_65b_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_51b.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_51b_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_52c.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_01.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54e.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54e_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badGlobal = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badSource(wchar_t * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badGlobal = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badSource(wchar_t * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B2Global = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22a.c", "text": "data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B2Global = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); } wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B2Source(wchar_t * data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B2Global = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_22_goodG2B2Source(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_64a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_64a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63a.c", "text": "void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63b_badSink(int * dataPtr); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63a.c", "text": "void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63b_badSink(int * dataPtr); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_63_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_64b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_64b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_53b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_53b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_31.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_31.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_54c.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_54c.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_44.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_44.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_44.cpp", "text": "dataBytes = data * sizeof(int); intPointer = (int*)new char[dataBytes]; for (i = 0; i < (size_t)data; i++) void bad() { int data; void (*funcPtr) (int) = badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_06.c", "text": "#ifndef OMITBAD void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_06_bad()", "label": 0}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_06.c", "text": "#ifndef OMITBAD void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51a.c", "text": "void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51b_badSink(int data); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51a.c", "text": "void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51b_badSink(int data); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54a.c", "text": "void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54b_badSink(int data); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54a.c", "text": "void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54b_badSink(int data); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_08.c", "text": "if(staticReturnsTrue()) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_08.c", "text": "if(staticReturnsTrue()) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_08.c", "text": "if(staticReturnsTrue()) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive); printLine(dest); if(staticReturnsTrue()) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_16.c", "text": "while(1) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_16.c", "text": "while(1) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive); printLine(dest); while(1) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_14.c", "text": "if(globalFive==5) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_14.c", "text": "if(globalFive==5) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_14.c", "text": "if(globalFive==5) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive); printLine(dest); if(globalFive==5) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_10.c", "text": "if(globalTrue) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_10.c", "text": "if(globalTrue) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_10.c", "text": "if(globalTrue) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive); printLine(dest); if(globalTrue) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE328_Reversible_One_Way_Hash/CWE328_Reversible_One_Way_Hash__w32_SHA1_03.c", "text": "{ HCRYPTPROV hCryptProv; HCRYPTHASH hHash; FILE *pFile = NULL; DWORD hashSize; char *replace; size_t i; pFile = fopen(\"password.txt\", \"r\"); if (pFile == NULL) } for (i = 0; i < SHA1_SUM_SIZE; i++) { ULONG val; if (fscanf(pFile, \"%02x\", &val) != 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE328_Reversible_One_Way_Hash/CWE328_Reversible_One_Way_Hash__w32_SHA1_03.c", "text": "{ HCRYPTPROV hCryptProv; HCRYPTHASH hHash; FILE *pFile = NULL; DWORD hashSize; char *replace; size_t i; pFile = fopen(\"password.txt\", \"r\"); if (pFile == NULL) } for (i = 0; i < SHA1_SUM_SIZE; i++) { ULONG val; if (fscanf(pFile, \"%02x\", &val) != 1) { fclose(pFile); exit(1); } if (val > 0xff) { fclose(pFile); exit(1); } savedHash[i] = (UCHAR)val; } if (pFile) { fclose(pFile); } if (fgets(password, PASSWORD_INPUT_SIZE, stdin) == NULL) { HCRYPTPROV hCryptProv; HCRYPTHASH hHash; FILE *pFile = NULL; DWORD hashSize; char *replace; size_t i; pFile = fopen(\"password.txt\", \"r\"); if (pFile == NULL) } for (i = 0; i < SHA512_SUM_SIZE; i++) { ULONG val; if (fscanf(pFile, \"%02x\", &val) != 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE328_Reversible_One_Way_Hash/CWE328_Reversible_One_Way_Hash__w32_MD2_04.c", "text": "#define MD2_SUM_SIZE (128 / 8) /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their { HCRYPTPROV hCryptProv; HCRYPTHASH hHash; FILE *pFile = NULL; DWORD hashSize; char *replace; size_t i; pFile = fopen(\"password.txt\", \"r\"); if (pFile == NULL) } for (i = 0; i < MD2_SUM_SIZE; i++) { ULONG val; if (fscanf(pFile, \"%02x\", &val) != 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, static void goodG2B() { wchar_t * password; void (*funcPtr) (wchar_t *) = goodG2BSink; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; wcscpy(password, L\"Password1234!\"); funcPtr(password); } static void goodB2GSink(wchar_t * password) wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44.c", "text": "* GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD static void badSink(wchar_t * password) { { HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44_bad() { wchar_t * password; void (*funcPtr) (wchar_t *) = badSink; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44.c", "text": "payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } { break; } memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(wchar_t)] = L'\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserW( username, domain, password, static void goodB2G() { wchar_t * password; void (*funcPtr) (wchar_t *) = goodB2GSink; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_64b.c", "text": "if (LogonUserW( username, domain, password, { wchar_t * * passwordPtr = (wchar_t * *)passwordVoidPtr; wchar_t * password = (*passwordPtr); HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, { wchar_t * * passwordPtr = (wchar_t * *)passwordVoidPtr; wchar_t * password = (*passwordPtr); wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66b.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66b_goodG2BSink(wchar_t * passwordArray[]) { wchar_t * password = passwordArray[2]; HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66b_goodB2GSink(wchar_t * passwordArray[]) { wchar_t * password = passwordArray[2]; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67b.c", "text": "HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67b_goodG2BSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67_structType myStruct) { char * password = myStruct.structFirst; HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67b_goodB2GSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67_structType myStruct) { char * password = myStruct.structFirst; char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_63b.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_63b_goodG2BSink(wchar_t * * passwordPtr) { wchar_t * password = *passwordPtr; HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_63b_goodB2GSink(wchar_t * * passwordPtr) { wchar_t * password = *passwordPtr; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_32.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(password, L'\\r'); { *replace = L'\\0'; } replace = wcschr(password, L'\\n'); WSACleanup(); } } *passwordPtr1 = password; } { wchar_t * password = *passwordPtr2; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_32.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, static void goodB2G() { wchar_t * password; wchar_t * *passwordPtr1 = &password; wchar_t * *passwordPtr2 = &password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { wchar_t * password = *passwordPtr1; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_84_bad.cpp", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext { CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_84_bad::CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_84_bad(char * passwordCopy) { password = passwordCopy; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_09.c", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_09_bad() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82a.cpp", "text": "} } CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82_base* baseObject = new CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82_bad; baseObject->action(password); static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82_base* baseObject = new CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82_goodG2B; baseObject->action(password); static void goodB2G() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82a.cpp", "text": "{ char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } } CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82_base* baseObject = new CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_82_bad; baseObject->action(password); static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_32.c", "text": "recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(password, L'\\r'); { *replace = L'\\0'; } replace = wcschr(password, L'\\n'); WSACleanup(); } } *passwordPtr1 = password; } { wchar_t * password = *passwordPtr2; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_32.c", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_32_bad() { wchar_t * password; wchar_t * *passwordPtr1 = &password; wchar_t * *passwordPtr2 = &password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { wchar_t * password = *passwordPtr1; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_32.c", "text": "wcscpy(password, L\"Password1234!\"); *passwordPtr1 = password; } { wchar_t * password = *passwordPtr2; { HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, static void goodB2G() { wchar_t * password; wchar_t * *passwordPtr1 = &password; wchar_t * *passwordPtr2 = &password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { wchar_t * password = *passwordPtr1; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67a.c", "text": "static void goodG2B() { char * password; CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67_structType myStruct; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); myStruct.structFirst = password; static void goodB2G() { char * password; CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67_structType myStruct; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67a.c", "text": "char * password; CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67_structType myStruct; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); WSACleanup(); } } myStruct.structFirst = password; static void goodG2B() { char * password; CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_67_structType myStruct; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_74a.cpp", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void bad() { char * password; map<int, char *> passwordMap; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_74a.cpp", "text": "} passwordMap[0] = password; passwordMap[1] = password; passwordMap[2] = password; static void goodG2B() { char * password; map<int, char *> passwordMap; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); passwordMap[0] = password; passwordMap[1] = password; passwordMap[2] = password; static void goodB2G() { char * password; map<int, char *> passwordMap; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_74a.cpp", "text": "char * password; map<int, char *> passwordMap; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); } recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); WSACleanup(); } } passwordMap[0] = password; passwordMap[1] = password; passwordMap[2] = password; static void goodG2B() { char * password; map<int, char *> passwordMap; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_44.c", "text": "HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, static void goodG2B() { char * password; void (*funcPtr) (char *) = goodG2BSink; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); funcPtr(password); } static void goodB2GSink(char * password) char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_44.c", "text": "* @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD static void badSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_44_bad() { char * password; void (*funcPtr) (char *) = badSink; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_44.c", "text": "payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } { break; } memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(char)] = '\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserA( username, domain, password, static void goodB2G() { char * password; void (*funcPtr) (char *) = goodB2GSink; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_44.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); } recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } } funcPtr(password); #ifndef OMITGOOD static void goodG2BSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, static void goodG2B() { char * password; void (*funcPtr) (char *) = goodG2BSink; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_74b.cpp", "text": "HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void goodG2BSink(map<int, char *> passwordMap) { char * password = passwordMap[2]; HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void goodB2GSink(map<int, char *> passwordMap) { char * password = passwordMap[2]; char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_31.c", "text": "break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(password, L'\\r'); { *replace = L'\\0'; } replace = wcschr(password, L'\\n'); } } { wchar_t * passwordCopy = password; wchar_t * password = passwordCopy; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_31.c", "text": "wcscpy(password, L\"Password1234!\"); { wchar_t * passwordCopy = password; wchar_t * password = passwordCopy; { HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, static void goodB2G() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_02.c", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_02_bad() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54a.c", "text": "void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54b_badSink(char * password); void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54_bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54a.c", "text": "{ char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54b_goodG2BSink(password); } void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54b_goodB2GSink(char * password); static void goodB2G() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54a.c", "text": "{ WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); WSACleanup(); } } CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54b_badSink(password); #ifndef OMITGOOD void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54b_goodG2BSink(char * password); static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_68b.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_68b_goodG2BSink() { wchar_t * password = CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_68_goodG2BData; HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_68b_goodB2GSink() { wchar_t * password = CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_68_goodB2GData; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_61a.c", "text": "char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; password = CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_61b_goodG2BSource(password); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, } char * CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_61b_goodB2GSource(char * password); static void goodB2G() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; password = CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_61b_goodB2GSource(password); char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_66a.c", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_66_bad() { char * password; char * passwordArray[5]; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_66a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); WSACleanup(); } } passwordArray[2] = password; static void goodG2B() { char * password; char * passwordArray[5]; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); passwordArray[2] = password; static void goodB2G() { char * password; char * passwordArray[5]; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_66a.c", "text": "char * password; char * passwordArray[5]; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); } recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); WSACleanup(); } } passwordArray[2] = password; static void goodG2B() { char * password; char * passwordArray[5]; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_05.c", "text": "void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_05_bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_42.c", "text": "{ wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; password = goodG2BSource(password); { HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, } static wchar_t * goodB2GSource(wchar_t * password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_67b.c", "text": "HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_67b_goodG2BSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_67_structType myStruct) { char * password = myStruct.structFirst; HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_67b_goodB2GSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_67_structType myStruct) { char * password = myStruct.structFirst; char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_52c.c", "text": "HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, #ifndef OMITGOOD void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_52c_goodG2BSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, } void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_52c_goodB2GSink(char * password) char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_02.c", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_02_bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_65b.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, #ifndef OMITGOOD void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_65b_goodG2BSink(wchar_t * password) HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, } void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_65b_goodB2GSink(wchar_t * password) wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_66a.c", "text": "void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_66b_badSink(wchar_t * dataArray[]); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_66_bad() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_66a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_66b_goodG2BSink(wchar_t * dataArray[]); static void goodG2B() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); dataArray[2] = data; } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_66b_goodB2GSink(wchar_t * dataArray[]); static void goodB2G() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22a.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_badSink(data); int CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_goodB2G1Sink(wchar_t * data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22a.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_goodB2G1Sink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_22_goodB2G2Sink(wchar_t * data); static void goodB2G2() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_42.c", "text": "data = dataBuffer; data = badSource(data); fwprintf(stdout, data); #ifndef OMITGOOD static wchar_t * goodG2BSource(wchar_t * data) { wcscpy(data, L\"fixedstringtest\"); return data; static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; data = goodG2BSource(data); fwprintf(stdout, data); } static wchar_t * goodB2GSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_81a.cpp", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } const CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_81_bad(); baseObject.action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); const CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_81_goodG2B(); baseObject.action(data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_62b.cpp", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #ifndef OMITGOOD void goodG2BSource(wchar_t * &data) { wcscpy(data, L\"fixedstringtest\"); } void goodB2GSource(wchar_t * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_04.c", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(STATIC_CONST_TRUE) { fwprintf(stdout, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_05.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(staticTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_05.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(staticTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(staticTrue) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_06.c", "text": "#endif size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(STATIC_CONST_FIVE==5) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_06.c", "text": "if(STATIC_CONST_FIVE==5) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_06.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(STATIC_CONST_FIVE==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_06.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(STATIC_CONST_FIVE==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(STATIC_CONST_FIVE==5) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_31.c", "text": "* GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 31 Data flow using a copy of data within the same function void CWE134_Uncontrolled_Format_String__char_file_snprintf_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_32.c", "text": "{ char * data = *dataPtr2; fprintf(stdout, data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"fixedstringtest\"); *dataPtr1 = data; } { char * data = *dataPtr2; fprintf(stdout, data); static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_32.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_fprintf_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; fprintf(stdout, data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_10.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalTrue) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_10.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); } if(globalTrue) { goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_42.c", "text": "strncat(data+dataLen, environment, 100-dataLen-1); } } return data; void CWE134_Uncontrolled_Format_String__char_environment_printf_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); printf(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcpy(data, \"fixedstringtest\"); return data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = goodG2BSource(data); printf(data); } static char * goodB2GSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_42.c", "text": "* Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; void CWE134_Uncontrolled_Format_String__char_environment_printf_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); printf(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_45.c", "text": "{ char * data = CWE134_Uncontrolled_Format_String__char_file_fprintf_45_badData; fprintf(stdout, data); void CWE134_Uncontrolled_Format_String__char_file_fprintf_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_fprintf_45_badData = data; static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_file_fprintf_45_goodG2BData; fprintf(stdout, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65a.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65_bad() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_badVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65a.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data, data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); funcPtr(data); } void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_goodB2GVaSink(char * data, ...); static void goodB2G() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_goodB2GVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65a.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65_bad() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_badVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data, data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_14.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalFive==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_14.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); } if(globalFive==5) { goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_41.c", "text": "static void badSink(char * data) { printf(data); void CWE134_Uncontrolled_Format_String__char_file_printf_41_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { printf(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_13.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_fprintf_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_13.c", "text": "if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_13.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_13.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_52a.c", "text": "* Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_vfprintf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_21.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } goodB2G2Static = 1; goodB2G2_vasink(data, data); } static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_08.c", "text": "vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_08_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_08.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(staticReturnsTrue()) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_08.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { goodB2G1VaSinkG(data, data); } } static void goodB2G2VaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_08.c", "text": "{ char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(staticReturnsTrue()) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_02.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(1) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_14.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_snprintf_14_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_14.c", "text": "{ char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_14.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_14.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_61b.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_61b_badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; #ifndef OMITGOOD char * CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_61b_goodG2BSource(char * data) { strcpy(data, \"fixedstringtest\"); return data; } char * CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_61b_goodB2GSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_61b.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_61b_badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; #ifndef OMITGOOD char * CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_61b_goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_52a.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_printf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_printf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_52a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_printf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_printf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_printf_52b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_environment_printf_52b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_52a.c", "text": "* Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_environment_printf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_printf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_printf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_printf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_08.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(staticReturnsTrue()) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_08.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(staticReturnsTrue()) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(staticReturnsTrue()) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_06.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_06.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(STATIC_CONST_FIVE==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_22a.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_22_goodB2G2_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_22_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_10.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_fprintf_10_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalTrue) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_10.c", "text": "if(globalTrue) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_10.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_10.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalTrue) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_51a.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_snprintf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_51a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_51a.c", "text": "* Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_snprintf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_snprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_18.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; goto sink; sink: fprintf(stdout, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; goto sink; sink: fprintf(stdout, \"%s\\n\", data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_11.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_printf_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalReturnsTrue()) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_11.c", "text": "if(globalReturnsTrue()) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_11.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalReturnsTrue()) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_11.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalReturnsTrue()) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalReturnsTrue()) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_66a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_snprintf_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_63a.c", "text": "* BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_fprintf_63_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_fprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_fprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_82a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE134_Uncontrolled_Format_String__char_file_printf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_file_printf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_badVaSink(data, data); int CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G1_vasink(char * data, ...); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G1_vasink(char * data, ...); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G1_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G2_vasink(char * data, ...); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_22a.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G1_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G2_vasink(char * data, ...); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodB2G2_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_environment_vprintf_22_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_09.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(GLOBAL_CONST_TRUE) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_15.c", "text": "vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_environment_vprintf_15_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_15.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); switch(7) { case 7: badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_15.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); printLine(\"Benign, fixed string\"); break; default: goodB2G1VaSinkG(data, data); } } static void goodB2G2VaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_15.c", "text": "{ { va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); switch(7) { case 7: goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_15.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; break; default: strcpy(data, \"fixedstringtest\"); switch(7) { case 7: goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_63a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_vprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_vprintf_63b_goodG2BSink(&data); } void CWE134_Uncontrolled_Format_String__char_environment_vprintf_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_63a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_vprintf_63_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_vprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_16.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; while(1) { fprintf(stdout, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; while(1) { fprintf(stdout, \"%s\\n\", data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_53a.c", "text": "* Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_fprintf_53b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_fprintf_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_fprintf_53b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_fprintf_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_21.c", "text": "static int badStatic = 0; static void badSink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); void CWE134_Uncontrolled_Format_String__char_environment_snprintf_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_21.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_snprintf_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_21.c", "text": "static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_21.c", "text": "} static void goodB2G2Sink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } goodB2G2Static = 1; goodB2G2Sink(data); } static void goodG2BSink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_65a.c", "text": "#ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_snprintf_65b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_snprintf_65_bad() { char * data; void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_file_snprintf_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_snprintf_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_file_snprintf_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_54a.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_printf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_printf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_54a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_printf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_printf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_printf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_environment_printf_54b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_54a.c", "text": "* Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_environment_printf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_printf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_printf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_printf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_03.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(5==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_03.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(5==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(5==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_31.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_44.c", "text": "printf(data); void CWE134_Uncontrolled_Format_String__char_environment_printf_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_44.c", "text": "} } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { printf(data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); funcPtr(data); } static void goodB2GSink(char * data) { printf(\"%s\\n\", data); static void goodB2G() { char * data; void (*funcPtr) (char *) = goodB2GSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) { printf(data); void CWE134_Uncontrolled_Format_String__char_environment_printf_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { printf(data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_54a.c", "text": "void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_54a.c", "text": "* Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_snprintf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_snprintf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_snprintf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_snprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_01.c", "text": "data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_01.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_snprintf_01_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_04.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(STATIC_CONST_TRUE) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void badSink() { char * data = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_badData; badVaSink(data, data); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45.c", "text": "static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_goodG2BData; goodG2BVaSink(data, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_goodG2BData = data; } static void goodB2GVaSink(char * data, ...) { { va_list args; va_start(args, data); static void goodB2GSink() { char * data = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_goodB2GData; goodB2GVaSink(data, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45.c", "text": "static void badSink() { char * data = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_badData; badVaSink(data, data); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_badData = data; #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_environment_vfprintf_45_goodG2BData; goodG2BVaSink(data, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_84_goodG2B.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_84_goodG2B::CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_64a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_snprintf_64_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_snprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_05.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_fprintf_05_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_05.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_fprintf_05_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(staticTrue) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_05.c", "text": "if(staticTrue) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_05.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(staticTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_05.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(staticTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(staticTrue) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_07.c", "text": "#endif size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(staticFive==5) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_07.c", "text": "if(staticFive==5) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_07.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(staticFive==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_07.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(staticFive==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(staticFive==5) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_72a.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_badVaSink(data, data); int CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G1_vasink(char * data, ...); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G1_vasink(char * data, ...); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G1_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G2_vasink(char * data, ...); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22a.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G1_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G2_vasink(char * data, ...); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodB2G2_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_22_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_16.c", "text": "vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_16_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_16.c", "text": "{ { va_list args; va_start(args, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } while(1) { goodB2GVaSinkG(data, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_65a.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_fprintf_65_bad() { char * data; void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_65a.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); funcPtr(data); } void CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_goodB2GSink(char * data); static void goodB2G() { char * data; void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_goodB2GSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_65a.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_fprintf_65_bad() { char * data; void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE134_Uncontrolled_Format_String__char_environment_fprintf_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45.c", "text": "static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodG2BData = data; static void goodB2GSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodB2GData; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData = data; static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodG2BData; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51a.c", "text": "void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65a.c", "text": "void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65_bad() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_badVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); funcPtr(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_goodB2GVaSink(char * data, ...); static void goodB2G() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_goodB2GVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data, data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_10.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalTrue) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53a.c", "text": "void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_74a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_15.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; break; default: strcpy(data, \"fixedstringtest\"); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45.c", "text": "static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45_badData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45_goodG2BData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45_goodB2GData; static void badSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45_badData; { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45.c", "text": "data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45_goodG2BData = data; static void goodB2GSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45_goodB2GData; { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, L\"%s\", data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); myStruct.structFirst = data; static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67a.c", "text": "char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_02.c", "text": "vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_02.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } if(1) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_02.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(1) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_62b.cpp", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #ifndef OMITGOOD void goodG2BSource(char * &data) { strcpy(data, \"fixedstringtest\"); } void goodB2GSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_62b.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_62b.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45.c", "text": "#define IP_ADDRESS \"127.0.0.1\" static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45_badData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45_goodG2BData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45_goodB2GData; static void badSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45_badData; fwprintf(stdout, data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45.c", "text": "wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45_goodG2BData = data; static void goodB2GSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_45_goodB2GData; fwprintf(stdout, L\"%s\\n\", data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51a.c", "text": "void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63b_goodG2BSink(&data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65a.c", "text": "void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65_bad() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_badVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); funcPtr(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_goodB2GVaSink(char * data, ...); static void goodB2G() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_goodB2GVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data, data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_62b.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_12.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); else { strcpy(data, \"fixedstringtest\"); if(globalReturnsTrueOrFalse()) { printf(data); else { printf(\"%s\\n\", data); use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_12.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_12.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { printf(\"%s\\n\", data); else { printf(\"%s\\n\", data); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_12.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { printf(\"%s\\n\", data); else { printf(\"%s\\n\", data); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"fixedstringtest\"); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_09.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(GLOBAL_CONST_TRUE) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_66a.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fwprintf with \"%s\" as the second argument and data as the third * BadSink : fwprintf with data as the second argument * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_66b_badSink(wchar_t * dataArray[]); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_66_bad() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_66a.c", "text": "wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); dataArray[2] = data; } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_66b_goodB2GSink(wchar_t * dataArray[]); static void goodB2G() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53a.c", "text": "void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_82a.cpp", "text": "#endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_82_bad; baseObject->action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_32.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: swprintf * GoodSink: snwprintf with \"%s\" as the third argument and data as the fourth * BadSink : snwprintf with data as the third argument void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_32_bad() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; { wchar_t * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_32.c", "text": "*dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; { wchar_t * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_13.c", "text": "vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_13.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(GLOBAL_CONST_FIVE==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_84_goodG2B.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE134_Uncontrolled_Format_String__char_file_vprintf_84_goodG2B::CWE134_Uncontrolled_Format_String__char_file_vprintf_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_53a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: wprintf with \"%s\" as the first argument and data as the second * BadSink : wprintf with only data as an argument * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_53b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_53_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_53a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_53b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_53b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_14.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(globalFive==5) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_14.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalFive==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_14.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalFive==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalFive==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_32.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: wprintf with \"%s\" as the first argument and data as the second * BadSink : wprintf with only data as an argument void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_32_bad() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; { wchar_t * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_32.c", "text": "wchar_t * data = *dataPtr1; wcscpy(data, L\"fixedstringtest\"); *dataPtr1 = data; } { wchar_t * data = *dataPtr2; wprintf(data); static void goodB2G() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; { wchar_t * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_12.c", "text": "#ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); } } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_12.c", "text": "#ifndef OMITGOOD static void goodB2GVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); } } static void goodB2GVaSinkG(char * data, ...) { { va_list args; va_start(args, data); use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_12.c", "text": "} } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_12.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { { va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_12.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { { va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"fixedstringtest\"); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_21.c", "text": "static int badStatic = 0; static void badSink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_21.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_21.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_21.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } goodB2G2Static = 1; goodB2G2Sink(data); } static void goodG2BSink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_61b.c", "text": "{ CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } return data; #ifndef OMITGOOD char * CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_61b_goodG2BSource(char * data) { strcpy(data, \"fixedstringtest\"); return data; } char * CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_61b_goodB2GSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_61b.c", "text": "* Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_61b_badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_61b_goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_10.c", "text": "vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_10_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_10.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(globalTrue) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_04.c", "text": "} } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(STATIC_CONST_TRUE) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_14.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(globalFive==5) { wprintf(data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_02.c", "text": "vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_02.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(1) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_51a.c", "text": "* Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_vprintf_51b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_vprintf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_vprintf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_vprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45.c", "text": "printf(data); void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45.c", "text": "{ char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodG2BData; printf(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodG2BData = data; static void goodB2GSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodB2GData; printf(\"%s\\n\", data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_badData = data; static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_goodG2BData; printf(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_54a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vwprintf with a format string * BadSink : vwprintf without a format string * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_54b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_54_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_54a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_54b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_64a.c", "text": "} #endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_64b_badSink(&data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_64b_goodG2BSink(&data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_13.c", "text": "#ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_13_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_13.c", "text": "} if(GLOBAL_CONST_FIVE==5) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_52a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: _vsnwprintf with a format string * BadSink : _vsnwprintf without a format string * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_52b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_52a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_52b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_52b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_54a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfwprintf with a format string * BadSink : vfwprintf without a format string * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_54b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_54_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_54a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_54b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_17.c", "text": "#ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_17_bad() { int i,j; wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_17.c", "text": "} for(j = 0; j < 1; j++) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2GVaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G() { int i,k; wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: _vsnwprintf with a format string * BadSink : _vsnwprintf without a format string * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68_badData; wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68_goodG2BData; wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68_goodB2GData; void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68a.c", "text": "} #endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68_badData = data; static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_68_goodG2BData = data; static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_33.cpp", "text": "#ifndef OMITBAD static void badVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_33.cpp", "text": "wcscpy(data, L\"fixedstringtest\"); { wchar_t * data = dataRef; goodG2BVaSink(data, data); } static void goodB2GVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_08.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { va_list args; va_start(args, data); vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_08_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_08.c", "text": "} if(staticReturnsTrue()) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_34.c", "text": "#ifndef OMITBAD static void badVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_34_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_34.c", "text": "myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; goodG2BVaSink(data, data); } static void goodB2GVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G() { wchar_t * data; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_34_unionType myUnion; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_81a.cpp", "text": "#endif } const CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_81_bad(); baseObject.action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); const CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_81_goodG2B(); baseObject.action(data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_11.c", "text": "#ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_11_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_11.c", "text": "} if(globalReturnsTrue()) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_11.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { va_list args; va_start(args, data); vwprintf(data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_11_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_74a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfwprintf with a format string * BadSink : vfwprintf without a format string * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #ifndef OMITBAD void badSink(map<int, wchar_t *> dataMap); void bad() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_52a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vwprintf with a format string * BadSink : vwprintf without a format string * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_52b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_52a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_52b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_52b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_02.c", "text": "#ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_02_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_02.c", "text": "} if(1) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_12.c", "text": "va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); } } static void badVaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_12_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_12.c", "text": "va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); } } static void goodB2GVaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); use the GoodSink */ static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_44.c", "text": "#ifndef OMITBAD static void badVaSink(wchar_t * data, ...) { { va_list args; va_start(args, data); vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = badVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_04.c", "text": "#define IP_ADDRESS \"127.0.0.1\" vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_04_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_68a.c", "text": "} #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_68_goodG2BData = data; static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_68a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_05.c", "text": "{ char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_05.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_17.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_17_bad() { int i,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_17.c", "text": "} for(j = 0; j < 1; j++) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2GVaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { int i,k; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_17.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } for(k = 0; k < 1; k++) { goodB2GVaSinkG(data, data); } } static void goodG2BVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { int h,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82a.cpp", "text": "#endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_09.c", "text": "else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_TRUE) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_09.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_TRUE) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(GLOBAL_CONST_TRUE) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_07.c", "text": "#define IP_ADDRESS \"127.0.0.1\" vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_07_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_07.c", "text": "} if(staticFive==5) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_07.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(staticFive==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_31.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char * dataCopy = data; char * data = dataCopy; fprintf(stdout, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_31.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; fprintf(stdout, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_43.cpp", "text": "* Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); fprintf(stdout, data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_10.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(globalTrue) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_10.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_10.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalTrue) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_14.c", "text": "else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_14.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalFive==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_10.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_10_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_10.c", "text": "} if(globalTrue) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_10.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(globalTrue) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_62b.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: console Read input from the console * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_31.c", "text": "void CWE134_Uncontrolled_Format_String__char_console_fprintf_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; fprintf(stdout, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_06.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(STATIC_CONST_FIVE==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81a.cpp", "text": "#endif } const CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); const CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_goodG2B(); baseObject.action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_62b.cpp", "text": "* Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_42.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; } static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_console_vfprintf_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); badVaSink(data, data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_62b.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: console Read input from the console * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_goodG2B.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: console Read input from the console * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_goodG2B::CWE134_Uncontrolled_Format_String__char_console_vfprintf_83_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vprintf_11.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalReturnsTrue()) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_53a.c", "text": "void CWE134_Uncontrolled_Format_String__char_console_printf_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_printf_53b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_console_printf_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63b_goodG2BSink(&data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_12.c", "text": "va_list args; va_start(args, data); vfprintf(stdout, data, args); } } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__char_console_vfprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_12.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { { va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_13.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_13.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(GLOBAL_CONST_FIVE==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_08.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(staticReturnsTrue()) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_08.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(staticReturnsTrue()) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_08.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(staticReturnsTrue()) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(staticReturnsTrue()) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_54a.c", "text": "void CWE134_Uncontrolled_Format_String__char_console_printf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_printf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_console_printf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_34.c", "text": "* Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) #ifndef OMITBAD static void badVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_34_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_34.c", "text": "myUnion.unionFirst = data; { char * data = myUnion.unionSecond; goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_34.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_81a.cpp", "text": "* Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE134_Uncontrolled_Format_String__char_console_snprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_console_snprintf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_62b.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: console Read input from the console * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_64a.c", "text": "} #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_64b_goodG2BSink(&data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_64a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_18.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_18.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } goto sink; sink: goodB2GVaSinkG(data, data); } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_33.cpp", "text": "#ifndef OMITBAD static void badVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_33.cpp", "text": "strcpy(data, \"fixedstringtest\"); { char * data = dataRef; goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_33.cpp", "text": "{ break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * data = dataRef; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67a.c", "text": "static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); myStruct.structFirst = data; static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_06.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(STATIC_CONST_FIVE==5) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_06.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_06.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(STATIC_CONST_FIVE==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_42.c", "text": "{ strcpy(data, \"fixedstringtest\"); return data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = goodG2BSource(data); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); } static char * goodB2GSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_42.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_01.c", "text": "* GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument void CWE134_Uncontrolled_Format_String__char_console_fprintf_01_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } fprintf(stdout, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_67a.c", "text": "static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); myStruct.structFirst = data; static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_67a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_32.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_03.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_03_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_03.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(5==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vprintf_67a.c", "text": "* Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_console_vprintf_67_bad() { char * data; CWE134_Uncontrolled_Format_String__char_console_vprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_console_vprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_83_goodG2B.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: console Read input from the console * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE134_Uncontrolled_Format_String__char_console_printf_83_goodG2B::CWE134_Uncontrolled_Format_String__char_console_printf_83_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_03.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(5==5) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_03.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(5==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_03.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(5==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(5==5) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_33.cpp", "text": "#ifndef OMITBAD static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_33.cpp", "text": "{ break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * data = dataRef; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45.c", "text": "{ { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void badSink() { char * data = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_badData; badVaSink(data, data); void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45.c", "text": "} static void goodB2GVaSink(char * data, ...) { { va_list args; va_start(args, data); static void goodB2GSink() { char * data = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_goodB2GData; goodB2GVaSink(data, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45.c", "text": "recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_badData = data; #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_45_goodG2BData; goodG2BVaSink(data, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_68a.c", "text": "* Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_console_fprintf_68_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_fprintf_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_02.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_02.c", "text": "} if(1) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_02.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(1) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vprintf_17.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } for(k = 0; k < 1; k++) { goodB2GVaSinkG(data, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { int h,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_10.c", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(globalTrue) { wprintf(data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_10.c", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); else { wprintf(L\"%s\\n\", data); static void goodB2G2() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_51a.c", "text": "void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_51b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_51a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_51b_goodG2BSink(wchar_t * data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_51b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_13.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(GLOBAL_CONST_FIVE==5) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_13.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); else { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, L\"%s\", data); static void goodB2G2() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_13.c", "text": "vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_13_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_13.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } if(GLOBAL_CONST_FIVE==5) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_02.c", "text": "_vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_02_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_02.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } if(1) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_44.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: wprintf with \"%s\" as the first argument and data as the second * BadSink : wprintf with only data as an argument * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(wchar_t * data) { wprintf(data); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_44.c", "text": "{ wchar_t * data; void (*funcPtr) (wchar_t *) = goodG2BSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); funcPtr(data); } static void goodB2GSink(wchar_t * data) { wprintf(L\"%s\\n\", data); static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *) = goodB2GSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_03.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(5==5) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_13.c", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(GLOBAL_CONST_FIVE==5) { wprintf(data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_17.c", "text": "vwprintf(data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_17_bad() { int i,j; wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_05.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { va_list args; va_start(args, data); vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_05_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_05.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } if(staticTrue) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_67a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } myStruct.structFirst = data; static void goodG2B() { wchar_t * data; CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_67_structType myStruct; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); myStruct.structFirst = data; static void goodB2G() { wchar_t * data; CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_67_structType myStruct; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_81a.cpp", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } const CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_81_bad(); baseObject.action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); const CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_81_goodG2B(); baseObject.action(data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_01.c", "text": "vwprintf(data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_01_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_68a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_68_badData = data; static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_68_goodG2BData = data; static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_scanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_scanf_12.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: scanf * GoodSink: Check if scanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_scanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_scanf_12.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: scanf * GoodSink: Check if scanf() fails * BadSink : Do not check if scanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_scanf_12.c", "text": "* CWE: 252 Unchecked Return Value * Sinks: scanf * GoodSink: Check if scanf() fails * BadSink : Do not check if scanf() fails #ifndef OMITBAD void CWE252_Unchecked_Return_Value__char_scanf_12_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; scanf(\"%99s\\0\", data); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (scanf(\"%99s\\0\", data) == EOF) { printLine(\"scanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (scanf(\"%99s\\0\", data) == EOF) { printLine(\"scanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (scanf(\"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_scanf_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_scanf_10.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: scanf * GoodSink: Check if scanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_scanf_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_scanf_10.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: scanf * GoodSink: Check if scanf() fails * BadSink : Do not check if scanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_09.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_09.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails * BadSink : Do not check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_18.cpp", "text": "data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_18.cpp", "text": "#include <wchar.h> namespace CWE126_Buffer_Overread__new_char_memcpy_18 void bad() { char * data; data = NULL; goto source; source: data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; static void goodG2B() { char * data; data = NULL; goto source; source: data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memmove_65b.c", "text": "memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_char_memmove_65b_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_43.cpp", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_43.cpp", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD static void goodG2BSource(wchar_t * &data) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; static void goodG2B() { wchar_t * data; data = NULL; goodG2BSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memmove_41.c", "text": "* GoodSource: Use a large buffer * Sink: memmove * BadSink : Copy data to string using memmove * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE126_Buffer_Overread__malloc_char_memmove_41_badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); } } void CWE126_Buffer_Overread__malloc_char_memmove_41_bad() { char * data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE126_Buffer_Overread__malloc_char_memmove_41_badSink(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_char_memmove_41_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_45.c", "text": "#include <wchar.h> static wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_45_badData; static wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_45_goodG2BData; static void badSink() { wchar_t * data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_45_badData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); } } void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_45_bad() { wchar_t * data; data = NULL; data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; CWE126_Buffer_Overread__malloc_wchar_t_memcpy_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_45_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_32.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_32.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = NULL; { wchar_t * data = *dataPtr1; data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_15.c", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_15.c", "text": "void CWE126_Buffer_Overread__malloc_wchar_t_memmove_15_bad() { wchar_t * data; data = NULL; { case 6: data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B1() { wchar_t * data; data = NULL; break; default: data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_15.c", "text": "static void goodG2B1() { wchar_t * data; data = NULL; break; default: data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B2() { wchar_t * data; data = NULL; { case 6: data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_31.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_31.cpp", "text": "void bad() { wchar_t * data; data = NULL; data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B() { wchar_t * data; data = NULL; data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_51b.cpp", "text": "memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; #ifndef OMITGOOD void goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_02.c", "text": "void CWE126_Buffer_Overread__malloc_wchar_t_memmove_02_bad() { wchar_t * data; data = NULL; if(1) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_02.c", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(1) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_51b.c", "text": "memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_wchar_t_memmove_51b_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_73b.cpp", "text": "*/ wchar_t * data = dataList.back(); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD void goodG2BSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_74b.cpp", "text": "char * data = dataMap[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_18.c", "text": "void CWE126_Buffer_Overread__malloc_wchar_t_memmove_18_bad() { wchar_t * data; data = NULL; goto source; source: data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B() { wchar_t * data; data = NULL; goto source; source: data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_01.c", "text": "* BadSource: Use a small buffer * GoodSource: Use a large buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE126_Buffer_Overread__malloc_char_memcpy_01_bad() { char * data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memmove_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memmove_62a.cpp", "text": "#include <wchar.h> namespace CWE126_Buffer_Overread__new_char_memmove_62 #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_31.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_31.c", "text": "void CWE126_Buffer_Overread__malloc_char_memcpy_31_bad() { char * data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_03.c", "text": "void CWE126_Buffer_Overread__malloc_wchar_t_memmove_03_bad() { wchar_t * data; data = NULL; if(5==5) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_03.c", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(5==5) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memmove_43.cpp", "text": "data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memmove_43.cpp", "text": "data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; #ifndef OMITGOOD static void goodG2BSource(char * &data) { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memmove_54e.cpp", "text": "memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; #ifndef OMITGOOD void goodG2BSink_e(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_14.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(globalFive==5) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_14.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(globalFive==5) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_04.c", "text": "void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_04_bad() { wchar_t * data; data = NULL; if(STATIC_CONST_TRUE) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_04.c", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(STATIC_CONST_TRUE) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_53d.cpp", "text": "memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_44.c", "text": "#ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); } } void CWE126_Buffer_Overread__malloc_wchar_t_memmove_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; data = NULL; data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_07.cpp", "text": "static int staticFive = 5; namespace CWE126_Buffer_Overread__new_char_memcpy_07 void bad() { char * data; data = NULL; if(staticFive==5) { data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_07.cpp", "text": "void bad() { char * data; data = NULL; if(staticFive==5) { data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_07.cpp", "text": "static void goodG2B1() { char * data; data = NULL; else { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_72b.cpp", "text": "*/ wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; #ifndef OMITGOOD void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_12.cpp", "text": "data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; else { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_12.cpp", "text": "{ data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; else { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_16.cpp", "text": "data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_16.cpp", "text": "void bad() { char * data; data = NULL; while(1) { data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; static void goodG2B() { char * data; data = NULL; while(1) { data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_03.c", "text": "void CWE126_Buffer_Overread__malloc_char_memcpy_03_bad() { char * data; data = NULL; if(5==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_03.c", "text": "static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B2() { char * data; data = NULL; if(5==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_11.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_11.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_10.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(globalTrue) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_10.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(globalTrue) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67b.c", "text": "* BadSource: Use a small buffer * GoodSource: Use a large buffer * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #include <wchar.h> typedef struct _CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67_structType { wchar_t * structFirst; } CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67_structType; #ifndef OMITBAD void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67b_badSink(CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67b_goodG2BSink(CWE126_Buffer_Overread__malloc_wchar_t_memcpy_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_14.c", "text": "if(globalFive==5) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_14.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_14_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(globalFive==5) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_14.c", "text": "* could be smaller than dest causing buffer overread */ memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(globalFive==5) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memmove_32.c", "text": "wchar_t * data = *dataPtr1; data = dataBadBuffer; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; { wchar_t * data = *dataPtr1; data = dataGoodBuffer; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_18.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_18.cpp", "text": "#include <wchar.h> namespace CWE126_Buffer_Overread__new_wchar_t_memmove_18 void bad() { wchar_t * data; data = NULL; goto source; source: data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B() { wchar_t * data; data = NULL; goto source; source: data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_54e.c", "text": "memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_54e_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_31.c", "text": "wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_31.c", "text": "{ wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataGoodBuffer; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memcpy_01.c", "text": "wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memcpy_01.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_declare_memcpy_01_bad() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataGoodBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memcpy_34.c", "text": "wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memcpy_34.c", "text": "wchar_t * data; CWE126_Buffer_Overread__wchar_t_declare_memcpy_34_unionType myUnion; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; CWE126_Buffer_Overread__wchar_t_declare_memcpy_34_unionType myUnion; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataGoodBuffer; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_34.c", "text": "wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_34.c", "text": "wchar_t * data; CWE126_Buffer_Overread__wchar_t_alloca_memmove_34_unionType myUnion; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; CWE126_Buffer_Overread__wchar_t_alloca_memmove_34_unionType myUnion; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataGoodBuffer; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_61a.cpp", "text": "wchar_t * badSource(wchar_t * data); void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_61a.cpp", "text": "#include <wchar.h> namespace CWE126_Buffer_Overread__new_wchar_t_memmove_61 #ifndef OMITBAD wchar_t * badSource(wchar_t * data); void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; #ifndef OMITGOOD wchar_t * goodG2BSource(wchar_t * data); static void goodG2B() { wchar_t * data; data = NULL; data = goodG2BSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_64b.c", "text": "* @description * CWE: 126 Buffer Over-read * BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_64b_badSink(void * dataVoidPtr) { wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_64b_goodG2BSink(void * dataVoidPtr) { wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memcpy_07.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_declare_memcpy_07_bad() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataGoodBuffer[100-1] = L'\\0'; if(staticFive==5) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memcpy_07.c", "text": "* could be smaller than dest causing buffer overread */ memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataGoodBuffer[100-1] = L'\\0'; if(staticFive==5) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_17.cpp", "text": "void bad() { int i; wchar_t * data; data = NULL; for(i = 0; i < 1; i++) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B() { int h; wchar_t * data; data = NULL; for(h = 0; h < 1; h++) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_18.c", "text": "goto source; source: data = dataBadBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_18.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_18_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; goto source; source: data = dataBadBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; goto source; source: data = dataGoodBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_67b.cpp", "text": "*/ memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; void goodG2BSink(structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_10.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(globalTrue) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_10.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(globalTrue) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE126_Buffer_Overread__new_wchar_t_memmove_04 void bad() { wchar_t * data; data = NULL; if(STATIC_CONST_TRUE) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_04.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(STATIC_CONST_TRUE) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_04.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(STATIC_CONST_TRUE) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE126_Buffer_Overread__new_wchar_t_memmove_05 void bad() { wchar_t * data; data = NULL; if(staticTrue) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_05.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(staticTrue) { data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_05.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(staticTrue) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_68b.c", "text": "memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_68b_goodG2BSink() { wchar_t * data = CWE126_Buffer_Overread__wchar_t_alloca_memmove_68_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_12.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_12.cpp", "text": "{ data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; both branches use the GoodSource */ static void goodG2B() { wchar_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; else { data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_32.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_listen_socket_32_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_72a.cpp", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) using namespace std; namespace CWE126_Buffer_Overread__CWE129_listen_socket_72 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_51a.c", "text": "void CWE126_Buffer_Overread__CWE129_listen_socket_51b_badSink(int data); void CWE126_Buffer_Overread__CWE129_listen_socket_51_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_51a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE126_Buffer_Overread__CWE129_listen_socket_51b_badSink(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_listen_socket_51b_goodG2BSink(int data); data = 7; CWE126_Buffer_Overread__CWE129_listen_socket_51b_goodG2BSink(data); } void CWE126_Buffer_Overread__CWE129_listen_socket_51b_goodB2GSink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memcpy_72b.cpp", "text": "char * data = dataVector[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memcpy_73b.cpp", "text": "char * data = dataList.back(); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_memcpy_05_bad() if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_memcpy_05_bad() if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_memcpy_05_bad() if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); dest[99] = '\\0'; printLine(dest); if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_06.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__char_declare_memcpy_06_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_06.c", "text": "#include <wchar.h> #ifndef OMITBAD void CWE126_Buffer_Overread__char_declare_memcpy_06_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_06.c", "text": "memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataGoodBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_73a.cpp", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) using namespace std; namespace CWE126_Buffer_Overread__CWE129_listen_socket_73 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_16.c", "text": "while(1) { data = dataBadBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_16.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE126_Buffer_Overread__char_declare_memmove_16_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; while(1) { data = dataBadBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; dataGoodBuffer[100-1] = '\\0'; while(1) { data = dataGoodBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_18.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); goto sink; sink: { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_73a.cpp", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking the upper bound * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE126_Buffer_Overread__CWE129_fscanf_73 void bad() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { int data; list<int> dataList; data = -1; data = 7; dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_11.c", "text": "if(globalReturnsTrue()) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_11.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE126_Buffer_Overread__char_declare_memmove_11_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_11.c", "text": "memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataGoodBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_53a.c", "text": "void CWE126_Buffer_Overread__CWE129_fscanf_53b_badSink(int data); void CWE126_Buffer_Overread__CWE129_fscanf_53_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_53a.c", "text": "void CWE126_Buffer_Overread__CWE129_fscanf_53b_badSink(int data); void CWE126_Buffer_Overread__CWE129_fscanf_53_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_53a.c", "text": "void CWE126_Buffer_Overread__CWE129_fscanf_53b_badSink(int data); void CWE126_Buffer_Overread__CWE129_fscanf_53_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE126_Buffer_Overread__CWE129_fscanf_53b_badSink(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_fscanf_53b_goodG2BSink(int data); data = 7; CWE126_Buffer_Overread__CWE129_fscanf_53b_goodG2BSink(data); } void CWE126_Buffer_Overread__CWE129_fscanf_53b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_53a.c", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking the upper bound * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_fscanf_53b_badSink(int data); void CWE126_Buffer_Overread__CWE129_fscanf_53_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE126_Buffer_Overread__CWE129_fscanf_53b_badSink(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_fscanf_53b_goodG2BSink(int data); static void goodG2B() { int data; data = -1; data = 7; CWE126_Buffer_Overread__CWE129_fscanf_53b_goodG2BSink(data); } void CWE126_Buffer_Overread__CWE129_fscanf_53b_goodB2GSink(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_65b.c", "text": "memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__char_declare_memcpy_65b_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_67a.c", "text": "void CWE126_Buffer_Overread__CWE129_fscanf_67b_badSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); void CWE126_Buffer_Overread__CWE129_fscanf_67_bad() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_67a.c", "text": "void CWE126_Buffer_Overread__CWE129_fscanf_67b_badSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); void CWE126_Buffer_Overread__CWE129_fscanf_67_bad() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_67a.c", "text": "#include \"std_testcase.h\" typedef struct _CWE126_Buffer_Overread__CWE129_fscanf_67_structType { int structFirst; } CWE126_Buffer_Overread__CWE129_fscanf_67_structType; #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_fscanf_67b_badSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); void CWE126_Buffer_Overread__CWE129_fscanf_67_bad() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE126_Buffer_Overread__CWE129_fscanf_67b_badSink(myStruct); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_fscanf_67b_goodG2BSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); static void goodG2B() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct; * access an index of the array in the sink that is out-of-bounds */ data = 7; myStruct.structFirst = data; CWE126_Buffer_Overread__CWE129_fscanf_67b_goodG2BSink(myStruct); } void CWE126_Buffer_Overread__CWE129_fscanf_67b_goodB2GSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); static void goodB2G() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_67a.c", "text": "void CWE126_Buffer_Overread__CWE129_fscanf_67b_badSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); void CWE126_Buffer_Overread__CWE129_fscanf_67_bad() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE126_Buffer_Overread__CWE129_fscanf_67b_badSink(myStruct); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_fscanf_67b_goodG2BSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); static void goodG2B() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct; data = -1; data = 7; myStruct.structFirst = data; CWE126_Buffer_Overread__CWE129_fscanf_67b_goodG2BSink(myStruct); } void CWE126_Buffer_Overread__CWE129_fscanf_67b_goodB2GSink(CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct); static void goodB2G() { int data; CWE126_Buffer_Overread__CWE129_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_73b.cpp", "text": "char * data = dataList.back(); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_15.c", "text": "/* * @description * CWE: 126 Buffer Overread #ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_15_bad() /* strncpy() does not null terminate if the string in the src buffer is larger than", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_15.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); printLine(dest); break; default: { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_15.c", "text": "*/ memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); printLine(dest); break; default: { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); dest[99] = '\\0'; printLine(dest); { case 6: { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_33.cpp", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE126_Buffer_Overread__CWE129_listen_socket_33 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_01.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodG2B() { int data; data = -1; data = 7; int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_41.c", "text": "if (data >= 0) { printIntLine(buffer[data]); } } void CWE126_Buffer_Overread__CWE129_fscanf_41_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_41.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(int data) int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodG2B() { int data; data = -1; data = 7; goodG2BSink(data); } static void goodB2GSink(int data) { { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_01.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_listen_socket_01_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_63b.c", "text": "memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__char_declare_memmove_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_68a.c", "text": "void CWE126_Buffer_Overread__CWE129_listen_socket_68b_badSink(); void CWE126_Buffer_Overread__CWE129_listen_socket_68_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_68a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE126_Buffer_Overread__CWE129_listen_socket_68_badData = data; CWE126_Buffer_Overread__CWE129_listen_socket_68b_badSink(); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_listen_socket_68b_goodG2BSink(); void CWE126_Buffer_Overread__CWE129_listen_socket_68b_goodB2GSink(); data = 7; CWE126_Buffer_Overread__CWE129_listen_socket_68_goodG2BData = data; CWE126_Buffer_Overread__CWE129_listen_socket_68b_goodG2BSink(); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_07.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); dest[99] = '\\0'; printLine(dest); if(staticFive==5) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_wchar_t_memcpy_06.c", "text": "wmemset(data, L'A', 149); data[149] = L'\\0'; memcpy(dest, data, 99*sizeof(wchar_t)); printWLine(dest); else { { wchar_t data[150], dest[100]; wmemset(data, L'A', 149); data[149] = L'\\0'; memcpy(dest, data, 99*sizeof(wchar_t)); dest[99] = L'\\0'; printWLine(dest); if(STATIC_CONST_FIVE==5) { { wchar_t data[150], dest[100]; wmemset(data, L'A', 149); data[149] = L'\\0'; memcpy(dest, data, 99*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_45.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE126_Buffer_Overread__CWE129_listen_socket_45_badData; static int CWE126_Buffer_Overread__CWE129_listen_socket_45_goodG2BData; static int CWE126_Buffer_Overread__CWE129_listen_socket_45_goodB2GData; static void badSink() { int data = CWE126_Buffer_Overread__CWE129_listen_socket_45_badData; } } void CWE126_Buffer_Overread__CWE129_listen_socket_45_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_45.c", "text": "inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE126_Buffer_Overread__CWE129_listen_socket_45_badData = data; static void goodG2BSink() { int data = CWE126_Buffer_Overread__CWE129_listen_socket_45_goodG2BData; data = 7; CWE126_Buffer_Overread__CWE129_listen_socket_45_goodG2BData = data; static void goodB2GSink() { int data = CWE126_Buffer_Overread__CWE129_listen_socket_45_goodB2GData; { int buffer[10] = { 0 }; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_09.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); dest[99] = '\\0'; printLine(dest); if(GLOBAL_CONST_TRUE) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_41.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) } } void CWE126_Buffer_Overread__CWE129_listen_socket_41_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_34.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); static void goodG2B() { int data; CWE126_Buffer_Overread__CWE129_fscanf_34_unionType myUnion; static void goodB2G() { int data; CWE126_Buffer_Overread__CWE129_fscanf_34_unionType myUnion;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_34.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodG2B() { int data; CWE126_Buffer_Overread__CWE129_fscanf_34_unionType myUnion; data = -1; data = 7; myUnion.unionFirst = data; { int data = myUnion.unionSecond; int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodB2G() { int data; CWE126_Buffer_Overread__CWE129_fscanf_34_unionType myUnion; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_listen_socket_05_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_10.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); dest[99] = '\\0'; printLine(dest); if(globalTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_18.c", "text": "/* * @description * CWE: 126 Buffer Overread #ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_18_bad() /* strncpy() does not null terminate if the string in the src buffer is larger than", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_18.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); printLine(dest); goto sink; sink: { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_connect_socket_22a.c", "text": "int CWE126_Buffer_Overread__CWE129_connect_socket_22_badGlobal = 0; void CWE126_Buffer_Overread__CWE129_connect_socket_22_badSink(int data); void CWE126_Buffer_Overread__CWE129_connect_socket_22_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_connect_socket_22a.c", "text": "data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE126_Buffer_Overread__CWE129_connect_socket_22_badGlobal = 1; CWE126_Buffer_Overread__CWE129_connect_socket_22_badSink(data); #ifndef OMITGOOD int CWE126_Buffer_Overread__CWE129_connect_socket_22_goodB2G1Global = 0; int CWE126_Buffer_Overread__CWE129_connect_socket_22_goodB2G2Global = 0; int CWE126_Buffer_Overread__CWE129_connect_socket_22_goodG2BGlobal = 0; void CWE126_Buffer_Overread__CWE129_connect_socket_22_goodB2G1Sink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_connect_socket_22a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE126_Buffer_Overread__CWE129_connect_socket_22_goodB2G1Global = 0; CWE126_Buffer_Overread__CWE129_connect_socket_22_goodB2G1Sink(data); } void CWE126_Buffer_Overread__CWE129_connect_socket_22_goodB2G2Sink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_08.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_listen_socket_08_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_66a.c", "text": "void CWE126_Buffer_Overread__CWE129_listen_socket_66b_badSink(int dataArray[]); void CWE126_Buffer_Overread__CWE129_listen_socket_66_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_66a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } dataArray[2] = data; CWE126_Buffer_Overread__CWE129_listen_socket_66b_badSink(dataArray); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_listen_socket_66b_goodG2BSink(int dataArray[]); * access an index of the array in the sink that is out-of-bounds */ data = 7; dataArray[2] = data; CWE126_Buffer_Overread__CWE129_listen_socket_66b_goodG2BSink(dataArray); } void CWE126_Buffer_Overread__CWE129_listen_socket_66b_goodB2GSink(int dataArray[]); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_connect_socket_52a.c", "text": "void CWE126_Buffer_Overread__CWE129_connect_socket_52b_badSink(int data); void CWE126_Buffer_Overread__CWE129_connect_socket_52_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_connect_socket_52a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE126_Buffer_Overread__CWE129_connect_socket_52b_badSink(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__CWE129_connect_socket_52b_goodG2BSink(int data); data = 7; CWE126_Buffer_Overread__CWE129_connect_socket_52b_goodG2BSink(data); } void CWE126_Buffer_Overread__CWE129_connect_socket_52b_goodB2GSink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memcpy_14.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE126_Buffer_Overread__char_alloca_memcpy_14_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; if(globalFive==5) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_06.c", "text": "/* * @description * CWE: 126 Buffer Overread #include <wchar.h> /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized #ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_06_bad() /* strncpy() does not null terminate if the string in the src buffer is larger than", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_06.c", "text": "#include <wchar.h> memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); dest[99] = '\\0'; printLine(dest); if(STATIC_CONST_FIVE==5) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_54e.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_54e_badSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_54e.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_54e_badSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_54e_goodG2BSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_66b.cpp", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; void goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_21.cpp", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void bad() { char * data; data = new char[100]; badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_21.cpp", "text": "{ memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void bad() { char * data; data = new char[100]; badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; data = new char[100]; goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_21.cpp", "text": "{ memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; data = new char[100]; goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B2() { char * data; data = new char[100]; goodG2B2Static = 1; data = goodG2B2Source(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_12.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_12_bad() { int * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_12.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_12_bad() { int * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); * both branches use the GoodSource */ static void goodG2B() { int * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_18.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_18_bad() { int * data; data = NULL; goto source; source: data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_18.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_18_bad() { int * data; data = NULL; goto source; source: data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; data = NULL; goto source; source: data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_83_bad.cpp", "text": "data = new char[50]; data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_83_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_83_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_41.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_41_badSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_41.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_41_badSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_41_bad() { int * data; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_41_goodG2BSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_84_bad.cpp", "text": "data = new char[50]; data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_84_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_10.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: cpy * BadSink : Copy string to data using strcpy void bad() { char * data; data = NULL; if(globalTrue) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_10.cpp", "text": "strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(globalTrue) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_12.cpp", "text": "data = new char[50]; data[0] = '\\0'; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_12.cpp", "text": "{ data = new char[50]; data[0] = '\\0'; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[100]; data[0] = '\\0'; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_16.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; while(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_03.cpp", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(5==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_33.cpp", "text": "data = new char[50]; data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_33.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = new char[50]; data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = new char[100]; data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_64b.cpp", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_02.cpp", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_16.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; while(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_41.cpp", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; void bad() { char * data; data = NULL; data = new char[50]; data[0] = '\\0'; badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_15.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cpy * BadSink : Copy data to string using strcpy void bad() { char * data; data = new char[100]; switch(6) { case 6: memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_15.cpp", "text": "char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; switch(6) { case 6: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_64b.cpp", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_52c.cpp", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_c(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53d.cpp", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_64b.cpp", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_84.h", "text": "/* * @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_72b.cpp", "text": "char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_04.cpp", "text": "#include <wchar.h> data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_04.cpp", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_TRUE) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_10.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { char * data; data = NULL; if(globalTrue) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_10.cpp", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(globalTrue) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_42.cpp", "text": "data = new char[50]; data[0] = '\\0'; return data; void bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_42.cpp", "text": "{ data = new char[50]; data[0] = '\\0'; return data; void bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD static char * goodG2BSource(char * data) { data = new char[100]; data[0] = '\\0'; return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_12.cpp", "text": "data = new char[50]; data[0] = '\\0'; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_12.cpp", "text": "{ data = new char[50]; data[0] = '\\0'; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[100]; data[0] = '\\0'; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_08.cpp", "text": "data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_08.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: ncat * BadSink : Copy string to data using strncat void bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_08.cpp", "text": "strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_52c.cpp", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_c(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = new wchar_t[10]; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = new wchar_t[10]; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = new wchar_t[10+1]; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_11.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_11.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_11.cpp", "text": "data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_13.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_13.cpp", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_41.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; void bad() { char * data; data = NULL; data = new char[50]; data[0] = '\\0'; badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_17.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { int h; char * data; data = NULL; for(h = 0; h < 1; h++) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_45.cpp", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; void bad() { char * data; data = NULL; data = new char[50]; data[0] = '\\0'; badData = data; static void goodG2BSink() { char * data = goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_31.cpp", "text": "data = new char[50]; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_31.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: ncat * BadSink : Copy string to data using strncat * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; data = NULL; data = new char[50]; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; data = new char[100]; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_01.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { wchar_t * data; data = NULL; data = new wchar_t[10]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_01.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { wchar_t * data; data = NULL; data = new wchar_t[10]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; data = NULL; data = new wchar_t[10+1]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_18.cpp", "text": "data = new char[50]; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_18.cpp", "text": "data = new char[50]; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; goto source; source: data = new char[100]; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_02.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { char * data; data = NULL; if(1) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_02.cpp", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(1) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_32.cpp", "text": "data = new char[50]; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_32.cpp", "text": "char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = new char[50]; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = new char[100]; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_51b.cpp", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_32.cpp", "text": "data = new char[50]; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_32.cpp", "text": "data = NULL; { char * data = *dataPtr1; data = new char[50]; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = new char[100]; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_41.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_41.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; void bad() { wchar_t * data; data = NULL; data = new wchar_t[10]; badSink(data); #ifndef OMITGOOD void goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_34.cpp", "text": "data = new char[50]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_34.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[50]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = NULL; data = new char[100]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_74b.cpp", "text": "char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_64b.cpp", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_15.cpp", "text": "data = new char[50]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_15.cpp", "text": "void bad() { char * data; data = NULL; switch(6) { case 6: data = new char[50]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_15.cpp", "text": "static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; switch(6) { case 6: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_17.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { int h; char * data; data = NULL; for(h = 0; h < 1; h++) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_43.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD void badSource(wchar_t * &data) { data = new wchar_t[10]; void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_43.cpp", "text": "* GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD void badSource(wchar_t * &data) { data = new wchar_t[10]; void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; #ifndef OMITGOOD static void goodG2BSource(wchar_t * &data) { data = new wchar_t[10+1]; static void goodG2B() { wchar_t * data; data = NULL; goodG2BSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53d.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_d(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53d.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_d(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_43.cpp", "text": "data = new char[50]; data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_43.cpp", "text": "void badSource(char * &data) { data = new char[50]; data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD static void goodG2BSource(char * &data) { data = new char[100]; data[0] = '\\0'; static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_16.cpp", "text": "data = new char[50]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_16.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: ncat * BadSink : Copy string to data using strncat void bad() { char * data; data = NULL; while(1) { data = new char[50]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; while(1) { data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_73b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #ifndef OMITBAD void badSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_73b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #ifndef OMITBAD void badSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66b.cpp", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; void goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_13.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_13.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_13.cpp", "text": "data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_17.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { int i; wchar_t * data; data = NULL; for(i = 0; i < 1; i++) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_17.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { int i; wchar_t * data; data = NULL; for(i = 0; i < 1; i++) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B() { int h; wchar_t * data; data = NULL; for(h = 0; h < 1; h++) { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_09.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_09.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_09.cpp", "text": "data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_52c.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void badSink_c(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_52c.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void badSink_c(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_c(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_66b.cpp", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_34.cpp", "text": "data = new char[50]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_34.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[50]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = NULL; data = new char[100]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68b.cpp", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68b.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memmove * BadSink : Copy TwoIntsClass array to data using memmove * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" extern TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68_badData; extern TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68_goodG2BData; void badSink() { TwoIntsClass * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68_badData; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; void goodG2BSink() { TwoIntsClass * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68_goodG2BData; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42.cpp", "text": "data = new int64_t[50]; return data; void bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memmove * BadSink : Copy int64_t array to data using memmove * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static int64_t * badSource(int64_t * data) { data = new int64_t[50]; return data; void bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD static int64_t * goodG2BSource(int64_t * data) { data = new int64_t[100]; return data; static void goodG2B() { int64_t * data; data = NULL; data = goodG2BSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_84_bad.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_84_bad() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53d.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memmove * BadSink : Copy TwoIntsClass array to data using memmove * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_d(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_02.cpp", "text": "data = NULL; if(1) { data = new TwoIntsClass[50]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_02.cpp", "text": "static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B2() { TwoIntsClass * data; data = NULL; if(1) { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_17.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void bad() { int i; wchar_t * data; data = NULL; for(i = 0; i < 1; i++) { data = new wchar_t[50]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { int h; wchar_t * data; data = NULL; for(h = 0; h < 1; h++) { data = new wchar_t[100]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_10.cpp", "text": "data = NULL; if(globalTrue) { data = new TwoIntsClass[50]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_10.cpp", "text": "static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B2() { TwoIntsClass * data; data = NULL; if(globalTrue) { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_08.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_08.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { wchar_t * data; data = NULL; if(staticReturnsTrue()) { data = new wchar_t[50]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; } else { data = new wchar_t[100]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_08.cpp", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; } else { data = new wchar_t[100]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(staticReturnsTrue()) { data = new wchar_t[100]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_44.cpp", "text": "static void badSink(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; void bad() { TwoIntsClass * data; void (*funcPtr) (TwoIntsClass *) = badSink; data = NULL; data = new TwoIntsClass[50]; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_12.cpp", "text": "data = new int[50]; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_12.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int array to data using memcpy void bad() { int * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new int[50]; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; both branches use the GoodSource */ static void goodG2B() { int * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new int[100]; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_08.cpp", "text": "if(staticReturnsTrue()) { data = new int64_t[50]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B2() { int64_t * data; data = NULL; if(staticReturnsTrue()) { data = new int64_t[100]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_62a.cpp", "text": "void badSource(TwoIntsClass * &data); void bad() { TwoIntsClass * data; data = NULL; badSource(data); { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_62a.cpp", "text": "#ifndef OMITBAD void badSource(TwoIntsClass * &data); void bad() { TwoIntsClass * data; data = NULL; badSource(data); { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; #ifndef OMITGOOD void goodG2BSource(TwoIntsClass * &data); static void goodG2B() { TwoIntsClass * data; data = NULL; goodG2BSource(data); { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_64b.cpp", "text": "int * * dataPtr = (int * *)dataVoidPtr; int * data = (*dataPtr); { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; { int * * dataPtr = (int * *)dataVoidPtr; int * data = (*dataPtr); { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_32.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_32.cpp", "text": "data = NULL; { wchar_t * data = *dataPtr1; data = new wchar_t[50]; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = NULL; { wchar_t * data = *dataPtr1; data = new wchar_t[100]; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_34.cpp", "text": "data = new int[50]; myUnion.unionFirst = data; { int * data = myUnion.unionSecond; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_34.cpp", "text": "data = new int[50]; myUnion.unionFirst = data; { int * data = myUnion.unionSecond; { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B() { int * data; unionType myUnion; data = NULL; data = new int[100]; myUnion.unionFirst = data; { int * data = myUnion.unionSecond; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_03.cpp", "text": "if(5==5) { data = new int[50]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(5==5) { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_10.cpp", "text": "if(globalTrue) { data = new int[50]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(globalTrue) { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_83_goodG2B.cpp", "text": "data = new wchar_t[100]; data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_83_goodG2B() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_15.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_15.cpp", "text": "void bad() { wchar_t * data; data = NULL; switch(6) { case 6: data = new wchar_t[50]; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new wchar_t[100]; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_15.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new wchar_t[100]; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; switch(6) { case 6: data = new wchar_t[100]; data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_01.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; data = NULL; data = new wchar_t[100]; data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_01.cpp", "text": "data = new int64_t[50]; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B() { int64_t * data; data = NULL; data = new int64_t[100]; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_73b.cpp", "text": "int * data = dataList.back(); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; void goodG2BSink(list<int *> dataList) { int * data = dataList.back(); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68b.cpp", "text": "memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; void goodG2BSink() { int64_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68_goodG2BData; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_06.cpp", "text": "if(STATIC_CONST_FIVE==5) { data = new int[50]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_02.cpp", "text": "if(1) { data = new int[50]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(1) { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_52c.cpp", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; #ifndef OMITGOOD void goodG2BSink_c(int * data) { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_84_goodG2B.cpp", "text": "data = new int64_t[100]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_84_goodG2B() { { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_06.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int64_t array to data using memcpy #include \"std_testcase.h\" data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_06.cpp", "text": "if(STATIC_CONST_FIVE==5) { data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B2() { int64_t * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_04.cpp", "text": "if(STATIC_CONST_TRUE) { data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B2() { int64_t * data; data = NULL; if(STATIC_CONST_TRUE) { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_84_goodG2B.cpp", "text": "data = new TwoIntsClass[100]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_84_goodG2B() { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_84_goodG2B.cpp", "text": "data = new TwoIntsClass[100]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_84_goodG2B() { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_34.cpp", "text": "data = new TwoIntsClass[50]; myUnion.unionFirst = data; { TwoIntsClass * data = myUnion.unionSecond; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_34.cpp", "text": "data = NULL; data = new TwoIntsClass[50]; myUnion.unionFirst = data; { TwoIntsClass * data = myUnion.unionSecond; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B() { TwoIntsClass * data; unionType myUnion; data = NULL; data = new TwoIntsClass[100]; myUnion.unionFirst = data; { TwoIntsClass * data = myUnion.unionSecond; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_84_bad.cpp", "text": "data = new TwoIntsClass[50]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_84_bad() { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_22a.cpp", "text": "int badGlobal = 0; int * badSource(int * data); void bad() { int * data; data = NULL; badGlobal = 1; data = badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_22a.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int array to data using memcpy #ifndef OMITBAD int badGlobal = 0; int * badSource(int * data); void bad() { int * data; data = NULL; badGlobal = 1; data = badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; #ifndef OMITGOOD int * goodG2B1Source(int * data); static void goodG2B1() { int * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_22a.cpp", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; #ifndef OMITGOOD int * goodG2B1Source(int * data); static void goodG2B1() { int * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; ; } int * goodG2B2Source(int * data); static void goodG2B2() { int * data; data = NULL; goodG2B2Global = 1; data = goodG2B2Source(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53d.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy TwoIntsClass array to data using memcpy * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_d(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72b.cpp", "text": "TwoIntsClass * data = dataVector[2]; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72b.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy TwoIntsClass array to data using memcpy * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files #ifndef OMITBAD void badSink(vector<TwoIntsClass *> dataVector) { TwoIntsClass * data = dataVector[2]; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; #ifndef OMITGOOD void goodG2BSink(vector<TwoIntsClass *> dataVector) { TwoIntsClass * data = dataVector[2]; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_63b.cpp", "text": "memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD void goodG2BSink(int64_t * * dataPtr) { int64_t * data = *dataPtr; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_31.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_31.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { wchar_t * data; data = NULL; data = new wchar_t[50]; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; data = NULL; data = new wchar_t[100]; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22a.cpp", "text": "int badGlobal = 0; int64_t * badSource(int64_t * data); void bad() { int64_t * data; data = NULL; badGlobal = 1; data = badSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22a.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int64_t array to data using memcpy #ifndef OMITBAD int badGlobal = 0; int64_t * badSource(int64_t * data); void bad() { int64_t * data; data = NULL; badGlobal = 1; data = badSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD int64_t * goodG2B1Source(int64_t * data); static void goodG2B1() { int64_t * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22a.cpp", "text": "memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD int64_t * goodG2B1Source(int64_t * data); static void goodG2B1() { int64_t * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; ; } int64_t * goodG2B2Source(int64_t * data); static void goodG2B2() { int64_t * data; data = NULL; goodG2B2Global = 1; data = goodG2B2Source(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67b.cpp", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; void goodG2BSink(structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_62a.cpp", "text": "void badSource(int * &data); void bad() { int * data; data = NULL; badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_62a.cpp", "text": "void badSource(int * &data); void bad() { int * data; data = NULL; badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; #ifndef OMITGOOD void goodG2BSource(int * &data); static void goodG2B() { int * data; data = NULL; goodG2BSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_74b.cpp", "text": "char * data = dataMap[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_44.cpp", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void bad() { char * data; void (*funcPtr) (char *) = badSink; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_22a.cpp", "text": "int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = new char[100]; badGlobal = 1; data = badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_22a.cpp", "text": "int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = new char[100]; badGlobal = 1; data = badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; int goodG2B2Global = 0; char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = new char[100]; goodG2B1Global = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_22a.cpp", "text": "data = badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; int goodG2B2Global = 0; char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = new char[100]; goodG2B1Global = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; } char * goodG2B2Source(char * data); static void goodG2B2() { char * data; data = new char[100]; goodG2B2Global = 1; data = goodG2B2Source(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = new char[100]; badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = new char[100]; badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = new char[100]; goodG2BSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_02.cpp", "text": "{ wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = new wchar_t[100]; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = new wchar_t[100]; if(1) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_51b.cpp", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_72b.cpp", "text": "char * data = dataVector[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_67b.cpp", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(structType myStruct) { char * data = myStruct.structFirst; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_01.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_15.cpp", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncpy * BadSink : Copy data to string using strncpy void bad() { char * data; data = new char[100]; switch(6) { case 6: memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_15.cpp", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; switch(6) { case 6: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54e.cpp", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_e(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53d.cpp", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_68b.cpp", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_68_goodG2BData; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_84_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_84_bad() { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_12.cpp", "text": "data = new char[100]; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; both branches use the GoodSource */ static void goodG2B() { char * data; data = new char[100]; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_73b.cpp", "text": "char * data = dataList.back(); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_72b.cpp", "text": "char * data = dataVector[2]; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_66b.cpp", "text": "char * data = dataArray[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_42.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_42.cpp", "text": "#ifndef OMITBAD static char * badSource(char * data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD static char * goodG2BSource(char * data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; return data; static void goodG2B() { char * data; data = new char[100]; data = goodG2BSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_41.cpp", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void bad() { char * data; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_41.cpp", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; void bad() { wchar_t * data; data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; badSink(data); #ifndef OMITGOOD void goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53d.cpp", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_32.cpp", "text": "{ wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = new wchar_t[100]; { wchar_t * data = *dataPtr1; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = new wchar_t[100]; { wchar_t * data = *dataPtr1; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_32.cpp", "text": "{ wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = new wchar_t[100]; { wchar_t * data = *dataPtr1; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = new wchar_t[100]; { wchar_t * data = *dataPtr1; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_32.cpp", "text": "{ char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = new char[100]; { char * data = *dataPtr1; memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = new char[100]; { char * data = *dataPtr1; memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_74b.cpp", "text": "char * data = dataMap[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_34.cpp", "text": "* GoodSource: Initialize data as a small string * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) typedef union { wchar_t * unionFirst; wchar_t * unionSecond; void bad() { wchar_t * data; unionType myUnion; data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; unionType myUnion; data = new wchar_t[100]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = new char[100]; badSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = new char[100]; badSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = new char[100]; goodG2BSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_74b.cpp", "text": "wchar_t * data = dataMap[2]; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(map<int, wchar_t *> dataMap) { wchar_t * data = dataMap[2]; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_09.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_09_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_TRUE) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_09.c", "text": "{ char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_TRUE) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_01.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_01.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_67b.c", "text": "strcpy(dest, data); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_67b_goodG2BSink(CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_14.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_14_bad() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_14.c", "text": "strcpy(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_63b.c", "text": "strcpy(dest, data); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_63b.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_13.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_13_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_FIVE==5) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_13.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_FIVE==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_03.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_03_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(5==5) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_03.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(5==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_13.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_13_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_FIVE==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_13.c", "text": "{ char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_FIVE==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_34.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_34.c", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: cat * BadSink : Copy string to data using strcat * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_34_bad() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_34_unionType myUnion; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_34_unionType myUnion; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_43.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_43.cpp", "text": "* GoodSource: Initialize data as a small string * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(char * &data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2BSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_34.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_34_bad() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_14.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_14_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(globalFive==5) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_14.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(globalFive==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_33.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t * data = dataRef; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t * data = dataRef; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_62a.cpp", "text": "void badSource(wchar_t * &data); void bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_62a.cpp", "text": "void badSource(wchar_t * &data); void bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD void goodG2BSource(wchar_t * &data); static void goodG2B() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} goodG2BSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_53d.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_53d_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_21_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_21.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_21_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_21.c", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2B2Static = 1; data = goodG2B2Source(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_31.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: cat * BadSink : Copy data to string using strcat * Flow Variant: 31 Data flow using a copy of data within the same function void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_31_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_43.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_43.cpp", "text": "* GoodSource: Initialize data as a small string * Sinks: cat * BadSink : Copy data to string using strcat * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(char * &data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2BSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_10.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_10_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(globalTrue) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_10.c", "text": "{ char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(globalTrue) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_03.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: cat * BadSink : Copy string to data using strcat void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_03_bad() { char * data; data = NULL; if(5==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_03.c", "text": "strcat(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(5==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_11.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_11_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(globalReturnsTrue()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_11.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(globalReturnsTrue()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_14.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cpy * BadSink : Copy data to string using strcpy void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_14_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(globalFive==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_14.c", "text": "{ char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(globalFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_83_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_83_bad::~CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_83_bad() { { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_21_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_21.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_21_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_21.c", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2B2Static = 1; data = goodG2B2Source(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_32.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_32.c", "text": "{ char * data = *dataPtr1; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_05.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_05.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(staticTrue) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_53d.c", "text": "strcat(dest, data); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_53d_goodG2BSink(char * data) { { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_12.c", "text": "if(globalReturnsTrueOrFalse()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); * both branches use the GoodSource */ static void goodG2B() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(globalReturnsTrueOrFalse()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_17.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B() { int h; char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} for(h = 0; h < 1; h++) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_41.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_41_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_41_bad() { char * data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_41_badSink(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_41_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_02.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_02_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(1) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_02.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(1) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_01.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_09.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_TRUE) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_09.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_TRUE) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); free(structCharVoid); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_09.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_TRUE) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); free(structCharVoid); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); free(structCharVoid); if(GLOBAL_CONST_TRUE) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_06.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; } charVoid; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); if(STATIC_CONST_FIVE==5) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_31.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; data = NULL; data = new char[10]; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_31.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; data = NULL; data = new char[10]; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; data = new char[10+1]; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_83_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_83_goodG2B::CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_83_goodG2B(char * dataCopy) { data = dataCopy; data = new char[10+1]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_83_goodG2B() { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_18.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; goto source; source: data = new char[10]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_18.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; goto source; source: data = new char[10]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; goto source; source: data = new char[10+1]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_51b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void badSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_51b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void badSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_08.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_08.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_08.cpp", "text": "if(staticReturnsTrue()) { data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_34.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[10]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_34.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[10]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = NULL; data = new char[10+1]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void badSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68_badData; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void badSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68_badData; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68_goodG2BData; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_61b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_61b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_61b.cpp", "text": "fscanf(stdin, \"%d\", &data); return data; #ifndef OMITGOOD int goodG2BSource(int data) { data = 7; return data; } int goodB2GSource(int data) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45.cpp", "text": "data = -1; fscanf(stdin, \"%d\", &data); badData = data; static void goodG2BSink() { int data = goodG2BData; } if (data >= 0) { buffer[data] = 1; static void goodG2B() { int data; data = -1; data = 7; goodG2BData = data; static void goodB2GSink() { int data = goodB2GData; buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_08.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_08.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_08.cpp", "text": "data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_34.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[10]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_34.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[10]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = NULL; data = new char[10+1]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_82_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 82 Data flow: data passed in a parameter to a virtual method called via a pointer namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_82 { void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_82_goodG2B::action(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_04.c", "text": "} charVoid; printLine((char *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); free(structCharVoid); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); free(structCharVoid); if(STATIC_CONST_TRUE) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_11.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(globalReturnsTrue()) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_11.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(globalReturnsTrue()) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_11.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(globalReturnsTrue()) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); if(globalReturnsTrue()) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_12.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[10]; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_12.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[10]; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); delete [] data; both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[10+1]; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void bad() { char * data; void (*funcPtr) (char *) = badSink; data = NULL; data = new char[10]; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_05.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_05.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_05.c", "text": "typedef struct _charVoid { char charFirst[16]; if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); if(staticTrue) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_18.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_18.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_18.cpp", "text": "data = -1; goto source; source: fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G() { int data; data = -1; goto source; source: fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67a.cpp", "text": "data = -1; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; static void goodG2B() { int data; structType myStruct; data = -1; data = 7; myStruct.structFirst = data; static void goodB2G() { int data; structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52a.cpp", "text": "#include \"std_testcase.h\" namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52 #ifndef OMITBAD void badSink_b(int data); void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(int data); static void goodG2B() { int data; data = -1; data = 7; goodG2BSink_b(data); } void goodB2GSink_b(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53d.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53d.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_03.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_03.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_03.cpp", "text": "data = -1; if(5==5) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(5==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_03.cpp", "text": "void bad() { int data; data = -1; if(5==5) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(5==5) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(5==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_10.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_10.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_10.cpp", "text": "data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_10.cpp", "text": "void bad() { int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04 void bad() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04 data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04 void bad() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04 data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04.cpp", "text": "void bad() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_74b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_74b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_72b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_72b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); delete [] data; void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_07.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() #define SRC_STRING \"AAAAAAAAAA\" data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_07.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() #define SRC_STRING \"AAAAAAAAAA\" data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_07.cpp", "text": "if(staticFive==5) { data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_11.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; if(globalReturnsTrue()) { data = new char[10]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_11.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; if(globalReturnsTrue()) { data = new char[10]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_11.cpp", "text": "data = new char[10]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(globalReturnsTrue()) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_12.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[10]; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_12.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[10]; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new char[10+1]; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_63b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_63b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_07.c", "text": "typedef struct _charVoid { char charFirst[16]; } charVoid; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); if(staticFive==5) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_17.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_17.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B() { int h; char * data; data = NULL; for(h = 0; h < 1; h++) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_72b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_72b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_82.h", "text": "/* * @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * BadSink : Copy array to data using memmove()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_43.cpp", "text": "#ifndef OMITBAD static void badSource(void * &data) if (dataBadBuffer == NULL) {exit(-1);} wmemset(dataBadBuffer, L'A', 50-1); dataBadBuffer[50-1] = L'\\0'; data = (void *)dataBadBuffer; void bad() { void * data; data = NULL; badSource(data); { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy((wchar_t *)dest, (wchar_t *)data); printLine((char *)dest); free(dest); #ifndef OMITGOOD static void goodG2BSource(void * &data) if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; static void goodG2B() { void * data; data = NULL; goodG2BSource(data); { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy((char *)dest, (char *)data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66a.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_badSink(int dataArray[]); void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66a.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_badSink(int dataArray[]); void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66_bad() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66a.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_badSink(int dataArray[]); void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66_bad() int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_badSink(dataArray); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_goodG2BSink(int dataArray[]); * access an index of the array in the sink that is out-of-bounds */ data = 7; dataArray[2] = data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_goodG2BSink(dataArray); } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_goodB2GSink(int dataArray[]);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66a.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66_bad() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_badSink(dataArray); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_goodG2BSink(int dataArray[]); static void goodG2B() { int data; int dataArray[5]; data = -1; data = 7; dataArray[2] = data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_goodG2BSink(dataArray); } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_66b_goodB2GSink(int dataArray[]); static void goodB2G() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_06.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() #include \"std_testcase.h\" void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_06.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() #include \"std_testcase.h\" void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_06.c", "text": "{ data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_09.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_04.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() #define SRC_STRING \"AAAAAAAAAA\" data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_04.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() #define SRC_STRING \"AAAAAAAAAA\" data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_04.c", "text": "{ data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_TRUE) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61a.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61b_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61_bad() { char * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61b_badSource(data); { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61a.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61b_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61_bad() { char * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61b_badSource(data); { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); #ifndef OMITGOOD char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61b_goodG2BSource(char * data); static void goodG2B() { char * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_61b_goodG2BSource(data); { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_83_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_83_goodG2B::CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_83_goodG2B(char * dataCopy) { data = dataCopy; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_83_goodG2B() { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_01_bad() { int * data; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_01_bad() { int * data; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; data = NULL; data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_31.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__CWE135_31_bad() { void * data; data = NULL; if (dataBadBuffer == NULL) {exit(-1);} wmemset(dataBadBuffer, L'A', 50-1); dataBadBuffer[50-1] = L'\\0'; data = (void *)dataBadBuffer; } { void * dataCopy = data; void * data = dataCopy; { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printLine((char *)dest); free(dest); static void goodG2B() { void * data; data = NULL; if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; } { void * dataCopy = data; void * data = dataCopy; { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_65b.c", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE135_65b_badSink(void * data) { { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printLine((char *)dest); free(dest); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__CWE135_65b_goodG2BSink(void * data) { { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_04.c", "text": "data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_04.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_63b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_63b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_15.c", "text": "void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printWLine((wchar_t *)dest); free(dest); static void goodB2G2() { void * data; data = NULL; if (dataBadBuffer == NULL) {exit(-1);} wmemset(dataBadBuffer, L'A', 50-1); dataBadBuffer[50-1] = L'\\0'; data = (void *)dataBadBuffer; case 7: { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printWLine((wchar_t *)dest); free(dest); static void goodG2B1() { void * data; data = NULL; if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; case 7: { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_15.c", "text": "void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printWLine((wchar_t *)dest); free(dest); static void goodG2B1() { void * data; data = NULL; if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; case 7: { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data); printLine((char *)dest); free(dest); static void goodG2B2() { void * data; data = NULL; if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; case 7: { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_03.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_03_bad() { char * data; data = NULL; if(5==5) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_03.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_03_bad() { char * data; data = NULL; if(5==5) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_03.c", "text": "{ char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(5==5) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_16.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_16_bad() { char * data; data = NULL; while(1) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_16.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_16_bad() { char * data; data = NULL; while(1) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); static void goodG2B() { char * data; data = NULL; while(1) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_14.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_14_bad() { int * data; data = NULL; if(globalFive==5) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_14.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_14_bad() { int * data; data = NULL; if(globalFive==5) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_14.c", "text": "{ data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(globalFive==5) { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67b_goodG2BSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_81_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_81 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_81_bad::action(char * data) const { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c", "text": "#ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05_bad()", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c", "text": "#ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05_bad() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c", "text": "#ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05_bad() data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c", "text": "#ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05_bad() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c", "text": "#ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05_bad() data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_05_bad() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_54e.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_54e_badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_54e.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_54e_badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_54e_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_03.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_03_bad() { int * data; data = NULL; if(5==5) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_03.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_03_bad() { int * data; data = NULL; if(5==5) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_03.c", "text": "{ data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(5==5) { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char * data = dataRef; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char * data = dataRef; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} { char * data = dataRef; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_44.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_44_bad() { char * data; void (*funcPtr) (char *) = badSink; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_33.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { int * data; int * &dataRef = data; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int * data = dataRef; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_33.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { int * data; int * &dataRef = data; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int * data = dataRef; { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; int * &dataRef = data; data = NULL; data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} { int * data = dataRef; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_41.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_41_badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_41.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_41_badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_41_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_41_badSink(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_41_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_17.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_17_bad() { int i; int * data; data = NULL; for(i = 0; i < 1; i++) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_17.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_17_bad() { int i; int * data; data = NULL; for(i = 0; i < 1; i++) { data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int h; int * data; data = NULL; for(h = 0; h < 1; h++) { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_62a.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(int * &data); void bad() { int * data; data = NULL; badSource(data); { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_62a.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(int * &data); void bad() { int * data; data = NULL; badSource(data); { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void goodG2BSource(int * &data); static void goodG2B() { int * data; data = NULL; goodG2BSource(data); { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_31.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_31_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_31.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_31_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_53d.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_53d_badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_53d.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_53d_badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_53d_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_42.c", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_42_bad() { twoIntsStruct * data; data = NULL; data = badSource(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_42.c", "text": "data = NULL; data = badSource(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD static twoIntsStruct * goodG2BSource(twoIntsStruct * data) { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} return data; static void goodG2B() { twoIntsStruct * data; data = NULL; data = goodG2BSource(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_05.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_05.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int array to data using memcpy data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_05.c", "text": "if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(staticTrue) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_02.c", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_02.c", "text": "else { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); static void goodG2B2() { twoIntsStruct * data; data = NULL; if(1) { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_01.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_01.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; data = NULL; data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_08.c", "text": "else { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); static void goodG2B2() { twoIntsStruct * data; data = NULL; if(staticReturnsTrue()) { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_84_goodG2B.cpp", "text": "data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_84_goodG2B() { { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_15.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_15.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy int array to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_15_bad() { int * data; data = NULL; switch(6) { case 6: data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_15.c", "text": "int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; switch(6) { case 6: data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_43.cpp", "text": "data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} void bad() { int64_t * data; data = NULL; badSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_43.cpp", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy int64_t array to data using memcpy * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(int64_t * &data) { data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} void bad() { int64_t * data; data = NULL; badSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); #ifndef OMITGOOD static void goodG2BSource(int64_t * &data) { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} static void goodG2B() { int64_t * data; data = NULL; goodG2BSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_bad.cpp", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_84_bad() { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61a.c", "text": "wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61b_badSource(wchar_t * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61_bad() { wchar_t * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61b_badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61a.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61b_badSource(wchar_t * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61_bad() { wchar_t * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61b_badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61b_goodG2BSource(wchar_t * data); static void goodG2B() { wchar_t * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_61b_goodG2BSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_66b.c", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_66b_badSink(twoIntsStruct * dataArray[]) { twoIntsStruct * data = dataArray[2]; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_66b_goodG2BSink(twoIntsStruct * dataArray[]) { twoIntsStruct * data = dataArray[2]; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_21.c", "text": "static int badStatic = 0; static twoIntsStruct * badSource(twoIntsStruct * data) { if(badStatic) { data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_21_bad() { twoIntsStruct * data; data = NULL; badStatic = 1; data = badSource(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_21.c", "text": "source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD static int goodG2B2Static = 0; static twoIntsStruct * goodG2B1Source(twoIntsStruct * data) } else { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } return data; static void goodG2B1() { twoIntsStruct * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_21.c", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); } } static twoIntsStruct * goodG2B2Source(twoIntsStruct * data) { if(goodG2B2Static) { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } return data; static void goodG2B2() { twoIntsStruct * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_18.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; data = NULL; goto source; source: data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_16.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_16_bad() { wchar_t * data; data = NULL; while(1) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B() { wchar_t * data; data = NULL; while(1) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_72b.cpp", "text": "int64_t * data = dataVector[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); #ifndef OMITGOOD void goodG2BSink(vector<int64_t *> dataVector) { int64_t * data = dataVector[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_12.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_12.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_12_bad() { int * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); * both branches use the GoodSource */ static void goodG2B() { int * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_51b.c", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_51b_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_54e.c", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_54e_goodG2BSink(int * data) { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_84_bad.cpp", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_84_bad() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_52c.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_52c_badSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_52c_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_44.c", "text": "static void badSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_44_bad() { twoIntsStruct * data; void (*funcPtr) (twoIntsStruct *) = badSink; data = NULL; data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_84_bad.cpp", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_84_bad() { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_32.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} *dataPtr1 = data; } { int * data = *dataPtr2; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_32.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_32_bad() { int * data; int * *dataPtr1 = &data; int * *dataPtr2 = &data; data = NULL; { int * data = *dataPtr1; data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} *dataPtr1 = data; } { int * data = *dataPtr2; { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; int * *dataPtr1 = &data; int * *dataPtr2 = &data; data = NULL; { int * data = *dataPtr1; data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} *dataPtr1 = data; } { int * data = *dataPtr2; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_42.c", "text": "data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_42_bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_42.c", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int64_t array to data using memcpy * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static int64_t * badSource(int64_t * data) { data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_42_bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); #ifndef OMITGOOD static int64_t * goodG2BSource(int64_t * data) { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} return data; static void goodG2B() { int64_t * data; data = NULL; data = goodG2BSource(data); { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_13.c", "text": "if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_34.c", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_34.c", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); static void goodG2B() { twoIntsStruct * data; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_34_unionType myUnion; data = NULL; data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_84_goodG2B.cpp", "text": "data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_84_goodG2B() { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_21.c", "text": "static int badStatic = 0; static int * badSource(int * data) { if(badStatic) { data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_21_bad() { int * data; data = NULL; badStatic = 1; data = badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_21.c", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_21_bad() { int * data; data = NULL; badStatic = 1; data = badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD static int goodG2B2Static = 0; static int * goodG2B1Source(int * data) } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } return data; static void goodG2B1() { int * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_21.c", "text": "data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } return data; static void goodG2B1() { int * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); } } static int * goodG2B2Source(int * data) { if(goodG2B2Static) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } return data; static void goodG2B2() { int * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_43.cpp", "text": "data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} void bad() { int * data; data = NULL; badSource(data); { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_43.cpp", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memmove * BadSink : Copy int array to data using memmove * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(int * &data) { data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} void bad() { int * data; data = NULL; badSource(data); { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD static void goodG2BSource(int * &data) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} static void goodG2B() { int * data; data = NULL; goodG2BSource(data); { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_51b.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_51b_goodG2BSink(int * data) { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_10.c", "text": "if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(globalTrue) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_84_bad.cpp", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_84_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_84_bad() { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_12.c", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } else { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_12.c", "text": "if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); * both branches use the GoodSource */ static void goodG2B() { twoIntsStruct * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } else { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61a.c", "text": "twoIntsStruct * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61b_badSource(twoIntsStruct * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61_bad() { twoIntsStruct * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61b_badSource(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61a.c", "text": "#ifndef OMITBAD twoIntsStruct * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61b_badSource(twoIntsStruct * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61_bad() { twoIntsStruct * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61b_badSource(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD twoIntsStruct * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61b_goodG2BSource(twoIntsStruct * data); static void goodG2B() { twoIntsStruct * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_61b_goodG2BSource(data); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_44.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_44_bad() { int * data; void (*funcPtr) (int *) = badSink; data = NULL; data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int * data) { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_01.c", "text": "data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); static void goodG2B() { int64_t * data; data = NULL; data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_17.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_17_bad() { int i; char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} for(i = 0; i < 1; i++) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { int h; char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} for(h = 0; h < 1; h++) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_06.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_06_bad() { wchar_t * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_06.c", "text": "#include <wchar.h> void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_06_bad() { wchar_t * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_06.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_02.c", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_02.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_02_bad() { wchar_t * data; data = NULL; if(1) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_02.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(1) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22a.c", "text": "int CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badGlobal = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badSource(wchar_t * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22a.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy int CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badGlobal = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badSource(wchar_t * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); int CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B2Global = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22a.c", "text": "wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); int CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B2Global = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); } wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B2Source(wchar_t * data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B2Global = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_22_goodG2B2Source(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_67b.c", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_67b_goodG2BSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_73b.cpp", "text": "char * data = dataList.back(); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_83_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_83_goodG2B() { { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_05.c", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_05.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(staticTrue) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_12.c", "text": "if(globalReturnsTrueOrFalse()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); * both branches use the GoodSource */ static void goodG2B() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(globalReturnsTrueOrFalse()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_42.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_42_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data = badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_42.c", "text": "static wchar_t * badSource(wchar_t * data) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_42_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data = badSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD static wchar_t * goodG2BSource(wchar_t * data) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; return data; static void goodG2B() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data = goodG2BSource(data); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_08.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_08_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(staticReturnsTrue()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_08.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(staticReturnsTrue()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_53d.c", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_53d_goodG2BSink(char * data) { { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_33.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: ncat * BadSink : Copy data to string using strncat * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; char * &dataRef = data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_34.c", "text": "* GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_34_bad() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_65b.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_65b_goodG2BSink(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2BSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_32.c", "text": "wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} { wchar_t * data = *dataPtr1; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} { wchar_t * data = *dataPtr1; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_03.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncat * BadSink : Copy data to string using strncat void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_03_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(5==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_03.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(5==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_51b.c", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_51b_goodG2BSink(char * data) { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_41.c", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_41_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_41_badSink(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_41_goodG2BSink(char * data) { { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_07.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(staticFive==5) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_54e.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_54e_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_44.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: ncat * BadSink : Copy data to string using strncat * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_44_bad() { char * data; void (*funcPtr) (char *) = badSink; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_54e.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_54e_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_01.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_31.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: ncat * BadSink : Copy data to string using strncat * Flow Variant: 31 Data flow using a copy of data within the same function void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_31_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_33.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; char * &dataRef = data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_72b.cpp", "text": "char * data = dataVector[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_84_bad.cpp", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_84_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_84_bad() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_72b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_65b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_65b_badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_65b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_65b_badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_65b_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_67b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_67b_goodG2BSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_43.cpp", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_43.cpp", "text": "static void badSource(char * &data) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_63b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_04.c", "text": "#include <wchar.h> data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_04.c", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_TRUE) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45_badData; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45_badData; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45_badData = data; static void goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_45_goodG2BData; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_62a.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(wchar_t * &data); void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); #ifndef OMITGOOD void goodG2BSource(wchar_t * &data); static void goodG2B() { wchar_t * data; data = NULL; goodG2BSource(data); { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_01.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_01_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_01.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_01_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_02.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_02_bad() { wchar_t * data; data = NULL; if(1) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_02.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_02_bad() { wchar_t * data; data = NULL; if(1) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_02.c", "text": "{ wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(1) { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_05.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_05.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_05.c", "text": "{ char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(staticTrue) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_82_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_82 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_82_bad::action(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_07.c", "text": "memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_13.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_13_bad() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_13.c", "text": "memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_64b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_68b.c", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_68b_goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_21.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() #ifndef OMITBAD static int badStatic = 0; static char * badSource(char * data) if(badStatic) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_21_bad() { char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_21.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_21_bad() { char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); #ifndef OMITGOOD static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } return data; static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_21.c", "text": "data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } return data; static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); } } static char * goodG2B2Source(char * data) if(goodG2B2Static) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } return data; static void goodG2B2() { char * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_81_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_81 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_81_bad::action(char * data) const { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_12.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_12.c", "text": "else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); * both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_13.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_13_bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_13.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_13_bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_13.c", "text": "{ wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_goodG2B::CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_goodG2B(char * dataCopy) { data = dataCopy; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_goodG2B() { { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_10.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_10_bad() { char * data; data = NULL; if(globalTrue) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_10.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_10_bad() { char * data; data = NULL; if(globalTrue) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_10.c", "text": "{ char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(globalTrue) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_16.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_16_bad() { char * data; data = NULL; while(1) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = NULL; while(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_52c.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_52c_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_07.c", "text": "{ char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_62a.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_72b.cpp", "text": "char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_74b.cpp", "text": "char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_13.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_13_bad() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_13.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_13_bad() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_13.c", "text": "{ char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_06.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_06_bad() { char * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_06.c", "text": "#include <wchar.h> void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_06_bad() { char * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_06.c", "text": "strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char * data = dataRef; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char * data = dataRef; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} { char * data = dataRef; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_51b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_51b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_54e.c", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: malloc Allocate data using malloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE690_NULL_Deref_From_Return__char_malloc_54e_badSink(char * data) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_54e.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); #ifndef OMITGOOD void CWE690_NULL_Deref_From_Return__char_malloc_54e_goodB2GSink(char * data) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_51b.c", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: realloc Allocate data using realloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE690_NULL_Deref_From_Return__char_realloc_51b_badSink(char * data) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_51b.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); #ifndef OMITGOOD void CWE690_NULL_Deref_From_Return__char_realloc_51b_goodB2GSink(char * data) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_31.c", "text": "data = (char *)realloc(data, 20*sizeof(char)); { char * dataCopy = data; char * data = dataCopy; strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_31.c", "text": "data = (char *)realloc(data, 20*sizeof(char)); { char * dataCopy = data; char * data = dataCopy; strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); { char * dataCopy = data; char * data = dataCopy; if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_11.c", "text": "data = (char *)malloc(20*sizeof(char)); if(globalReturnsTrue()) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_11.c", "text": "* BadSource: malloc Allocate data using malloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_malloc_11_bad() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); if(globalReturnsTrue()) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); if(globalReturnsTrue()) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_34.c", "text": "data = (char *)malloc(20*sizeof(char)); myUnion.unionFirst = data; { char * data = myUnion.unionSecond; strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_34.c", "text": "data = (char *)malloc(20*sizeof(char)); myUnion.unionFirst = data; { char * data = myUnion.unionSecond; strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G() { char * data; CWE690_NULL_Deref_From_Return__char_malloc_34_unionType myUnion; data = NULL; data = (char *)malloc(20*sizeof(char)); myUnion.unionFirst = data; { char * data = myUnion.unionSecond; if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_81_bad.cpp", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: realloc Allocate data using realloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE690_NULL_Deref_From_Return__char_realloc_81 { void CWE690_NULL_Deref_From_Return__char_realloc_81_bad::action(char * data) const strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_84_goodB2G.cpp", "text": "data = (char *)calloc(20, sizeof(char)); CWE690_NULL_Deref_From_Return__char_calloc_84_goodB2G::~CWE690_NULL_Deref_From_Return__char_calloc_84_goodB2G() { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_03.c", "text": "data = (char *)calloc(20, sizeof(char)); if(5==5) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_03.c", "text": "* BadSource: calloc Allocate data using calloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_calloc_03_bad() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(5==5) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(5==5) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); strcpy(data, \"Initialize\"); printLine(data); free(data); #ifndef OMITGOOD void goodB2GSource(char * &data); static void goodB2G() { char * data; data = NULL; goodB2GSource(data); if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_81_bad.cpp", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: malloc Allocate data using malloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE690_NULL_Deref_From_Return__char_malloc_81 { void CWE690_NULL_Deref_From_Return__char_malloc_81_bad::action(char * data) const strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_66b.c", "text": "char * data = dataArray[2]; strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_66b.c", "text": "char * data = dataArray[2]; strcpy(data, \"Initialize\"); printLine(data); free(data); void CWE690_NULL_Deref_From_Return__char_calloc_66b_goodB2GSink(char * dataArray[]) { char * data = dataArray[2]; if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_18.c", "text": "data = (char *)malloc(20*sizeof(char)); goto sink; sink: strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); goto sink; sink: if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_02.c", "text": "data = (char *)realloc(data, 20*sizeof(char)); if(1) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_02.c", "text": "* BadSource: realloc Allocate data using realloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_realloc_02_bad() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); if(1) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); if(1) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_08.c", "text": "data = (char *)calloc(20, sizeof(char)); if(staticReturnsTrue()) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_08.c", "text": "* BadSource: calloc Allocate data using calloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_calloc_08_bad() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(staticReturnsTrue()) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(staticReturnsTrue()) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_12.c", "text": "data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrueOrFalse()) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_12.c", "text": "data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrueOrFalse()) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); both branches use the GoodSink */ static void goodB2G() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrueOrFalse()) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_12.c", "text": "void CWE690_NULL_Deref_From_Return__char_calloc_12_bad() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrueOrFalse()) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); both branches use the GoodSink */ static void goodB2G() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrueOrFalse()) { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_32.c", "text": "{ char * data = *dataPtr1; data = (char *)malloc(20*sizeof(char)); *dataPtr1 = data; } { char * data = *dataPtr2; strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_32.c", "text": "* BadSource: malloc Allocate data using malloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_malloc_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)malloc(20*sizeof(char)); *dataPtr1 = data; } { char * data = *dataPtr2; strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)malloc(20*sizeof(char)); *dataPtr1 = data; } { char * data = *dataPtr2; if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_68b.c", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: realloc Allocate data using realloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE690_NULL_Deref_From_Return__char_realloc_68b_badSink() { char * data = CWE690_NULL_Deref_From_Return__char_realloc_68_badDataForBadSink; strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_68b.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); void CWE690_NULL_Deref_From_Return__char_realloc_68b_goodB2GSink() { char * data = CWE690_NULL_Deref_From_Return__char_realloc_68_badDataForGoodSink; if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_22b.c", "text": "extern int CWE690_NULL_Deref_From_Return__char_malloc_22_badGlobal; void CWE690_NULL_Deref_From_Return__char_malloc_22_badSink(char * data) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_22b.c", "text": "extern int CWE690_NULL_Deref_From_Return__char_malloc_22_badGlobal; void CWE690_NULL_Deref_From_Return__char_malloc_22_badSink(char * data) if(CWE690_NULL_Deref_From_Return__char_malloc_22_badGlobal) { strcpy(data, \"Initialize\"); printLine(data); free(data); extern int CWE690_NULL_Deref_From_Return__char_malloc_22_goodB2G2Global; void CWE690_NULL_Deref_From_Return__char_malloc_22_goodB2G1Sink(char * data) else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_22b.c", "text": "extern int CWE690_NULL_Deref_From_Return__char_malloc_22_badGlobal; void CWE690_NULL_Deref_From_Return__char_malloc_22_badSink(char * data) if(CWE690_NULL_Deref_From_Return__char_malloc_22_badGlobal) { strcpy(data, \"Initialize\"); printLine(data); free(data); extern int CWE690_NULL_Deref_From_Return__char_malloc_22_goodB2G2Global; void CWE690_NULL_Deref_From_Return__char_malloc_22_goodB2G1Sink(char * data) else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); } void CWE690_NULL_Deref_From_Return__char_malloc_22_goodB2G2Sink(char * data) if(CWE690_NULL_Deref_From_Return__char_malloc_22_goodB2G2Global) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_12.c", "text": "data = (char *)realloc(data, 20*sizeof(char)); if(globalReturnsTrueOrFalse()) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_12.c", "text": "data = (char *)realloc(data, 20*sizeof(char)); if(globalReturnsTrueOrFalse()) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); both branches use the GoodSink */ static void goodB2G() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); if(globalReturnsTrueOrFalse()) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_12.c", "text": "void CWE690_NULL_Deref_From_Return__char_realloc_12_bad() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); if(globalReturnsTrueOrFalse()) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); both branches use the GoodSink */ static void goodB2G() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); if(globalReturnsTrueOrFalse()) { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_45.c", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: realloc Allocate data using realloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE690_NULL_Deref_From_Return__char_realloc_45_badData; strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_45.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); void CWE690_NULL_Deref_From_Return__char_realloc_45_bad() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); CWE690_NULL_Deref_From_Return__char_realloc_45_badData = data; static void goodB2GSink() { char * data = CWE690_NULL_Deref_From_Return__char_realloc_45_goodB2GData; if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_44.c", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: malloc Allocate data using malloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_44.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); void CWE690_NULL_Deref_From_Return__char_malloc_44_bad() { char * data; void (*funcPtr) (char *) = badSink; data = NULL; data = (char *)malloc(20*sizeof(char)); funcPtr(data); #ifndef OMITGOOD static void goodB2GSink(char * data) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_41.c", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: realloc Allocate data using realloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD static void badSink(char * data) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_41.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); void CWE690_NULL_Deref_From_Return__char_realloc_41_bad() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); badSink(data); #ifndef OMITGOOD static void goodB2GSink(char * data) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_11.c", "text": "data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrue()) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_11.c", "text": "* BadSource: calloc Allocate data using calloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_calloc_11_bad() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrue()) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); if(globalReturnsTrue()) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_51a.c", "text": "void CWE90_LDAP_Injection__w32_char_console_51_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE90_LDAP_Injection__w32_char_console_51b_badSink(data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_console_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_68a.c", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE90_LDAP_Injection__w32_char_file_68_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE90_LDAP_Injection__w32_char_file_68_badData = data; static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_05.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_05.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_05.c", "text": "{ char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B2() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_11.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_11_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_11.c", "text": "{ char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B2() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_listen_socket_74a.cpp", "text": "void badSink(map<int, wchar_t *> dataMap); void bad() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[256] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_16.c", "text": "{ char * data; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_62b.cpp", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_connect_socket_44.c", "text": "#ifndef OMITBAD static void badSink(wchar_t * data) ULONG connectSuccess = 0L; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; wchar_t filter[256]; _snwprintf(filter, 256-1, L\"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_wchar_t_connect_socket_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[256] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_66a.c", "text": "char * data; char * dataArray[5]; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_34.c", "text": "* GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE90_LDAP_Injection__w32_char_file_34_bad() { char * data; CWE90_LDAP_Injection__w32_char_file_34_unionType myUnion; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; CWE90_LDAP_Injection__w32_char_file_34_unionType myUnion; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_char_connect_socket_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_44.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_02.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_02_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_02.c", "text": "{ char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B2() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_12.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_12_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_12.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_12_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_12.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_12_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"Doe, XXXXX\"); strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_16.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_16_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_72a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_66a.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_66_bad() { char * data; char * dataArray[5]; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_43.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; badSource(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_listen_socket_41.c", "text": "_snwprintf(filter, 256-1, L\"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_wchar_t_listen_socket_41_bad() { wchar_t * data; wchar_t dataBuffer[256] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE90_LDAP_Injection__w32_char_file_21_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_21.c", "text": "void CWE90_LDAP_Injection__w32_char_file_21_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) else { strcat(data, \"Doe, XXXXX\"); } return data; static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); } static char * goodG2B2Source(char * data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_73a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_33.cpp", "text": "* GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * &dataRef = data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); } } { char * data = dataRef; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_21.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); } } } return data; void CWE90_LDAP_Injection__w32_char_environment_21_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_21.c", "text": "void CWE90_LDAP_Injection__w32_char_environment_21_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) else { strcat(data, \"Doe, XXXXX\"); } return data; static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); } static char * goodG2B2Source(char * data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_62b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_connect_socket_34.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) typedef union { wchar_t * unionFirst; wchar_t * unionSecond; void CWE90_LDAP_Injection__w32_wchar_t_connect_socket_34_bad() { wchar_t * data; CWE90_LDAP_Injection__w32_wchar_t_connect_socket_34_unionType myUnion; wchar_t dataBuffer[256] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_listen_socket_06.c", "text": "void CWE90_LDAP_Injection__w32_wchar_t_listen_socket_06_bad() { wchar_t * data; wchar_t dataBuffer[256] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_74a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; map<int, char *> dataMap; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_44.c", "text": "_snprintf(filter, 256-1, \"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_char_environment_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_44.c", "text": "LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_char_environment_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_63a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE90_LDAP_Injection__w32_char_connect_socket_63b_badSink(&data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_connect_socket_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_listen_socket_54a.c", "text": "void CWE90_LDAP_Injection__w32_wchar_t_listen_socket_54b_badSink(wchar_t * data); void CWE90_LDAP_Injection__w32_wchar_t_listen_socket_54_bad() { wchar_t * data; wchar_t dataBuffer[256] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE244_Heap_Inspection/CWE244_Heap_Inspection__w32_char_realloc_16.c", "text": "* CWE: 244 Failure to Clear Heap Before Release (Heap Inspection) * Sinks: realloc * GoodSink: Clear the password buffer before reallocating it * BadSink : Reallocate buffer containing password without first clearing the buffer while(1) { { char * password = (char *)malloc(100*sizeof(char)); if (password == NULL) {exit(-1);} HANDLE hUser; char * username = \"User\"; char * domain = \"Domain\"; password[0] = '\\0'; if (fgets(password, 100, stdin) == NULL) { printLine(\"fgets() failed\"); password[0] = '\\0'; } passwordLen = strlen(password); if (passwordLen > 0) { password[passwordLen-1] = '\\0'; } if (LogonUserA( username, domain, password, { printLine(\"Unable to login.\"); } password = realloc(password, 200 * sizeof(char)); if (password == NULL) {exit(-1);} SecureZeroMemory(password, 200 * sizeof(char)); strcpy(password, \"Nothing to see here\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE244_Heap_Inspection/CWE244_Heap_Inspection__w32_char_realloc_16.c", "text": "SecureZeroMemory(password, 200 * sizeof(char)); strcpy(password, \"Nothing to see here\"); printLine(password); free(password); while(1) { { char * password = (char *)malloc(100*sizeof(char)); if (password == NULL) {exit(-1);} HANDLE hUser; char * username = \"User\"; char * domain = \"Domain\"; password[0] = '\\0'; if (fgets(password, 100, stdin) == NULL) { printLine(\"fgets() failed\"); password[0] = '\\0'; } passwordLen = strlen(password); if (passwordLen > 0) { password[passwordLen-1] = '\\0'; } if (LogonUserA( username, domain, password, { printLine(\"Unable to login.\"); } SecureZeroMemory(password, 100 * sizeof(char)); password = realloc(password, 200 * sizeof(char)); if (password == NULL) {exit(-1);} strcpy(password, \"Nothing to see here\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_81_goodB2G.cpp", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserW() * BadSink : Authenticate the user using LogonUserW() * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE256_Plaintext_Storage_of_Password__w32_wchar_t_81 { void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_81_goodB2G::action(wchar_t * data) const HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_32.c", "text": "if (LogonUserW( username, domain, data, static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; { wchar_t * data = *dataPtr1; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_32.c", "text": "wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; { wchar_t * data = *dataPtr1; if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } } *dataPtr1 = data; } { wchar_t * data = *dataPtr2; HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_62a.cpp", "text": "static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2BSource(data); if (LogonUserA( username, domain, data, } void goodB2GSource(char * &data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodB2GSource(data); HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_74b.cpp", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserA() * BadSink : Authenticate the user using LogonUserA() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; if (LogonUserA( username, domain, data, void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; if (LogonUserA( username, domain, data, void goodB2GSink(map<int, char *> dataMap) { char * data = dataMap[2]; HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_84_goodG2B.cpp", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserW() * BadSink : Authenticate the user using LogonUserW() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE256_Plaintext_Storage_of_Password__w32_wchar_t_84_goodG2B::CWE256_Plaintext_Storage_of_Password__w32_wchar_t_84_goodG2B(wchar_t * dataCopy) { data = dataCopy; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_65b.c", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserW() * BadSink : Authenticate the user using LogonUserW() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_65b_badSink(wchar_t * data) if (LogonUserW( username, domain, data, #ifndef OMITGOOD void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_65b_goodG2BSink(wchar_t * data) if (LogonUserW( username, domain, data, } void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_65b_goodB2GSink(wchar_t * data) HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_61a.c", "text": "static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE256_Plaintext_Storage_of_Password__w32_char_61b_goodG2BSource(data); if (LogonUserA( username, domain, data, } char * CWE256_Plaintext_Storage_of_Password__w32_char_61b_goodB2GSource(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE256_Plaintext_Storage_of_Password__w32_char_61b_goodB2GSource(data); HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_52c.c", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserA() * BadSink : Authenticate the user using LogonUserA() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE256_Plaintext_Storage_of_Password__w32_char_52c_badSink(char * data) if (LogonUserA( username, domain, data, #ifndef OMITGOOD void CWE256_Plaintext_Storage_of_Password__w32_char_52c_goodG2BSink(char * data) if (LogonUserA( username, domain, data, } void CWE256_Plaintext_Storage_of_Password__w32_char_52c_goodB2GSink(char * data) HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_84_goodB2G.cpp", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserA() * BadSink : Authenticate the user using LogonUserA() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE256_Plaintext_Storage_of_Password__w32_char_84_goodB2G::CWE256_Plaintext_Storage_of_Password__w32_char_84_goodB2G(char * dataCopy) { data = dataCopy; if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_12.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_12.c", "text": "do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes); data[payloadBytes / sizeof(char)] = '\\0'; if (LogonUserA( username, domain, data, HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_12.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_12.c", "text": "do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes); data[payloadBytes / sizeof(char)] = '\\0'; if (LogonUserA( username, domain, data, HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_12.c", "text": "} memcpy(data, payload, payloadBytes); data[payloadBytes / sizeof(char)] = '\\0'; if (LogonUserA( username, domain, data, use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_12.c", "text": "payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes); data[payloadBytes / sizeof(char)] = '\\0'; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_51a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_51a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_51a.cpp", "text": "void badSink(size_t data); void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_51a.cpp", "text": "* Sinks: * GoodSink: Allocate memory with new [] and check the size of the memory to be allocated * BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define HELLO_STRING L\"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_51 #ifndef OMITBAD void badSink(size_t data); void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); badSink(data); #ifndef OMITGOOD void goodG2BSink(size_t data); void goodB2GSink(size_t data); static void goodG2B() { size_t data; data = 0; data = 20; goodG2BSink(data); static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_07.cpp", "text": "#define HELLO_STRING \"hello\" if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_07.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_07.cpp", "text": "static void goodG2B2() { size_t data; data = 0; if(staticFive==5) { data = 20; } if(staticFive==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_07.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_11.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_11.cpp", "text": "{ char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_11.cpp", "text": "{ char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_11.cpp", "text": "{ myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_11.cpp", "text": "} else { printLine(\"fgets() failed.\"); if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "{ char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "{ char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "{ myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_07.cpp", "text": "} else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07 void bad() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07 void bad() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_07.cpp", "text": "if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING) && data < 100) { myString = new wchar_t[data]; static void goodB2G2() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "void bad() { size_t data; data = 0; if(globalTrue) { data = rand(); } if(globalTrue) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "data = 0; if(globalTrue) { data = rand(); } if(globalFalse) { printLine(\"Benign, fixed string\"); } else { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "static void goodB2G2() { size_t data; data = 0; if(globalTrue) { data = rand(); } if(globalTrue) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "data = 0; if(globalFalse) { printLine(\"Benign, fixed string\"); } else { data = 20; } if(globalTrue) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "static void goodG2B2() { size_t data; data = 0; if(globalTrue) { data = 20; } if(globalTrue) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_10.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_52b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_52b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_53c.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_53c.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_66a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_66a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_66a.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); dataArray[2] = data; static void goodG2B() { size_t data; size_t dataArray[5]; data = 0; data = 20; dataArray[2] = data; static void goodB2G() { size_t data; size_t dataArray[5]; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_65b.cpp", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_65 { #ifndef OMITBAD void badSink(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_65b.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_65b.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_65b.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "void bad() { size_t data; data = 0; if(5==5) { data = rand(); } if(5==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "data = 0; if(5==5) { data = rand(); } if(5!=5) { printLine(\"Benign, fixed string\"); } else { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "static void goodB2G2() { size_t data; data = 0; if(5==5) { data = rand(); } if(5==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "data = 0; if(5!=5) { printLine(\"Benign, fixed string\"); } else { data = 20; } if(5==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "static void goodG2B2() { size_t data; data = 0; if(5==5) { data = 20; } if(5==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_03.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_01.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_01.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_01.cpp", "text": "#define HELLO_STRING L\"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_01 void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodG2B() { size_t data; data = 0; data = 20; { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74a.cpp", "text": "* Sinks: * GoodSink: Allocate memory with new [] and check the size of the memory to be allocated * BadSink : Allocate memory with new [], but incorrectly check the size of the memory to be allocated * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files using namespace std; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74 void bad() { size_t data; map<int, size_t> dataMap; data = 0; fscanf(stdin, \"%zu\", &data); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { size_t data; map<int, size_t> dataMap; data = 0; data = 20; dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodB2G() { size_t data; map<int, size_t> dataMap; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_73b.cpp", "text": "using namespace std; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_73 size_t data = dataList.back(); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = dataList.back(); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = dataList.back(); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_61a.cpp", "text": "{ #ifndef OMITBAD size_t badSource(size_t data); void bad() { size_t data; data = 0; data = badSource(data); { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_61a.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_61a.cpp", "text": "#endif #ifndef OMITGOOD size_t goodG2BSource(size_t data); static void goodG2B() { size_t data; data = 0; data = goodG2BSource(data); { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_61a.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_61a.cpp", "text": "} } } size_t goodB2GSource(size_t data); static void goodB2G() { size_t data; data = 0; data = goodB2GSource(data); { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_61a.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; data = goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82.h\" namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82.h\" namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82 void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82.h\" namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82 size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_bad; data = 0; data = 20; CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_goodG2B;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82.h\" namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82 void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_bad; baseObject->action(data); static void goodG2B() { size_t data; data = 0; data = 20; CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_82_goodG2B; baseObject->action(data); static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_42.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_42.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_42.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = 0; data = goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_62b.cpp", "text": "fscanf(stdin, \"%zu\", &data); #ifndef OMITGOOD void goodG2BSource(size_t &data) { data = 20; } void goodB2GSource(size_t &data) { fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54e.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54e.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54e.cpp", "text": "#define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54 void badSink_e(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodG2BSink_e(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodB2GSink_e(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_63b.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_63 { #ifndef OMITBAD void badSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_63b.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_63b.cpp", "text": "printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void goodG2BSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_63b.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_63b.cpp", "text": "delete [] myString; } else { printLine(\"Input is less than the length of the source string\"); } } } void goodB2GSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_63b.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_connect_socket_06.cpp", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING L\"hello\" connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_22a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_22a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_22a.cpp", "text": "int badGlobal = 0; void badSink(size_t data); void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_22a.cpp", "text": "int badGlobal = 0; void badSink(size_t data); void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); badGlobal = 1; badSink(data); int goodG2B1Global = 0; void goodB2G1Sink(size_t data); static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_22a.cpp", "text": "#include <wchar.h> #endif namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_22 a C++ namespace, it doesn't need a globally unique name. */ int badGlobal = 0; void badSink(size_t data); void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); badGlobal = 1; badSink(data); int goodG2B1Global = 0; void goodB2G1Sink(size_t data); static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); goodB2G1Global = 0; goodB2G1Sink(data); } void goodB2G2Sink(size_t data); static void goodB2G2() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad.cpp", "text": "fscanf(stdin, \"%zu\", &data); } CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad() * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad.cpp", "text": "fscanf(stdin, \"%zu\", &data); } CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_84_bad() { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_63b.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_rand_63 { #ifndef OMITBAD void badSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_63b.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_63b.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_63b.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_83_goodB2G.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_83_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_83_goodB2G() * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_83_goodB2G.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_83_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_83_goodB2G() { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_31.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); size_t dataCopy = data; size_t data = dataCopy; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_31.cpp", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_31 data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); size_t dataCopy = data; size_t data = dataCopy; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t dataCopy = data; size_t data = dataCopy; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_31.cpp", "text": "{ myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t dataCopy = data; size_t data = dataCopy; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); size_t dataCopy = data; size_t data = dataCopy; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_61a.cpp", "text": "#define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_61 data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; data = goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad.cpp", "text": "fscanf(stdin, \"%zu\", &data); } CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad() * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad.cpp", "text": "fscanf(stdin, \"%zu\", &data); } CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad::~CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_83_bad() { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_64a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_64a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_goodG2B.cpp", "text": "* */ #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82 { void CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_goodG2B::action(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_goodG2B.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_goodG2B::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 void bad() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 void bad() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; static void goodB2G2() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "#define HELLO_STRING \"hello\" static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "static int staticFive = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07 data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_07.cpp", "text": "if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_09.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_09.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_09.cpp", "text": "data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_09.cpp", "text": "if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING) && data < 100) { myString = new wchar_t[data]; static void goodB2G2() { size_t data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81_bad.cpp", "text": "* */ #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81 { void CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81_bad::action(size_t data) const { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81_bad.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81_bad::action(size_t data) const { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_01.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_01_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); static void goodG2B() { size_t data; data = 0; data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_01.c", "text": "data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_01.c", "text": "data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_01.c", "text": "if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41.c", "text": "if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41.c", "text": "#ifndef OMITGOOD static void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); static void goodG2B() { size_t data; data = 0; data = 20; goodG2BSink(data); } static void goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41_bad() size_t data; data = 0; fscanf(stdin, \"%zu\", &data); static void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_41_bad() size_t data; data = 0; fscanf(stdin, \"%zu\", &data); static void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); static void goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_17.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; for(j = 0; j < 1; j++) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_17.c", "text": "for(j = 0; j < 1; j++) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; for(k = 0; k < 1; k++) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_17.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; for(k = 0; k < 1; k++) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); for(j = 0; j < 1; j++) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B.cpp", "text": "#define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84 { CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B::CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B(size_t dataCopy) { data = dataCopy; data = 20; } CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B() { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_84_goodG2B() { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08.c", "text": "} else { printLine(\"fgets() failed.\"); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08_bad() { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08.c", "text": "} else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_08.c", "text": "if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b.c", "text": "#define HELLO_STRING \"hello\" typedef struct _CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType { size_t structFirst; } CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType; #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType myStruct) { size_t data = myStruct.structFirst; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = myStruct.structFirst; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b.c", "text": "printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b_goodG2BSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType myStruct) { size_t data = myStruct.structFirst; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = myStruct.structFirst; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = myStruct.structFirst; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b.c", "text": "free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b_goodB2GSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType myStruct) { size_t data = myStruct.structFirst; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b.c", "text": "{ size_t data = myStruct.structFirst; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = myStruct.structFirst; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = myStruct.structFirst; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_04.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_04.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_04.c", "text": "if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_04.c", "text": "else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_04.c", "text": "if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_01.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_01_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = (wchar_t *)malloc(data*sizeof(wchar_t)); static void goodG2B() { size_t data; data = 0; data = 20; { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = (wchar_t *)malloc(data*sizeof(wchar_t)); static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81_goodB2G.cpp", "text": "* */ #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81 { void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81_goodB2G::action(size_t data) const { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81_goodB2G.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81_goodB2G::action(size_t data) const { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b.c", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData; extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodG2BData; extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodB2GData; #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b_badSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b.c", "text": "printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b_goodG2BSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodG2BData; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodG2BData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b.c", "text": "free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b_goodB2GSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodB2GData; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b.c", "text": "{ size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodG2BData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodB2GData; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b.c", "text": "#include \"std_testcase.h\" #ifndef _WIN32 #include <wchar.h> #endif #define HELLO_STRING \"hello\" #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b_badSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b.c", "text": "printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b_goodG2BSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b.c", "text": "free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_63b_goodB2GSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_72b.cpp", "text": "#define HELLO_STRING \"hello\" using namespace std; namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_72 { #ifndef OMITBAD void badSink(vector<size_t> dataVector) { size_t data = dataVector[2]; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_72b.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" size_t data = dataVector[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_72b.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" size_t data = dataVector[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = dataVector[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_72b.cpp", "text": "free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void goodB2GSink(vector<size_t> dataVector) { size_t data = dataVector[2]; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "fscanf(stdin, \"%zu\", &data); return data; } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "size_t data; data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); #ifndef OMITGOOD static size_t goodG2BSource(size_t data) { data = 20; return data; static void goodG2B() { size_t data; data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); } static size_t goodB2GSource(size_t data) { fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "fscanf(stdin, \"%zu\", &data); return data; } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42_bad() * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "fscanf(stdin, \"%zu\", &data); return data; } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42_bad() data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" static size_t badSource(size_t data) { fscanf(stdin, \"%zu\", &data); return data; } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42_bad() data = 0; data = badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "fscanf(stdin, \"%zu\", &data); return data; } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42_bad() static size_t goodB2GSource(size_t data) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c", "text": "if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; data = goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); static size_t goodB2GSource(size_t data) { fscanf(stdin, \"%zu\", &data); data = 0; data = goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_82_goodG2B.cpp", "text": "* */ #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_82.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_82 { void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_82_goodG2B::action(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_82_goodG2B.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_82.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_82_goodG2B::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c", "text": "size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61_bad() size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c", "text": "size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61_bad() size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c", "text": "size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61_bad() size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(data); #ifndef OMITGOOD size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(size_t data); size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(data); * for the strcpy() function to not cause a buffer overflow */", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c", "text": "#ifndef OMITBAD size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61_bad() size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); #ifndef OMITGOOD size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(size_t data); size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c", "text": "size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61_bad() size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_badSource(data); #ifndef OMITGOOD size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(size_t data); size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(data); } size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodB2GSource(size_t data); size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodB2GSource(data); * for the strcpy() function to not cause a buffer overflow */", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61a.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); #ifndef OMITGOOD size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(size_t data); size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodB2GSource(size_t data); size_t data; data = 0; data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_61b_goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05_bad() { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05_bad() { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05_bad() { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c", "text": "} else { printLine(\"fgets() failed.\"); if(staticTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05_bad() { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c", "text": "} else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticTrue) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_05.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticTrue) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(staticTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_43.cpp", "text": "size_t data; data = 0; badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); #ifndef OMITGOOD static void goodG2BSource(size_t &data) { data = 20; static void goodG2B() { size_t data; data = 0; goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); } static void goodB2GSource(size_t &data) { fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_43.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_43.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_43.cpp", "text": "if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); static void goodB2GSource(size_t &data) { fscanf(stdin, \"%zu\", &data); data = 0; goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_bad.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_bad::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_bad() * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_bad.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_bad::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_bad() { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_18.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; goto sink; sink: { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_18.cpp", "text": "goto sink; sink: { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; goto sink; sink: { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_18.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; goto sink; sink: { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; goto sink; sink: { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_14.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_14.c", "text": "} else { printLine(\"fgets() failed.\"); if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_14.c", "text": "} else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_14.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B.cpp", "text": "#define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83 { CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B::CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B(size_t dataCopy) { data = dataCopy; data = 20; } CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B() { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83.h\" #define HELLO_STRING \"hello\" CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_goodG2B() { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_32.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_32.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_32.cpp", "text": "recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_32.cpp", "text": "{ size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_08.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_08.cpp", "text": "if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_08.cpp", "text": "else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_08.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_34.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_34.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_34.cpp", "text": "{ size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32_bad() size_t data = *dataPtr1; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_32.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); size_t data = *dataPtr1; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c", "text": "static int badStatic = 0; static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c", "text": "{ { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c", "text": "static int goodG2BStatic = 0; static void goodB2G1Sink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G2() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(badStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21_bad() size_t data; data = 0; fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c", "text": "} } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21_bad() size_t data; data = 0; fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); if(goodB2G2Static) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_21.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); if(goodB2G2Static) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); if(goodG2BStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_16.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; while(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_16.c", "text": "while(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; while(1) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_16.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; while(1) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); while(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad.cpp", "text": "#define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83 { CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad::CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad(size_t dataCopy) { data = dataCopy; data = rand(); } CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad() { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83.h\" #define HELLO_STRING \"hello\" CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_83_bad() { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82_goodG2B.cpp", "text": "* */ #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82 { void CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82_goodG2B::action(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82_goodG2B.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_82_goodG2B::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: fscanf * GoodSink: Correctly check if fscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: fscanf * GoodSink: Correctly check if fscanf() failed * BadSink : Incorrectly check if fscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c", "text": "/* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c", "text": "char dataBuffer[100] = \"\"; char * data = dataBuffer; /* FLAW: fscanf() might fail, in which case the return value will be EOF (-1), but if (fscanf(stdin, \"%99s\\0\", data) == 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c", "text": "char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == 0) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c", "text": "char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == 0) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12.c", "text": "#ifndef OMITBAD void CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_12_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == 0) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14.c", "text": "* @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed #include <wchar.h> #endif #define SRC_STRING \"string\" #ifndef OMITBAD void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_14_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_17.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: fscanf * GoodSink: Correctly check if fscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_17.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: fscanf * GoodSink: Correctly check if fscanf() failed * BadSink : Incorrectly check if fscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s05/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_w32CreateFile_74a.cpp", "text": "void badSink(map<int, wchar_t *> dataMap); void bad() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s05/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_41.cpp", "text": "fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_62b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_62b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_62b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_62b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_45.cpp", "text": "{ int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_45.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_73a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_73a.cpp", "text": "* GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_42.cpp", "text": "* GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_42.cpp", "text": "#ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_53a.cpp", "text": "* GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_54a.cpp", "text": "* GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_84_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_84_goodG2B::CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_84_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_84_goodG2B::CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_84_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_81a.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_81a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_68a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE36_Absolute_Path_Traversal__char_file_ofstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_68a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE36_Absolute_Path_Traversal__char_file_ofstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_17.cpp", "text": "int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_17.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_16.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_16.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_16.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_16.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_52a.cpp", "text": "* GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_62b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_62b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); #ifndef OMITGOOD void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_17.cpp", "text": "int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_17.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_07.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_52a.cpp", "text": "* GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_11.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_11.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_11.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_22b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) if(badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_22b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) if(badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_34.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_34.cpp", "text": "void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_41.cpp", "text": "#ifndef OMITBAD void badSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_41.cpp", "text": "#ifndef OMITBAD void badSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_12.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_12.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_12.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_12.cpp", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_12.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_12.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_01.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_01.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_33.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_33.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_84_goodG2B.cpp", "text": "/* * @description * CWE: 36 Absolute Path Traversal * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_listen_socket_open_84_goodG2B::CWE36_Absolute_Path_Traversal__char_listen_socket_open_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_21.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_21.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_67a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void bad() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_67a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void bad() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_01.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_01.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_08.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_08.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_08.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_16.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_16.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_51a.cpp", "text": "* GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_44.cpp", "text": "outputFile.open((char *)data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_44.cpp", "text": "{ ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_44.cpp", "text": "{ ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_66a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_66a.cpp", "text": "* GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_82a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE36_Absolute_Path_Traversal__char_file_ofstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_file_ofstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_82a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE36_Absolute_Path_Traversal__char_file_ofstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_file_ofstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_44.cpp", "text": "pFile = FOPEN(data, \"wb+\"); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_44.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_44.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_51a.cpp", "text": "* GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_83_goodG2B.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_file_ofstream_83_goodG2B::CWE36_Absolute_Path_Traversal__char_file_ofstream_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_83_goodG2B.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_file_ofstream_83_goodG2B::CWE36_Absolute_Path_Traversal__char_file_ofstream_83_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_fopen_65a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void badSink(wchar_t * data); void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_10.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_10.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_10.cpp", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_10.cpp", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_44.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(wchar_t * data) { ifstream inputFile; inputFile.open((char *)data); void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_12.cpp", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_12.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_12.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_12.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_12.cpp", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_65a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void badSink(wchar_t * data); void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_45.cpp", "text": "hFile = CreateFileA(data, void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_45.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badData = data; static void goodG2BSink() { char * data = goodG2BData; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_45.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badData = data; static void goodG2BSink() { char * data = goodG2BData; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_84_goodG2B.cpp", "text": "/* * @description * CWE: 36 Absolute Path Traversal * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_84_goodG2B::CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_41.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_41.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s04/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ifstream_45.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file namespace CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ifstream_45 { static wchar_t * badData; static wchar_t * goodG2BData; static void badSink() { wchar_t * data = badData; { ifstream inputFile; inputFile.open((char *)data); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s04/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_44.cpp", "text": "outputFile.open((char *)data); void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_45.cpp", "text": "inputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_45.cpp", "text": "static void badSink() { char * data = badData; { ifstream inputFile; inputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_45.cpp", "text": "static void badSink() { char * data = badData; { ifstream inputFile; inputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_54a.cpp", "text": "void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_54a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_54a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_44.cpp", "text": "inputFile.open((char *)data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_44.cpp", "text": "{ ifstream inputFile; inputFile.open((char *)data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_44.cpp", "text": "{ ifstream inputFile; inputFile.open((char *)data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_16.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_16.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_64a.cpp", "text": "* GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_64a.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_18.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_18.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_12.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_12.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_12.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_12.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_12.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_12.cpp", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_15.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_15.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; default: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_15.cpp", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; default: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_73a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_73a.cpp", "text": "* GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_53a.cpp", "text": "* GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_17.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_17.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_21.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_21.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_62b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_62b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); #ifndef OMITGOOD void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_68a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } CWE36_Absolute_Path_Traversal__char_environment_fopen_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_68a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } CWE36_Absolute_Path_Traversal__char_environment_fopen_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_66a.cpp", "text": "void bad() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_66a.cpp", "text": "char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_34.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_34.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_83_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_83_goodG2B::CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_83_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_83_goodG2B::CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_83_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_83_goodG2B.cpp", "text": "/* * @description * CWE: 36 Absolute Path Traversal * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_83_goodG2B::CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_83_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_environment_fopen_83_goodG2B::CWE36_Absolute_Path_Traversal__char_environment_fopen_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_83_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_environment_fopen_83_goodG2B::CWE36_Absolute_Path_Traversal__char_environment_fopen_83_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_45.cpp", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_45.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_51a.cpp", "text": "* GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_11.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_11.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_11.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_61b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_61b.cpp", "text": "* GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_16.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_04.cpp", "text": "#endif size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_14.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_14.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_14.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_02.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_02.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_02.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_42.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_42.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_42.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_42.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_82a.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE36_Absolute_Path_Traversal__char_console_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_console_ifstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_82a.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE36_Absolute_Path_Traversal__char_console_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_console_ifstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_68a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_68a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_17.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_17.cpp", "text": "int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_21.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_21.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_41.cpp", "text": "* GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_41.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_41.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_44.cpp", "text": "pFile = FOPEN(data, \"wb+\"); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_44.cpp", "text": "{ FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_44.cpp", "text": "{ FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_32.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_32.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_45.c", "text": "#include <wchar.h> static wchar_t * CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_45_badData; static wchar_t * CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_45_goodG2BData; static void badSink() { wchar_t * data = CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_45_badData; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); data = dataBuffer - 8; } CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_45_goodG2BData; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_84_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_84_goodG2B::~CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_84_goodG2B() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_16.c", "text": "data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_16.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE124_Buffer_Underwrite__malloc_char_cpy_16_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_01.c", "text": "data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_01.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__malloc_char_memmove_01_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_06.c", "text": "void CWE124_Buffer_Underwrite__malloc_char_cpy_06_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_06.c", "text": "#include <wchar.h> void CWE124_Buffer_Underwrite__malloc_char_cpy_06_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_06.c", "text": "strcpy(data, source); printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_54e.c", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_54e_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_45.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE124_Buffer_Underwrite__malloc_char_memmove_45_badData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); data = dataBuffer - 8; } CWE124_Buffer_Underwrite__malloc_char_memmove_45_badData = data; static void goodG2BSink() { char * data = CWE124_Buffer_Underwrite__malloc_char_memmove_45_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_33.cpp", "text": "data = dataBuffer - 8; } { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_33.cpp", "text": "wchar_t * &dataRef = data; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_11.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE124_Buffer_Underwrite__malloc_char_cpy_11_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_34.c", "text": "data = dataBuffer - 8; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_34.c", "text": "{ char * data; CWE124_Buffer_Underwrite__malloc_char_cpy_34_unionType myUnion; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; CWE124_Buffer_Underwrite__malloc_char_cpy_34_unionType myUnion; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_83_bad.cpp", "text": "data = dataBuffer - 8; CWE124_Buffer_Underwrite__malloc_char_memcpy_83_bad::~CWE124_Buffer_Underwrite__malloc_char_memcpy_83_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_16.c", "text": "while(1) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; while(1) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_22a.c", "text": "int CWE124_Buffer_Underwrite__malloc_char_memmove_22_badGlobal = 0; char * CWE124_Buffer_Underwrite__malloc_char_memmove_22_badSource(char * data); void CWE124_Buffer_Underwrite__malloc_char_memmove_22_bad() { char * data; data = NULL; CWE124_Buffer_Underwrite__malloc_char_memmove_22_badGlobal = 1; data = CWE124_Buffer_Underwrite__malloc_char_memmove_22_badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_22a.c", "text": "int CWE124_Buffer_Underwrite__malloc_char_memmove_22_badGlobal = 0; char * CWE124_Buffer_Underwrite__malloc_char_memmove_22_badSource(char * data); void CWE124_Buffer_Underwrite__malloc_char_memmove_22_bad() { char * data; data = NULL; CWE124_Buffer_Underwrite__malloc_char_memmove_22_badGlobal = 1; data = CWE124_Buffer_Underwrite__malloc_char_memmove_22_badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); int CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B2Global = 0; char * CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B1Global = 0; data = CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_22a.c", "text": "#ifndef OMITGOOD int CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B2Global = 0; char * CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B1Global = 0; data = CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); char * CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B2Global = 1; data = CWE124_Buffer_Underwrite__malloc_char_memmove_22_goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_03.c", "text": "if(5==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_03.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(5==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_10.c", "text": "if(globalTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_10.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(globalTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_84_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__malloc_char_cpy_84_goodG2B::~CWE124_Buffer_Underwrite__malloc_char_cpy_84_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_63b.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); void CWE124_Buffer_Underwrite__malloc_char_cpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_42.c", "text": "data = dataBuffer - 8; } return data; void CWE124_Buffer_Underwrite__malloc_char_ncpy_42_bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_42.c", "text": "data = dataBuffer - 8; } return data; void CWE124_Buffer_Underwrite__malloc_char_ncpy_42_bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); data = dataBuffer; } return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_09.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__malloc_char_memcpy_09_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_14.c", "text": "if(globalFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_14.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(globalFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_52c.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_52c_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_83_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__new_char_cpy_83_goodG2B::~CWE124_Buffer_Underwrite__new_char_cpy_83_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_15.cpp", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_15.cpp", "text": "data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_18.cpp", "text": "wchar_t * data; data = NULL; goto source; source: { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; goto source; source: { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_61a.cpp", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * badSource(char * data); void bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); char * goodG2BSource(char * data); static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_53d.cpp", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void goodG2BSink_d(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_ncpy_83_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__new_char_ncpy_83_goodG2B::~CWE124_Buffer_Underwrite__new_char_ncpy_83_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_44.cpp", "text": "#ifndef OMITBAD static void badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void (*funcPtr) (char *) = badSink; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_54e.cpp", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void goodG2BSink_e(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_22a.cpp", "text": "a C++ namespace, it doesn't need a globally unique name. */ int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = NULL; badGlobal = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_22a.cpp", "text": "#ifndef OMITGOOD char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); char * goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; goodG2B2Global = 1; data = goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_66b.cpp", "text": "wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_63b.cpp", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); void goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_61a.cpp", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * badSource(char * data); void bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); char * goodG2BSource(char * data); static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_83_bad.cpp", "text": "data = dataBuffer - 8; CWE124_Buffer_Underwrite__new_wchar_t_memmove_83_bad::~CWE124_Buffer_Underwrite__new_wchar_t_memmove_83_bad() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_32.cpp", "text": "data = dataBuffer - 8; } *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_03.cpp", "text": "if(5==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_03.cpp", "text": "else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(5==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_21.cpp", "text": "static int badStatic = 0; static char * badSource(char * data) char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } return data; void bad() { char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_21.cpp", "text": "badStatic = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } return data; static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_21.cpp", "text": "static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static char * goodG2B2Source(char * data) char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } return data; static void goodG2B2() { char * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_18.cpp", "text": "void bad() { char * data; data = NULL; goto source; source: char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; data = NULL; goto source; source: char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_68b.cpp", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); void goodG2BSink() { char * data = CWE124_Buffer_Underwrite__new_char_cpy_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_ncpy_54e.cpp", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); void goodG2BSink_e(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_04.cpp", "text": "if(STATIC_CONST_TRUE) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_04.cpp", "text": "else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(STATIC_CONST_TRUE) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_63b.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_63b_goodG2BSink(wchar_t * * dataPtr) { wchar_t * data = *dataPtr; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_44.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_10.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_10_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalTrue) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_10.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalTrue) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memmove_64b.c", "text": "wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__wchar_t_declare_memmove_64b_goodG2BSink(void * dataVoidPtr) { wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_03.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_03_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(5==5) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_03.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(5==5) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_07.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(staticFive==5) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_06.c", "text": "void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_06_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_06.c", "text": "#include <wchar.h> void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_06_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_06.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_52c.c", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_52c_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_52c.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_52c_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_15.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_15_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); switch(6) { case 6: data = dataBuffer - 8; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_15.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); switch(6) { case 6: data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memmove_13.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__char_declare_memmove_13_bad() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_66a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_66b_badSink(int dataArray[]); void CWE124_Buffer_Underwrite__CWE839_fscanf_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_66a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_66b_badSink(int dataArray[]); void CWE124_Buffer_Underwrite__CWE839_fscanf_66_bad() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_66a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_66b_badSink(int dataArray[]); void CWE124_Buffer_Underwrite__CWE839_fscanf_66_bad() int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE124_Buffer_Underwrite__CWE839_fscanf_66b_badSink(dataArray); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_66b_goodG2BSink(int dataArray[]); * access an index of the array in the sink that is out-of-bounds */ data = 7; dataArray[2] = data; CWE124_Buffer_Underwrite__CWE839_fscanf_66b_goodG2BSink(dataArray); } void CWE124_Buffer_Underwrite__CWE839_fscanf_66b_goodB2GSink(int dataArray[]);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_66a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_66_bad() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE124_Buffer_Underwrite__CWE839_fscanf_66b_badSink(dataArray); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_66b_goodG2BSink(int dataArray[]); static void goodG2B() { int data; int dataArray[5]; data = -1; data = 7; dataArray[2] = data; CWE124_Buffer_Underwrite__CWE839_fscanf_66b_goodG2BSink(dataArray); } void CWE124_Buffer_Underwrite__CWE839_fscanf_66b_goodB2GSink(int dataArray[]); static void goodB2G() { int data; int dataArray[5]; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_84_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_ncpy_11.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE124_Buffer_Underwrite__char_alloca_ncpy_11_bad() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_ncpy_11.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_ncpy_41.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE124_Buffer_Underwrite__char_alloca_ncpy_41_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__char_alloca_ncpy_41_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE124_Buffer_Underwrite__char_alloca_ncpy_41_badSink(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_alloca_ncpy_41_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_67a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); void CWE124_Buffer_Underwrite__CWE839_fscanf_67_bad() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_67a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); void CWE124_Buffer_Underwrite__CWE839_fscanf_67_bad() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_67a.c", "text": "#include \"std_testcase.h\" typedef struct _CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType { int structFirst; } CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType; #ifndef OMITBAD void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); void CWE124_Buffer_Underwrite__CWE839_fscanf_67_bad() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE124_Buffer_Underwrite__CWE839_fscanf_67b_badSink(myStruct); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_goodG2BSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); static void goodG2B() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct; * access an index of the array in the sink that is out-of-bounds */ data = 7; myStruct.structFirst = data; CWE124_Buffer_Underwrite__CWE839_fscanf_67b_goodG2BSink(myStruct); } void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_goodB2GSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); static void goodB2G() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_67a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); void CWE124_Buffer_Underwrite__CWE839_fscanf_67_bad() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE124_Buffer_Underwrite__CWE839_fscanf_67b_badSink(myStruct); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_goodG2BSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); static void goodG2B() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct; data = -1; data = 7; myStruct.structFirst = data; CWE124_Buffer_Underwrite__CWE839_fscanf_67b_goodG2BSink(myStruct); } void CWE124_Buffer_Underwrite__CWE839_fscanf_67b_goodB2GSink(CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct); static void goodB2G() { int data; CWE124_Buffer_Underwrite__CWE839_fscanf_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memcpy_63b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__char_alloca_memcpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_ncpy_34.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE124_Buffer_Underwrite__char_declare_ncpy_34_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_45.c", "text": "if (data < 10) { buffer[data] = 1; } } void CWE124_Buffer_Underwrite__CWE839_fscanf_45_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_45.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); CWE124_Buffer_Underwrite__CWE839_fscanf_45_badData = data; static void goodG2BSink() { int data = CWE124_Buffer_Underwrite__CWE839_fscanf_45_goodG2BData; data = 7; CWE124_Buffer_Underwrite__CWE839_fscanf_45_goodG2BData = data; static void goodB2GSink() { int data = CWE124_Buffer_Underwrite__CWE839_fscanf_45_goodB2GData;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_45.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); CWE124_Buffer_Underwrite__CWE839_fscanf_45_badData = data; static void goodG2BSink() { int data = CWE124_Buffer_Underwrite__CWE839_fscanf_45_goodG2BData; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; static void goodG2B() { int data; data = -1; data = 7; CWE124_Buffer_Underwrite__CWE839_fscanf_45_goodG2BData = data; static void goodB2GSink() { int data = CWE124_Buffer_Underwrite__CWE839_fscanf_45_goodB2GData; int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_34.c", "text": "data = dataBuffer - 8; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_34.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE124_Buffer_Underwrite__char_alloca_memmove_34_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_ncpy_31.c", "text": "data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_ncpy_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 31 Data flow using a copy of data within the same function void CWE124_Buffer_Underwrite__char_declare_ncpy_31_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_ncpy_13.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE124_Buffer_Underwrite__char_alloca_ncpy_13_bad() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_ncpy_13.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_cpy_53d.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_alloca_cpy_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memcpy_52c.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_alloca_memcpy_52c_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_33.cpp", "text": "data = dataBuffer - 8; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_33.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_14.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__char_declare_memcpy_14_bad() { char * data; dataBuffer[100-1] = '\\0'; if(globalFive==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_14.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(globalFive==5) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_ncpy_04.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_TRUE) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memcpy_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 31 Data flow using a copy of data within the same function void CWE124_Buffer_Underwrite__char_alloca_memcpy_31_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_68b.c", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__char_alloca_memmove_68b_goodG2BSink() { char * data = CWE124_Buffer_Underwrite__char_alloca_memmove_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_13.c", "text": "data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_13.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memcpy_14.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__char_alloca_memcpy_14_bad() { char * data; dataBuffer[100-1] = '\\0'; if(globalFive==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_ncpy_33.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memcpy_10.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__char_alloca_memcpy_10_bad() { char * data; dataBuffer[100-1] = '\\0'; if(globalTrue) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_64a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE124_Buffer_Underwrite__CWE839_fscanf_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_64a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE124_Buffer_Underwrite__CWE839_fscanf_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_64a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE124_Buffer_Underwrite__CWE839_fscanf_64_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE124_Buffer_Underwrite__CWE839_fscanf_64b_badSink(&data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_goodG2BSink(void * dataVoidPtr); data = 7; CWE124_Buffer_Underwrite__CWE839_fscanf_64b_goodG2BSink(&data); } void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_goodB2GSink(void * dataVoidPtr);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_64a.c", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking the lower bound * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_badSink(void * dataVoidPtr); void CWE124_Buffer_Underwrite__CWE839_fscanf_64_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE124_Buffer_Underwrite__CWE839_fscanf_64b_badSink(&data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int data; data = -1; data = 7; CWE124_Buffer_Underwrite__CWE839_fscanf_64b_goodG2BSink(&data); } void CWE124_Buffer_Underwrite__CWE839_fscanf_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memmove_06.c", "text": "void CWE124_Buffer_Underwrite__char_declare_memmove_06_bad() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memmove_06.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove #include <wchar.h> void CWE124_Buffer_Underwrite__char_declare_memmove_06_bad() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memmove_06.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_06.c", "text": "void CWE124_Buffer_Underwrite__char_alloca_memmove_06_bad() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_06.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove #include <wchar.h> void CWE124_Buffer_Underwrite__char_alloca_memmove_06_bad() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_65a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink(int data); void CWE124_Buffer_Underwrite__CWE839_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_65a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink(int data); void CWE124_Buffer_Underwrite__CWE839_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_65a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink(int data); void CWE124_Buffer_Underwrite__CWE839_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodG2BSink; } void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodB2GSink;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_65a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink(int data); void CWE124_Buffer_Underwrite__CWE839_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data); funcPtr(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodG2BSink; data = -1; data = 7; funcPtr(data); } void CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE124_Buffer_Underwrite__CWE839_fscanf_65b_goodB2GSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_02.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__char_alloca_memmove_02_bad() { char * data; dataBuffer[100-1] = '\\0'; if(1) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_02.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(1) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_17.c", "text": "* GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data void CWE401_Memory_Leak__strdup_char_17_bad() { int i,j; char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); static void goodB2G() { int i,k; char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); for(k = 0; k < 1; k++) { free(data); static void goodG2B() { int h,j; char * data; data = NULL; for(h = 0; h < 1; h++) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_14.c", "text": "static void goodB2G1() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); if(globalFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_14.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); if(globalFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(globalFive==5) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_51a.c", "text": "void CWE401_Memory_Leak__strdup_char_51b_badSink(char * data); void CWE401_Memory_Leak__strdup_char_51_bad() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); } CWE401_Memory_Leak__strdup_char_51b_badSink(data); #ifndef OMITGOOD void CWE401_Memory_Leak__strdup_char_51b_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_68a.c", "text": "data = strdup(myString); printLine(data); } CWE401_Memory_Leak__strdup_char_68_badData = data; static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_06.c", "text": "static void goodB2G1() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); if(STATIC_CONST_FIVE==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_06.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); if(STATIC_CONST_FIVE==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_22a.c", "text": "int CWE401_Memory_Leak__char_calloc_22_badGlobal = 0; void CWE401_Memory_Leak__char_calloc_22_badSink(char * data); void CWE401_Memory_Leak__char_calloc_22_bad() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_22a.c", "text": "int CWE401_Memory_Leak__char_calloc_22_badGlobal = 0; void CWE401_Memory_Leak__char_calloc_22_badSink(char * data); void CWE401_Memory_Leak__char_calloc_22_bad() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_22_badGlobal = 1; CWE401_Memory_Leak__char_calloc_22_badSink(data); int CWE401_Memory_Leak__char_calloc_22_goodG2BGlobal = 0; void CWE401_Memory_Leak__char_calloc_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_22a.c", "text": "char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_22_badGlobal = 1; CWE401_Memory_Leak__char_calloc_22_badSink(data); int CWE401_Memory_Leak__char_calloc_22_goodG2BGlobal = 0; void CWE401_Memory_Leak__char_calloc_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_22_goodB2G1Global = 0; CWE401_Memory_Leak__char_calloc_22_goodB2G1Sink(data); } void CWE401_Memory_Leak__char_calloc_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_22a.c", "text": "static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_22_goodB2G1Global = 0; CWE401_Memory_Leak__char_calloc_22_goodB2G1Sink(data); } void CWE401_Memory_Leak__char_calloc_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_22_goodB2G2Global = 1; CWE401_Memory_Leak__char_calloc_22_goodB2G2Sink(data); } void CWE401_Memory_Leak__char_calloc_22_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_66a.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_66a.c", "text": "* Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE401_Memory_Leak__char_calloc_66_bad() { char * data; char * dataArray[5]; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodB2G() { char * data; char * dataArray[5]; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_64a.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_64b_badSink(&data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_64a.c", "text": "* @description * CWE: 401 Memory Leak * BadSource: realloc Allocate data using realloc() * GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE401_Memory_Leak__char_realloc_64_bad() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_64b_badSink(&data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_64b_goodG2BSink(&data); static void goodB2G() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_18.cpp", "text": "data = new char[100]; strcpy(data, \"A String\"); printLine(data); static void goodB2G() { char * data; data = NULL; goto source; source: data = new char[100]; strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_18.cpp", "text": "* GoodSource: Point data to a stack buffer * Sinks: * GoodSink: call delete[] on data * BadSink : no deallocation of data void bad() { char * data; data = NULL; goto source; source: data = new char[100]; strcpy(data, \"A String\"); printLine(data); static void goodB2G() { char * data; data = NULL; goto source; source: data = new char[100]; strcpy(data, \"A String\"); printLine(data); goto sink; sink: delete[] data; static void goodG2B() { char * data; data = NULL; source: char dataGoodBuffer[100]; data = dataGoodBuffer; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_11.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_11.c", "text": "void CWE401_Memory_Leak__char_malloc_11_bad() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_11.c", "text": "static void goodB2G1() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalReturnsTrue()) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_11.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalReturnsTrue()) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(globalReturnsTrue()) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_14.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_14.c", "text": "void CWE401_Memory_Leak__char_calloc_14_bad() { char * data; data = NULL; if(globalFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_14.c", "text": "static void goodB2G1() { char * data; data = NULL; if(globalFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_14.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(globalFive==5) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_02.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_02.c", "text": "void CWE401_Memory_Leak__char_malloc_02_bad() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_02.c", "text": "static void goodB2G1() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(1) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_02.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(1) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(1) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_07.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(staticFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_07.c", "text": "void CWE401_Memory_Leak__char_calloc_07_bad() { char * data; data = NULL; if(staticFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(staticFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_07.c", "text": "static void goodB2G1() { char * data; data = NULL; if(staticFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(staticFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_07.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticFive==5) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(staticFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_08.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_08.c", "text": "void CWE401_Memory_Leak__char_malloc_08_bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_08.c", "text": "static void goodB2G1() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(staticReturnsTrue()) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_08.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(staticReturnsTrue()) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_09.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_09.c", "text": "void CWE401_Memory_Leak__char_calloc_09_bad() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_09.c", "text": "static void goodB2G1() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(GLOBAL_CONST_TRUE) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_09.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(GLOBAL_CONST_TRUE) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_12.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_12.c", "text": "* BadSource: malloc Allocate data using malloc() * GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data void CWE401_Memory_Leak__char_malloc_12_bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); else { free(data); use the GoodSink */ static void goodB2G() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_12.c", "text": "void CWE401_Memory_Leak__char_malloc_12_bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); else { free(data); use the GoodSink */ static void goodB2G() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_12.c", "text": "else { free(data); use the GoodSink */ static void goodB2G() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalReturnsTrueOrFalse()) { free(data); else { free(data); use the BadSink */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_12.c", "text": "{ data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalReturnsTrueOrFalse()) { free(data); else { free(data); use the BadSink */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_17.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G() { int i,k; char * data; data = NULL; for(i = 0; i < 1; i++) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_17.c", "text": "void CWE401_Memory_Leak__char_calloc_17_bad() { int i,j; char * data; data = NULL; for(i = 0; i < 1; i++) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G() { int i,k; char * data; data = NULL; for(i = 0; i < 1; i++) { data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); for(k = 0; k < 1; k++) { free(data); static void goodG2B() { int h,j; char * data; data = NULL; for(h = 0; h < 1; h++) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_32.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_32.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); *dataPtr1 = data; } { char * data = *dataPtr2; static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_81a.cpp", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); const CWE401_Memory_Leak__char_calloc_81_base& baseObject = CWE401_Memory_Leak__char_calloc_81_bad(); baseObject.action(data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_81a.cpp", "text": "* BadSource: calloc Allocate data using calloc() * GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); const CWE401_Memory_Leak__char_calloc_81_base& baseObject = CWE401_Memory_Leak__char_calloc_81_bad(); baseObject.action(data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); const CWE401_Memory_Leak__char_calloc_81_base& baseObject = CWE401_Memory_Leak__char_calloc_81_goodG2B(); baseObject.action(data); static void goodB2G() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_18.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G() { char * data; data = NULL; goto source; source: data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_18.c", "text": "void CWE401_Memory_Leak__char_realloc_18_bad() { char * data; data = NULL; goto source; source: data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G() { char * data; data = NULL; goto source; source: data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); goto sink; sink: free(data); static void goodG2B() { char * data; data = NULL; goto source; source: data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_12.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_12.c", "text": "* BadSource: realloc Allocate data using realloc() * GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data void CWE401_Memory_Leak__char_realloc_12_bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); else { free(data); use the GoodSink */ static void goodB2G() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_12.c", "text": "void CWE401_Memory_Leak__char_realloc_12_bad() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); else { free(data); use the GoodSink */ static void goodB2G() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_12.c", "text": "else { free(data); use the GoodSink */ static void goodB2G() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalReturnsTrueOrFalse()) { free(data); else { free(data); use the BadSink */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_12.c", "text": "{ data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalReturnsTrueOrFalse()) { free(data); else { free(data); use the BadSink */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_13.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(GLOBAL_CONST_FIVE==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_13.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(GLOBAL_CONST_FIVE==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_13.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(GLOBAL_CONST_FIVE==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_13.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(GLOBAL_CONST_FIVE==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_13.c", "text": "char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\"); printLine(data); } free(data); if(GLOBAL_CONST_FIVE==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_13.c", "text": "strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\"); printLine(data); } free(data); if(GLOBAL_CONST_FIVE==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_51a.c", "text": "void CWE401_Memory_Leak__char_calloc_51b_badSink(char * data); void CWE401_Memory_Leak__char_calloc_51_bad() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_51a.c", "text": "void CWE401_Memory_Leak__char_calloc_51b_badSink(char * data); void CWE401_Memory_Leak__char_calloc_51_bad() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_51b_badSink(data); #ifndef OMITGOOD void CWE401_Memory_Leak__char_calloc_51b_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_51a.c", "text": "void CWE401_Memory_Leak__char_calloc_51_bad() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_51b_badSink(data); #ifndef OMITGOOD void CWE401_Memory_Leak__char_calloc_51b_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_calloc_51b_goodG2BSink(data); } void CWE401_Memory_Leak__char_calloc_51b_goodB2GSink(char * data); static void goodB2G() { char * data; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_22a.c", "text": "int CWE401_Memory_Leak__char_realloc_22_badGlobal = 0; void CWE401_Memory_Leak__char_realloc_22_badSink(char * data); void CWE401_Memory_Leak__char_realloc_22_bad() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_22a.c", "text": "int CWE401_Memory_Leak__char_realloc_22_badGlobal = 0; void CWE401_Memory_Leak__char_realloc_22_badSink(char * data); void CWE401_Memory_Leak__char_realloc_22_bad() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_22_badGlobal = 1; CWE401_Memory_Leak__char_realloc_22_badSink(data); int CWE401_Memory_Leak__char_realloc_22_goodG2BGlobal = 0; void CWE401_Memory_Leak__char_realloc_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_22a.c", "text": "char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_22_badGlobal = 1; CWE401_Memory_Leak__char_realloc_22_badSink(data); int CWE401_Memory_Leak__char_realloc_22_goodG2BGlobal = 0; void CWE401_Memory_Leak__char_realloc_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_22_goodB2G1Global = 0; CWE401_Memory_Leak__char_realloc_22_goodB2G1Sink(data); } void CWE401_Memory_Leak__char_realloc_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_22a.c", "text": "static void goodB2G1() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_22_goodB2G1Global = 0; CWE401_Memory_Leak__char_realloc_22_goodB2G1Sink(data); } void CWE401_Memory_Leak__char_realloc_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_22_goodB2G2Global = 1; CWE401_Memory_Leak__char_realloc_22_goodB2G2Sink(data); } void CWE401_Memory_Leak__char_realloc_22_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_31.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_31.c", "text": "* Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 31 Data flow using a copy of data within the same function void CWE401_Memory_Leak__char_malloc_31_bad() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); { char * dataCopy = data; char * data = dataCopy; static void goodB2G() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_10.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(globalTrue) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_10.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(globalTrue) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_10.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(globalTrue) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_10.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(globalTrue) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_10.c", "text": "char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\"); printLine(data); } free(data); if(globalTrue) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_10.c", "text": "strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\"); printLine(data); } free(data); if(globalTrue) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_33.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_33.cpp", "text": "if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); { char * data = dataRef; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_33.cpp", "text": "{ intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_64a.c", "text": "} #endif } CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_64b_badSink(&data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_64b_goodG2BSink(&data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_68a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_68_badData = data; static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_68_goodG2BData = data; static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_15.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_console_15_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_15.c", "text": "int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; break; default: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_15.c", "text": "if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_15.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcpy(data, \"15\"); { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_15.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcpy(data, \"15\"); { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; switch(6) { case 6: strcpy(data, \"15\"); { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_15.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_15.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcpy(data, \"15\"); case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; switch(6) { case 6: strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_72a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files #ifndef OMITBAD void badSink(vector<wchar_t *> dataVector); void bad() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_72a.cpp", "text": "wcscpy(data, L\"15\"); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); } void goodB2GSink(vector<wchar_t *> dataVector); static void goodB2G() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_15.c", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_file_15_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_15.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; break; default: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_15.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; break; default: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_15.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcpy(data, \"15\"); { case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_15.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; default: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_15.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcpy(data, \"15\"); case 7: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; switch(6) { case 6: strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_10.c", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_listen_socket_10_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_10.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_10.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(globalTrue) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_10.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_61a.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE606_Unchecked_Loop_Condition__char_console_61b_badSource(char * data); void CWE606_Unchecked_Loop_Condition__char_console_61_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE606_Unchecked_Loop_Condition__char_console_61b_badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_61a.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE606_Unchecked_Loop_Condition__char_console_61b_badSource(char * data); void CWE606_Unchecked_Loop_Condition__char_console_61_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE606_Unchecked_Loop_Condition__char_console_61b_badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { #ifndef OMITGOOD char * CWE606_Unchecked_Loop_Condition__char_console_61b_goodG2BSource(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE606_Unchecked_Loop_Condition__char_console_61b_goodG2BSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_61a.c", "text": "int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { #ifndef OMITGOOD char * CWE606_Unchecked_Loop_Condition__char_console_61b_goodG2BSource(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE606_Unchecked_Loop_Condition__char_console_61b_goodG2BSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { } char * CWE606_Unchecked_Loop_Condition__char_console_61b_goodB2GSource(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = CWE606_Unchecked_Loop_Condition__char_console_61b_goodB2GSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65a.c", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65b_badSink(wchar_t * data); void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65b_badSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65a.c", "text": "void (*funcPtr) (wchar_t *) = CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65b_goodG2BSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); funcPtr(data); } void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_65b_goodB2GSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_83_bad.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv { CWE606_Unchecked_Loop_Condition__char_environment_83_bad::CWE606_Unchecked_Loop_Condition__char_environment_83_bad(char * dataCopy) { data = dataCopy; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); CWE606_Unchecked_Loop_Condition__char_environment_83_bad::~CWE606_Unchecked_Loop_Condition__char_environment_83_bad() { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_02.c", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_file_02_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_02.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_02.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_02.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_02.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(1) { strcpy(data, \"15\"); if(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_02.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(1) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_52c.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE606_Unchecked_Loop_Condition__char_console_52c_badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_52c.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE606_Unchecked_Loop_Condition__char_console_52c_badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_console_52c_goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_52c.c", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE606_Unchecked_Loop_Condition__char_console_52c_badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_console_52c_goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { } void CWE606_Unchecked_Loop_Condition__char_console_52c_goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_74a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #ifndef OMITBAD void badSink(map<int, wchar_t *> dataMap); void bad() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_74a.cpp", "text": "wcscpy(data, L\"15\"); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; } void goodB2GSink(map<int, wchar_t *> dataMap); static void goodB2G() { wchar_t * data; map<int, wchar_t *> dataMap; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45.c", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static wchar_t * CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_badData; static wchar_t * CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_goodG2BData; static wchar_t * CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_goodB2GData; static void badSink() { wchar_t * data = CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_badData; { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) void CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45.c", "text": "static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_goodG2BData = data; static void goodB2GSink() { wchar_t * data = CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_45_goodB2GData; { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_16.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_console_16_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_16.c", "text": "int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_16.c", "text": "{ dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { strcpy(data, \"15\"); while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_16.c", "text": "static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_73b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_73b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_73b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void goodB2GSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_81_goodB2G.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE606_Unchecked_Loop_Condition__char_console_81 { void CWE606_Unchecked_Loop_Condition__char_console_81_goodB2G::action(char * data) const { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_67b.c", "text": "/* * @description * CWE: 606 Unchecked Input For Loop Condition * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE606_Unchecked_Loop_Condition__char_listen_socket_67b_badSink(CWE606_Unchecked_Loop_Condition__char_listen_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_67b.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_listen_socket_67b_goodG2BSink(CWE606_Unchecked_Loop_Condition__char_listen_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_67b.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_listen_socket_67b_goodG2BSink(CWE606_Unchecked_Loop_Condition__char_listen_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_listen_socket_67b_goodB2GSink(CWE606_Unchecked_Loop_Condition__char_listen_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_22b.c", "text": "extern int CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badGlobal; void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_22b.c", "text": "extern int CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badGlobal; void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { extern int CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodG2BGlobal; void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodB2G1Sink(char * data) else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_22b.c", "text": "extern int CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badGlobal; void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_connect_socket_22_badGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { extern int CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodG2BGlobal; void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodB2G1Sink(char * data) else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { } void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodB2G2Sink(char * data) if(CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodB2G2Global) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_22b.c", "text": "extern int CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodG2BGlobal; void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodB2G1Sink(char * data) else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { } void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodB2G2Sink(char * data) if(CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodB2G2Global) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { } void CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodG2BSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_connect_socket_22_goodG2BGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_43.cpp", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_43.cpp", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { #ifndef OMITGOOD static void goodG2BSource(char * &data) { strcpy(data, \"15\"); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2BSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_43.cpp", "text": "{ intVariable = 0; for (i = 0; i < n; i++) { } static void goodB2GSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodB2GSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_43.cpp", "text": "#ifndef OMITBAD static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) #ifndef OMITGOOD static void goodG2BSource(char * &data) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_61b.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } return data; #ifndef OMITGOOD wchar_t * CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_61b_goodG2BSource(wchar_t * data) { wcscpy(data, L\"15\"); return data; } wchar_t * CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_61b_goodB2GSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_17.c", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_listen_socket_17_bad() { int i,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); for(j = 0; j < 1; j++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_17.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G() { int i,k; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); for(k = 0; k < 1; k++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_17.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); for(k = 0; k < 1; k++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { int h,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(h = 0; h < 1; h++) { strcpy(data, \"15\"); for(j = 0; j < 1; j++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_17.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { int i,k; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_17.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { int h,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(h = 0; h < 1; h++) { strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_83_bad.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE606_Unchecked_Loop_Condition__char_console_83_bad::CWE606_Unchecked_Loop_Condition__char_console_83_bad(char * dataCopy) { data = dataCopy; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; CWE606_Unchecked_Loop_Condition__char_console_83_bad::~CWE606_Unchecked_Loop_Condition__char_console_83_bad() { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_63b.c", "text": "/* * @description * CWE: 606 Unchecked Input For Loop Condition * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE606_Unchecked_Loop_Condition__char_connect_socket_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_63b.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_connect_socket_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_63b.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_connect_socket_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_connect_socket_63b_goodB2GSink(char * * dataPtr) { char * data = *dataPtr; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_12.c", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_file_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } else { strcpy(data, \"15\"); if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_12.c", "text": "void CWE606_Unchecked_Loop_Condition__char_file_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } else { strcpy(data, \"15\"); if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_12.c", "text": "use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_12.c", "text": "if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_12.c", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_file_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } else { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_12.c", "text": "if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_12.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"15\"); } else { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_18.c", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_file_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_18.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_18.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goto source; source: strcpy(data, \"15\"); goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_18.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goto source; source: strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_08.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_console_08_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(staticReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_08.c", "text": "if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(staticReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_08.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(staticReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(staticReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_08.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_01.c", "text": "static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_16.c", "text": "void CWE606_Unchecked_Loop_Condition__char_connect_socket_16_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_16.c", "text": "static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_16.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { strcpy(data, \"15\"); while(1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_16.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_16.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; while(1) { strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_66b.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE606_Unchecked_Loop_Condition__char_console_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_66b.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE606_Unchecked_Loop_Condition__char_console_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_console_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_66b.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE606_Unchecked_Loop_Condition__char_console_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_console_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_console_66b_goodB2GSink(char * dataArray[]) { char * data = dataArray[2]; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_68a.c", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE606_Unchecked_Loop_Condition__char_console_68_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE606_Unchecked_Loop_Condition__char_console_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_32.c", "text": "void CWE606_Unchecked_Loop_Condition__char_console_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_32.c", "text": "} else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"15\"); *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_32.c", "text": "static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_32.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_18.c", "text": "void CWE606_Unchecked_Loop_Condition__char_connect_socket_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_18.c", "text": "static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_18.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goto source; source: strcpy(data, \"15\"); goto sink; sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_18.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_18.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); sink: { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goto source; source: strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_41.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_41.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_environment_41_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_41.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); goodG2BSink(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_41.c", "text": "strncat(data+dataLen, environment, 100-dataLen-1); } } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); goodG2BSink(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_41.c", "text": "#ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) void CWE606_Unchecked_Loop_Condition__char_environment_41_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_22b.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size extern int CWE606_Unchecked_Loop_Condition__char_console_22_badGlobal; void CWE606_Unchecked_Loop_Condition__char_console_22_badSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_console_22_badGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_22b.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size extern int CWE606_Unchecked_Loop_Condition__char_console_22_badGlobal; void CWE606_Unchecked_Loop_Condition__char_console_22_badSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_console_22_badGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { extern int CWE606_Unchecked_Loop_Condition__char_console_22_goodG2BGlobal; void CWE606_Unchecked_Loop_Condition__char_console_22_goodB2G1Sink(char * data) else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_22b.c", "text": "extern int CWE606_Unchecked_Loop_Condition__char_console_22_badGlobal; void CWE606_Unchecked_Loop_Condition__char_console_22_badSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_console_22_badGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { extern int CWE606_Unchecked_Loop_Condition__char_console_22_goodG2BGlobal; void CWE606_Unchecked_Loop_Condition__char_console_22_goodB2G1Sink(char * data) else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { } void CWE606_Unchecked_Loop_Condition__char_console_22_goodB2G2Sink(char * data) if(CWE606_Unchecked_Loop_Condition__char_console_22_goodB2G2Global) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_22b.c", "text": "extern int CWE606_Unchecked_Loop_Condition__char_console_22_goodG2BGlobal; void CWE606_Unchecked_Loop_Condition__char_console_22_goodB2G1Sink(char * data) else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { } void CWE606_Unchecked_Loop_Condition__char_console_22_goodB2G2Sink(char * data) if(CWE606_Unchecked_Loop_Condition__char_console_22_goodB2G2Global) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { } void CWE606_Unchecked_Loop_Condition__char_console_22_goodG2BSink(char * data) if(CWE606_Unchecked_Loop_Condition__char_console_22_goodG2BGlobal) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_74a.cpp", "text": "char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodB2G() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_74a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_81_goodB2G.cpp", "text": "/* * @description * CWE: 606 Unchecked Input For Loop Condition * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE606_Unchecked_Loop_Condition__char_listen_socket_81 { void CWE606_Unchecked_Loop_Condition__char_listen_socket_81_goodB2G::action(char * data) const { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_62a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_62a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2BSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_66a.c", "text": "void CWE606_Unchecked_Loop_Condition__char_console_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_73a.cpp", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_73a.cpp", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_81_goodB2G.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE606_Unchecked_Loop_Condition__char_file_81 { void CWE606_Unchecked_Loop_Condition__char_file_81_goodB2G::action(char * data) const { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_73b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_73b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_73b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void goodB2GSink(list<char *> dataList) { char * data = dataList.back(); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_66a.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_66b_badSink(wchar_t * dataArray[]); void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_66_bad() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_66a.c", "text": "wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); dataArray[2] = data; } void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_66b_goodB2GSink(wchar_t * dataArray[]); static void goodB2G() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_14.c", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_file_14_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_14.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_14.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_14.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(globalFive==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_14.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalFive==5) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_16.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); { { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_82_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE606_Unchecked_Loop_Condition__char_environment_82 { void CWE606_Unchecked_Loop_Condition__char_environment_82_goodG2B::action(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_18.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_18_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_18.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); goto sink; sink: { --data; int64_t result = data; static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_34.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) { short unionFirst; short unionSecond; } CWE191_Integer_Underflow__short_fscanf_predec_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_34_bad() { short data; CWE191_Integer_Underflow__short_fscanf_predec_34_unionType myUnion; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_34.c", "text": "{ short unionFirst; short unionSecond; } CWE191_Integer_Underflow__short_fscanf_predec_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_34_bad() { short data; CWE191_Integer_Underflow__short_fscanf_predec_34_unionType myUnion; data = 0; fscanf (stdin, \"%hd\", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { --data; short result = data; static void goodG2B() { short data; CWE191_Integer_Underflow__short_fscanf_predec_34_unionType myUnion; data = 0; data = -2; myUnion.unionFirst = data; { short data = myUnion.unionSecond; { --data; short result = data; static void goodB2G() { short data; CWE191_Integer_Underflow__short_fscanf_predec_34_unionType myUnion; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_42.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static unsigned int badSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_42.c", "text": "#ifndef OMITBAD static unsigned int badSource(unsigned int data) { fscanf (stdin, \"%u\", &data); return data; } void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_42_bad() { unsigned int data; data = 0; data = badSource(data); { --data; unsigned int result = data; #ifndef OMITGOOD static unsigned int goodG2BSource(unsigned int data) { data = -2; return data; static void goodG2B() { unsigned int data; data = 0; data = goodG2BSource(data); { --data; unsigned int result = data; } static unsigned int goodB2GSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_goodG2BSink; } void CWE191_Integer_Underflow__int_fscanf_predec_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_goodB2GSink;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data); funcPtr(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_goodG2BSink; data = 0; data = -2; funcPtr(data); } void CWE191_Integer_Underflow__int_fscanf_predec_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_predec_65b_goodB2GSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_12.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { --data; int result = data; else { if (data > INT_MIN) { --data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_12.c", "text": "data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { --data; int result = data; else { if (data > INT_MIN) { --data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); } else { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_09.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_predec_09_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_09.c", "text": "fscanf (stdin, \"%c\", &data); if(GLOBAL_CONST_TRUE) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_09.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_09_bad() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%c\", &data); if(GLOBAL_CONST_TRUE) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { --data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_16.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_16_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_16.c", "text": "fscanf (stdin, \"%u\", &data); while(1) { { --data; unsigned int result = data; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_53a.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_predec_53b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_53_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_53a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_53b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_53_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_predec_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int64_t_fscanf_predec_53b_goodG2BSink(int64_t data); static void goodG2B() { int64_t data; data = 0LL; data = -2; CWE191_Integer_Underflow__int64_t_fscanf_predec_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__int64_t_fscanf_predec_53b_goodB2GSink(int64_t data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_16.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_16_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_16.c", "text": "fscanf (stdin, \"%hd\", &data); while(1) { { --data; short result = data; static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_54a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_54a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_54a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_54_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_predec_54b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_54b_goodG2BSink(int data); data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_predec_54b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_predec_54b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_54a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int_fscanf_predec_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_predec_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_predec_54b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_54b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_predec_54b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_predec_54b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_10.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_10_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_10.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(globalTrue) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_10.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_predec_10_bad() { int64_t data; data = 0LL; if(globalTrue) { fscanf (stdin, \"%\" SCNd64, &data); if(globalTrue) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; if(globalTrue) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { --data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_03.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_03_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_03.c", "text": "fscanf (stdin, \"%hd\", &data); if(5==5) { { --data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_03.c", "text": "void CWE191_Integer_Underflow__short_fscanf_predec_03_bad() { short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); if(5==5) { { --data; short result = data; static void goodB2G1() { short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { --data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_02.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_predec_02_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_02.c", "text": "fscanf (stdin, \"%c\", &data); if(1) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_02.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_02_bad() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); if(1) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { --data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_07.c", "text": "data = 0; if(staticFive==5) { fscanf(stdin, \"%d\", &data); if(staticFive==5) { { --data; int result = data; static void goodB2G1() { int data; data = 0; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_07.c", "text": "if(staticFive==5) { fscanf(stdin, \"%d\", &data); if(staticFive==5) { { --data; int result = data; static void goodB2G1() { int data; data = 0; if(staticFive==5) { fscanf(stdin, \"%d\", &data); else { if (data > INT_MIN) { --data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_11.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_predec_11_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_11.c", "text": "fscanf (stdin, \"%c\", &data); if(globalReturnsTrue()) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_11.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_11_bad() { char data; data = ' '; if(globalReturnsTrue()) { fscanf (stdin, \"%c\", &data); if(globalReturnsTrue()) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; if(globalReturnsTrue()) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { --data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10.c", "text": "fscanf (stdin, \"%u\", &data); if(globalTrue) { { --data; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_10_bad() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); if(globalTrue) { { --data; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { --data; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_04.c", "text": "data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } if(STATIC_CONST_TRUE) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_04.c", "text": "if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } if(STATIC_CONST_TRUE) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_53a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_sub_53b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_53_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_53a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_sub_53b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_53_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_53a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_sub_53b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_53_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_sub_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_sub_53b_goodG2BSink(int data); data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_sub_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_sub_53b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_53a.c", "text": "* Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int_fscanf_sub_53b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_53_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_sub_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_sub_53b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_sub_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_sub_53b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_11.c", "text": "data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(globalReturnsTrue()) { { int result = data - 1; static void goodB2G1() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_11.c", "text": "{ int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(globalReturnsTrue()) { { int result = data - 1; static void goodB2G1() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); else { if (data > INT_MIN) { int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_18.c", "text": "data = 0; goto source; source: fscanf(stdin, \"%d\", &data); goto sink; sink: if(data < 0) { int result = data * 2; static void goodB2G() { int data; data = 0; goto source; source: fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_21.c", "text": "static int badStatic = 0; static void badSink(int data) if(badStatic) { { int result = data - 1; } } void CWE191_Integer_Underflow__int_fscanf_sub_21_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_21.c", "text": "static int badStatic = 0; static void badSink(int data) if(badStatic) { { int result = data - 1; } } void CWE191_Integer_Underflow__int_fscanf_sub_21_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(int data) else { if (data > INT_MIN) { int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_21.c", "text": "else { if (data > INT_MIN) { int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(int data) if(goodB2G2Static) { if (data > INT_MIN) { int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_06.c", "text": "data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } if(STATIC_CONST_FIVE==5) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_06.c", "text": "if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } if(STATIC_CONST_FIVE==5) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_14.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_14_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_14.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { short result = data - 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_14.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_14_bad() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { short result = data - 1; static void goodB2G1() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_04.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #include \"std_testcase.h\" /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_04_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_04.c", "text": "fscanf (stdin, \"%hd\", &data); if(STATIC_CONST_TRUE) { { short result = data - 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_04.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); if(STATIC_CONST_TRUE) { { short result = data - 1; static void goodB2G1() { short data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_21.c", "text": "static int badStatic = 0; static void badSink(short data) if(badStatic) { { short result = data - 1; } } void CWE191_Integer_Underflow__short_fscanf_sub_21_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_21.c", "text": "* GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow static int badStatic = 0; static void badSink(short data) if(badStatic) { { short result = data - 1; } } void CWE191_Integer_Underflow__short_fscanf_sub_21_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(short data) else { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_21.c", "text": "static int goodG2BStatic = 0; static void goodB2G1Sink(short data) else { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(short data) if(goodB2G2Static) { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_05.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_multiply_05_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_05.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_multiply_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); } if(staticTrue) { if(data < 0) { short result = data * 2; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_05.c", "text": "void CWE191_Integer_Underflow__short_fscanf_multiply_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); } if(staticTrue) { if(data < 0) { short result = data * 2; static void goodB2G1() { short data; data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); } else { if(data < 0) { if (data > (SHRT_MIN/2)) { short result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_61b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_61b.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD short CWE191_Integer_Underflow__short_fscanf_multiply_61b_badSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_61b.c", "text": "fscanf (stdin, \"%hd\", &data); return data; #ifndef OMITGOOD short CWE191_Integer_Underflow__short_fscanf_multiply_61b_goodG2BSource(short data) { data = -2; return data; } short CWE191_Integer_Underflow__short_fscanf_multiply_61b_goodB2GSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_72a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_72a.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__short_fscanf_multiply_72 void bad() { short data; vector<short> dataVector; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_72a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__short_fscanf_multiply_72 void bad() { short data; vector<short> dataVector; data = 0; fscanf (stdin, \"%hd\", &data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { short data; vector<short> dataVector; data = 0; data = -2; dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodB2G() { short data; vector<short> dataVector; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_33.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__short_fscanf_multiply_33 void bad() { short data; short &dataRef = data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_33.cpp", "text": "* Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__short_fscanf_multiply_33 void bad() { short data; short &dataRef = data; data = 0; fscanf (stdin, \"%hd\", &data); { short data = dataRef; if(data < 0) { short result = data * 2; static void goodG2B() { short data; short &dataRef = data; data = 0; data = -2; { short data = dataRef; if(data < 0) { short result = data * 2; static void goodB2G() { short data; short &dataRef = data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_18.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_18_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_18.c", "text": "fscanf (stdin, \"%hd\", &data); goto sink; sink: { short result = data - 1; static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_13.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_multiply_13_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_13.c", "text": "fscanf (stdin, \"%hd\", &data); } if(GLOBAL_CONST_FIVE==5) { if(data < 0) { short result = data * 2; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_13.c", "text": "void CWE191_Integer_Underflow__short_fscanf_multiply_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); } if(GLOBAL_CONST_FIVE==5) { if(data < 0) { short result = data * 2; static void goodB2G1() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); } else { if(data < 0) { if (data > (SHRT_MIN/2)) { short result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_32.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_32_bad() { unsigned int data; unsigned int *dataPtr1 = &data; unsigned int *dataPtr2 = &data; data = 0; { unsigned int data = *dataPtr1; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_32.c", "text": "unsigned int *dataPtr2 = &data; data = 0; { unsigned int data = *dataPtr1; fscanf (stdin, \"%u\", &data); *dataPtr1 = data; } { unsigned int data = *dataPtr2; { unsigned int result = data - 1; static void goodG2B() { unsigned int data; unsigned int *dataPtr1 = &data; unsigned int *dataPtr2 = &data; data = 0; { unsigned int data = *dataPtr1; data = -2; *dataPtr1 = data; } { unsigned int data = *dataPtr2; { unsigned int result = data - 1; static void goodB2G() { unsigned int data; unsigned int *dataPtr1 = &data; unsigned int *dataPtr2 = &data; data = 0; { unsigned int data = *dataPtr1; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09.c", "text": "fscanf (stdin, \"%u\", &data); if(GLOBAL_CONST_TRUE) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_09_bad() { unsigned int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%u\", &data); if(GLOBAL_CONST_TRUE) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_68a.c", "text": "void CWE191_Integer_Underflow__short_fscanf_multiply_68b_badSink(); void CWE191_Integer_Underflow__short_fscanf_multiply_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_68a.c", "text": "* Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" short CWE191_Integer_Underflow__short_fscanf_multiply_68_badData; short CWE191_Integer_Underflow__short_fscanf_multiply_68_goodG2BData; short CWE191_Integer_Underflow__short_fscanf_multiply_68_goodB2GData; #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_multiply_68b_badSink(); void CWE191_Integer_Underflow__short_fscanf_multiply_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE191_Integer_Underflow__short_fscanf_multiply_68_badData = data; CWE191_Integer_Underflow__short_fscanf_multiply_68b_badSink(); #ifndef OMITGOOD void CWE191_Integer_Underflow__short_fscanf_multiply_68b_goodG2BSink(); void CWE191_Integer_Underflow__short_fscanf_multiply_68b_goodB2GSink(); static void goodG2B() { short data; data = 0; data = -2; CWE191_Integer_Underflow__short_fscanf_multiply_68_goodG2BData = data; CWE191_Integer_Underflow__short_fscanf_multiply_68b_goodG2BSink(); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_31.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_31_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_31.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_31_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); { unsigned int dataCopy = data; unsigned int data = dataCopy; { unsigned int result = data - 1; static void goodG2B() { unsigned int data; data = 0; data = -2; { unsigned int dataCopy = data; unsigned int data = dataCopy; { unsigned int result = data - 1; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_65a.c", "text": "void CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink(short data); void CWE191_Integer_Underflow__short_fscanf_sub_65_bad() { short data; void (*funcPtr) (short) = CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_65a.c", "text": "* Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink(short data); void CWE191_Integer_Underflow__short_fscanf_sub_65_bad() { short data; void (*funcPtr) (short) = CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink; data = 0; fscanf (stdin, \"%hd\", &data); funcPtr(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__short_fscanf_sub_65b_goodG2BSink(short data); static void goodG2B() { short data; void (*funcPtr) (short) = CWE191_Integer_Underflow__short_fscanf_sub_65b_goodG2BSink; data = 0; data = -2; funcPtr(data); } void CWE191_Integer_Underflow__short_fscanf_sub_65b_goodB2GSink(short data); static void goodB2G() { short data; void (*funcPtr) (short) = CWE191_Integer_Underflow__short_fscanf_sub_65b_goodB2GSink; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #include \"std_testcase.h\" /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04.c", "text": "fscanf (stdin, \"%u\", &data); if(STATIC_CONST_TRUE) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_04_bad() { unsigned int data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%u\", &data); if(STATIC_CONST_TRUE) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_21.c", "text": "static int badStatic = 0; static void badSink(unsigned int data) if(badStatic) { { unsigned int result = data - 1; } } void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_21_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_21.c", "text": "* GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow static int badStatic = 0; static void badSink(unsigned int data) if(badStatic) { { unsigned int result = data - 1; } } void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_21_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(unsigned int data) else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_21.c", "text": "static int goodG2BStatic = 0; static void goodB2G1Sink(unsigned int data) else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(unsigned int data) if(goodB2G2Static) { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE191_Integer_Underflow__short_fscanf_sub_82.h\" namespace CWE191_Integer_Underflow__short_fscanf_sub_82 void bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE191_Integer_Underflow__short_fscanf_sub_82.h\" namespace CWE191_Integer_Underflow__short_fscanf_sub_82 void bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE191_Integer_Underflow__short_fscanf_sub_82_base* baseObject = new CWE191_Integer_Underflow__short_fscanf_sub_82_bad; baseObject->action(data); static void goodG2B() { short data; data = 0; data = -2; CWE191_Integer_Underflow__short_fscanf_sub_82_base* baseObject = new CWE191_Integer_Underflow__short_fscanf_sub_82_goodG2B; baseObject->action(data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_postdec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_postdec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_postdec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodG2BSink; } void CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodB2GSink;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_postdec_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data); funcPtr(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodG2BSink; data = 0; data = -2; funcPtr(data); } void CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_postdec_65b_goodB2GSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_51a.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_postdec_51b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_postdec_51_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_51a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_postdec_51b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_postdec_51_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_postdec_51b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int64_t_fscanf_postdec_51b_goodG2BSink(int64_t data); static void goodG2B() { int64_t data; data = 0LL; data = -2; CWE191_Integer_Underflow__int64_t_fscanf_postdec_51b_goodG2BSink(data); } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_51b_goodB2GSink(int64_t data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_12.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_postdec_12_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_12.c", "text": "* GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_postdec_12_bad() { int64_t data; data = 0LL; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%\" SCNd64, &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { data--; int64_t result = data; else { if (data > LLONG_MIN) { data--; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_12.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_postdec_12_bad() { int64_t data; data = 0LL; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%\" SCNd64, &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { data--; int64_t result = data; else { if (data > LLONG_MIN) { data--; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int64_t data; data = 0LL; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%\" SCNd64, &data); fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_06.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #include \"std_testcase.h\" /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_postdec_06_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_06.c", "text": "fscanf (stdin, \"%c\", &data); if(STATIC_CONST_FIVE==5) { { data--; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_06.c", "text": "void CWE191_Integer_Underflow__char_fscanf_postdec_06_bad() { char data; data = ' '; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%c\", &data); if(STATIC_CONST_FIVE==5) { { data--; char result = data; static void goodB2G1() { char data; data = ' '; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { data--; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_68a.c", "text": "void CWE191_Integer_Underflow__short_fscanf_postdec_68b_badSink(); void CWE191_Integer_Underflow__short_fscanf_postdec_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_68a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" short CWE191_Integer_Underflow__short_fscanf_postdec_68_badData; short CWE191_Integer_Underflow__short_fscanf_postdec_68_goodG2BData; short CWE191_Integer_Underflow__short_fscanf_postdec_68_goodB2GData; #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_postdec_68b_badSink(); void CWE191_Integer_Underflow__short_fscanf_postdec_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE191_Integer_Underflow__short_fscanf_postdec_68_badData = data; CWE191_Integer_Underflow__short_fscanf_postdec_68b_badSink(); #ifndef OMITGOOD void CWE191_Integer_Underflow__short_fscanf_postdec_68b_goodG2BSink(); void CWE191_Integer_Underflow__short_fscanf_postdec_68b_goodB2GSink(); static void goodG2B() { short data; data = 0; data = -2; CWE191_Integer_Underflow__short_fscanf_postdec_68_goodG2BData = data; CWE191_Integer_Underflow__short_fscanf_postdec_68b_goodG2BSink(); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_04.c", "text": "data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_TRUE) { { data--; int result = data; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_04.c", "text": "if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_TRUE) { { data--; int result = data; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); else { if (data > INT_MIN) { data--; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_21.c", "text": "static int badStatic = 0; static void badSink(int64_t data) if(badStatic) { { data--; int64_t result = data; } } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_21_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_21.c", "text": "static int badStatic = 0; static void badSink(int64_t data) if(badStatic) { { data--; int64_t result = data; } } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_21_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(int64_t data) else { if (data > LLONG_MIN) { data--; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_21.c", "text": "else { if (data > LLONG_MIN) { data--; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(int64_t data) if(goodB2G2Static) { if (data > LLONG_MIN) { data--; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_17.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_postdec_17_bad() { int i,j; short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_17.c", "text": "fscanf (stdin, \"%hd\", &data); for(j = 0; j < 1; j++) { { data--; short result = data; static void goodB2G() { int i,k; short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_09.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_postdec_09_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_09.c", "text": "fscanf (stdin, \"%hd\", &data); if(GLOBAL_CONST_TRUE) { { data--; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_09.c", "text": "void CWE191_Integer_Underflow__short_fscanf_postdec_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); if(GLOBAL_CONST_TRUE) { { data--; short result = data; static void goodB2G1() { short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { data--; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45.c", "text": "data--; unsigned int result = data; } } void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45_badData = data; static void goodG2BSink() { unsigned int data = CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45_goodG2BData; { data--; unsigned int result = data; static void goodG2B() { unsigned int data; data = 0; data = -2; CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45_goodG2BData = data; static void goodB2GSink() { unsigned int data = CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_45_goodB2GData; if (data > 0) { data--; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_65a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_postdec_65b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_postdec_65_bad() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_postdec_65b_badSink; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_65a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_postdec_65b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_postdec_65_bad() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_postdec_65b_badSink; data = ' '; fscanf (stdin, \"%c\", &data); funcPtr(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_postdec_65b_goodG2BSink(char data); static void goodG2B() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_postdec_65b_goodG2BSink; data = ' '; data = -2; funcPtr(data); } void CWE191_Integer_Underflow__char_fscanf_postdec_65b_goodB2GSink(char data); static void goodB2G() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_postdec_65b_goodB2GSink; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_16.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_16_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_16.c", "text": "fscanf (stdin, \"%u\", &data); while(1) { { data--; unsigned int result = data; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_18.c", "text": "data = 0; goto source; source: fscanf(stdin, \"%d\", &data); goto sink; sink: { data--; int result = data; static void goodB2G() { int data; data = 0; goto source; source: fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_31.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_postdec_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_31.c", "text": "* GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_postdec_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); { char dataCopy = data; char data = dataCopy; { data--; char result = data; static void goodG2B() { char data; data = ' '; data = -2; { char dataCopy = data; char data = dataCopy; { data--; char result = data; static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_42.c", "text": "fscanf(stdin, \"%d\", &data); return data; } void CWE191_Integer_Underflow__int_fscanf_postdec_42_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_42.c", "text": "{ fscanf(stdin, \"%d\", &data); return data; } void CWE191_Integer_Underflow__int_fscanf_postdec_42_bad() { int data; data = 0; data = badSource(data); { data--; int result = data; #ifndef OMITGOOD static int goodG2BSource(int data) { data = -2; return data; static void goodG2B() { int data; data = 0; data = goodG2BSource(data); { data--; int result = data; } static int goodB2GSource(int data) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_03.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_03_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_03.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(5==5) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_03.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_03_bad() { int64_t data; data = 0LL; if(5==5) { fscanf (stdin, \"%\" SCNd64, &data); if(5==5) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; if(5==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { int64_t result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_72a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_72a.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__char_fscanf_multiply_72 void bad() { char data; vector<char> dataVector; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_72a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__char_fscanf_multiply_72 void bad() { char data; vector<char> dataVector; data = ' '; fscanf (stdin, \"%c\", &data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char data; vector<char> dataVector; data = ' '; data = -2; dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodB2G() { char data; vector<char> dataVector; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_45.c", "text": "{ char result = data * 2; } } void CWE191_Integer_Underflow__char_fscanf_multiply_45_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_45.c", "text": "char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_multiply_45_badData = data; static void goodG2BSink() { char data = CWE191_Integer_Underflow__char_fscanf_multiply_45_goodG2BData; if(data < 0) { char result = data * 2; static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_multiply_45_goodG2BData = data; static void goodB2GSink() { char data = CWE191_Integer_Underflow__char_fscanf_multiply_45_goodB2GData; if(data < 0) { if (data > (CHAR_MIN/2)) { char result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_41.c", "text": "{ char result = data * 2; } } void CWE191_Integer_Underflow__char_fscanf_multiply_41_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_41.c", "text": "data = ' '; fscanf (stdin, \"%c\", &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(char data) { if(data < 0) { char result = data * 2; static void goodG2B() { char data; data = ' '; data = -2; goodG2BSink(data); } static void goodB2GSink(char data) { if(data < 0) { if (data > (CHAR_MIN/2)) { char result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badGlobal = 1; CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badSink(data); #ifndef OMITGOOD int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G1Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G2Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodG2BGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G1Sink(int64_t data); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badGlobal = 1; CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_badSink(data); #ifndef OMITGOOD int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G1Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G2Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodG2BGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G1Sink(int64_t data); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G1Global = 0; CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G1Sink(data); } void CWE191_Integer_Underflow__int64_t_fscanf_multiply_22_goodB2G2Sink(int64_t data); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_44.c", "text": "int64_t result = data - 1; } } void CWE191_Integer_Underflow__int64_t_fscanf_sub_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_44.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int64_t data) { { int64_t result = data - 1; static void goodG2B() { int64_t data; void (*funcPtr) (int64_t) = goodG2BSink; data = 0LL; data = -2; funcPtr(data); } static void goodB2GSink(int64_t data) { if (data > LLONG_MIN) { int64_t result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G() { int64_t data; void (*funcPtr) (int64_t) = goodB2GSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_14.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_14_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_14.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(globalFive==5) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_14.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_14_bad() { int64_t data; data = 0LL; if(globalFive==5) { fscanf (stdin, \"%\" SCNd64, &data); if(globalFive==5) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; if(globalFive==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { int64_t result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_81a.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #include <inttypes.h> #include \"std_testcase.h\" #include \"CWE191_Integer_Underflow__int64_t_fscanf_sub_81.h\" namespace CWE191_Integer_Underflow__int64_t_fscanf_sub_81 void bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_81a.cpp", "text": "fscanf (stdin, \"%\" SCNd64, &data); const CWE191_Integer_Underflow__int64_t_fscanf_sub_81_base& baseObject = CWE191_Integer_Underflow__int64_t_fscanf_sub_81_bad(); baseObject.action(data); static void goodG2B() { int64_t data; data = 0LL; data = -2; const CWE191_Integer_Underflow__int64_t_fscanf_sub_81_base& baseObject = CWE191_Integer_Underflow__int64_t_fscanf_sub_81_goodG2B(); baseObject.action(data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_17.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_17_bad() { int i,j; int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_17.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); } for(j = 0; j < 1; j++) { if(data < 0) { int64_t result = data * 2; static void goodB2G() { int i,k; int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_13.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_13_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_13.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); } if(GLOBAL_CONST_FIVE==5) { if(data < 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_13.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_multiply_13_bad() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); } if(GLOBAL_CONST_FIVE==5) { if(data < 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); } else { if(data < 0) { if (data > (LLONG_MIN/2)) { int64_t result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_53a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_multiply_53b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_multiply_53_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_53a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_multiply_53b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_multiply_53_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_multiply_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_multiply_53b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_multiply_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__char_fscanf_multiply_53b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_82a.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #include <inttypes.h> #include \"std_testcase.h\" #include \"CWE191_Integer_Underflow__int64_t_fscanf_sub_82.h\" namespace CWE191_Integer_Underflow__int64_t_fscanf_sub_82 void bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_82a.cpp", "text": "fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_sub_82_base* baseObject = new CWE191_Integer_Underflow__int64_t_fscanf_sub_82_bad; baseObject->action(data); static void goodG2B() { int64_t data; data = 0LL; data = -2; CWE191_Integer_Underflow__int64_t_fscanf_sub_82_base* baseObject = new CWE191_Integer_Underflow__int64_t_fscanf_sub_82_goodG2B; baseObject->action(data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_02.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_02_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_02.c", "text": "fscanf (stdin, \"%c\", &data); if(1) { { char result = data - 1; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_02.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_02_bad() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); if(1) { { char result = data - 1; static void goodB2G1() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { char result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_09.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_multiply_09_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_09.c", "text": "fscanf (stdin, \"%c\", &data); } if(GLOBAL_CONST_TRUE) { if(data < 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_09.c", "text": "void CWE191_Integer_Underflow__char_fscanf_multiply_09_bad() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%c\", &data); } if(GLOBAL_CONST_TRUE) { if(data < 0) { char result = data * 2; static void goodB2G1() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%c\", &data); } else { if(data < 0) { if (data > (CHAR_MIN/2)) { char result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_66a.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_sub_66b_badSink(int64_t dataArray[]); void CWE191_Integer_Underflow__int64_t_fscanf_sub_66_bad() { int64_t data; int64_t dataArray[5]; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_66a.c", "text": "* Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_66b_badSink(int64_t dataArray[]); void CWE191_Integer_Underflow__int64_t_fscanf_sub_66_bad() { int64_t data; int64_t dataArray[5]; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); dataArray[2] = data; CWE191_Integer_Underflow__int64_t_fscanf_sub_66b_badSink(dataArray); #ifndef OMITGOOD void CWE191_Integer_Underflow__int64_t_fscanf_sub_66b_goodG2BSink(int64_t dataArray[]); static void goodG2B() { int64_t data; int64_t dataArray[5]; data = 0LL; data = -2; dataArray[2] = data; CWE191_Integer_Underflow__int64_t_fscanf_sub_66b_goodG2BSink(dataArray); } void CWE191_Integer_Underflow__int64_t_fscanf_sub_66b_goodB2GSink(int64_t dataArray[]); static void goodB2G() { int64_t data; int64_t dataArray[5]; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE191_Integer_Underflow__char_fscanf_multiply_82.h\" namespace CWE191_Integer_Underflow__char_fscanf_multiply_82 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE191_Integer_Underflow__char_fscanf_multiply_82.h\" namespace CWE191_Integer_Underflow__char_fscanf_multiply_82 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_multiply_82_base* baseObject = new CWE191_Integer_Underflow__char_fscanf_multiply_82_bad; baseObject->action(data); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_multiply_82_base* baseObject = new CWE191_Integer_Underflow__char_fscanf_multiply_82_goodG2B; baseObject->action(data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_31.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_multiply_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_31.c", "text": "* GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_multiply_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); { char dataCopy = data; char data = dataCopy; if(data < 0) { char result = data * 2; static void goodG2B() { char data; data = ' '; data = -2; { char dataCopy = data; char data = dataCopy; if(data < 0) { char result = data * 2; static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_54a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_sub_54b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_sub_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_54a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_54b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_sub_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_sub_54b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_sub_54b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_sub_54b_goodG2BSink(data); } void CWE191_Integer_Underflow__char_fscanf_sub_54b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_02.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_02_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_02.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(1) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_02.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_02_bad() { int64_t data; data = 0LL; if(1) { fscanf (stdin, \"%\" SCNd64, &data); if(1) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; if(1) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { int64_t result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_54a.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_multiply_54b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_multiply_54_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_54a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_54b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_multiply_54_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_multiply_54b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_54b_goodG2BSink(int64_t data); static void goodG2B() { int64_t data; data = 0LL; data = -2; CWE191_Integer_Underflow__int64_t_fscanf_multiply_54b_goodG2BSink(data); } void CWE191_Integer_Underflow__int64_t_fscanf_multiply_54b_goodB2GSink(int64_t data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_01.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_01_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_01.c", "text": "fscanf (stdin, \"%c\", &data); { char result = data - 1; static void goodG2B() { char data; data = ' '; data = -2; { char result = data - 1; static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_05.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_05_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_05.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { char result = data - 1; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_05.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { char result = data - 1; static void goodB2G1() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { char result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptHashData_09.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(GLOBAL_CONST_TRUE) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptHashData_09.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(GLOBAL_CONST_TRUE) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptHashData_09.c", "text": "do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); if(GLOBAL_CONST_TRUE) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptCreateHash_10.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(globalTrue) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptCreateHash_10.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(globalTrue) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptCreateHash_10.c", "text": "{ break; } { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); if(globalTrue) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptCreateHash_08.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(staticReturnsTrue()) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptCreateHash_08.c", "text": "{ break; } { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); if(staticReturnsTrue()) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptHashData_02.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(1) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptHashData_02.c", "text": "do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); if(1) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE222_Truncation_of_Security_Relevant_Information/CWE222_Truncation_of_Security_Relevant_Information__w32_09.c", "text": "* @description * CWE: 222 Truncation of Security Relevant Information * Sinks: * GoodSink: Log the complete username SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; HANDLE pHandle; char username[USERNAME_SIZE+1]; char truncatedUsername[TRUNCATED_USERNAME_SIZE+1]; { break; } if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0)) { break; } username[USERNAME_SIZE] = '\\0'; memcpy(truncatedUsername, username, sizeof(truncatedUsername));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE222_Truncation_of_Security_Relevant_Information/CWE222_Truncation_of_Security_Relevant_Information__w32_09.c", "text": "* @description * CWE: 222 Truncation of Security Relevant Information * Sinks: * GoodSink: Log the complete username WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; HANDLE pHandle; char username[USERNAME_SIZE+1]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))", "label": 1}
{"id": null, "file": "../../C/testcases/CWE222_Truncation_of_Security_Relevant_Information/CWE222_Truncation_of_Security_Relevant_Information__w32_09.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0)) { break; } username[USERNAME_SIZE] = '\\0'; memcpy(truncatedUsername, username, sizeof(truncatedUsername)); truncatedUsername[TRUNCATED_USERNAME_SIZE] = '\\0'; } } while (0); if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; HANDLE pHandle; char username[USERNAME_SIZE+1]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))", "label": 1}
{"id": null, "file": "../../C/testcases/CWE222_Truncation_of_Security_Relevant_Information/CWE222_Truncation_of_Security_Relevant_Information__w32_09.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0)) { break; } username[USERNAME_SIZE] = '\\0'; if (LogonUserA( username, } } while (0); if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; HANDLE pHandle; char username[USERNAME_SIZE+1]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))", "label": 1}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s04/CWE762_Mismatched_Memory_Management_Routines__malloc_delete_array_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = (char *)malloc(strlen(name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s04/CWE762_Mismatched_Memory_Management_Routines__malloc_delete_array_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = (char *)malloc(strlen(name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~BadClass() { delete [] name; } BadClass(BadClass &badClassObject) { this->name = (char *)malloc(strlen(badClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s04/CWE762_Mismatched_Memory_Management_Routines__malloc_delete_array_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = (char *)malloc(strlen(name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~BadClass() { delete [] name; } BadClass(BadClass &badClassObject) { this->name = (char *)malloc(strlen(badClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name); } BadClass& operator=(const BadClass &badClassObject) { if (&badClassObject != this) { this->name = (char *)malloc(strlen(badClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s01/CWE762_Mismatched_Memory_Management_Routines__calloc_delete_array_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = (char *)calloc(strlen(name)+1, sizeof(char)); if (this->name == NULL) {exit(-1);} strcpy(this->name, name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s01/CWE762_Mismatched_Memory_Management_Routines__calloc_delete_array_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = (char *)calloc(strlen(name)+1, sizeof(char)); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~BadClass() { delete [] name; } BadClass(BadClass &badClassObject) { this->name = (char *) calloc(strlen(badClassObject.name)+1, sizeof(char)); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s01/CWE762_Mismatched_Memory_Management_Routines__calloc_delete_array_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = (char *)calloc(strlen(name)+1, sizeof(char)); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~BadClass() { delete [] name; } BadClass(BadClass &badClassObject) { this->name = (char *) calloc(strlen(badClassObject.name)+1, sizeof(char)); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name); } BadClass& operator=(const BadClass &badClassObject) { if (&badClassObject != this) { this->name = (char *) calloc(strlen(badClassObject.name)+1, sizeof(char)); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_54a.c", "text": "void CWE617_Reachable_Assertion__fscanf_54b_badSink(int data); void CWE617_Reachable_Assertion__fscanf_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_54a.c", "text": "void CWE617_Reachable_Assertion__fscanf_54b_badSink(int data); void CWE617_Reachable_Assertion__fscanf_54_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE617_Reachable_Assertion__fscanf_81.h\" namespace CWE617_Reachable_Assertion__fscanf_81", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE617_Reachable_Assertion__fscanf_81.h\" namespace CWE617_Reachable_Assertion__fscanf_81 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63a.c", "text": "void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63_bad() { char * password; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63a.c", "text": "void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63_bad() { char * password; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) } strcpy(password, \"Password1234!\"); CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63b_badSink(&password); #ifndef OMITGOOD void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63b_goodG2BSink(char * * password); static void goodG2B() { char * password; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14.c", "text": "void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14_bad() { char * password; password = \"\"; if(globalFive==5) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14.c", "text": "void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14_bad() { char * password; password = \"\"; if(globalFive==5) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) } strcpy(password, \"Password1234!\"); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); static void goodG2B1() { char * password; password = \"\"; } else { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14.c", "text": "{ char * password; password = \"\"; } else { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) exit(1); } strcpy(password, \"Password1234!\"); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); static void goodG2B2() { char * password; password = \"\"; if(globalFive==5) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_41.c", "text": "#ifndef OMITBAD void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_41_badSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_41_bad() { char * password; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_41.c", "text": "void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_41_bad() { char * password; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) } strcpy(password, \"Password1234!\"); CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_41_badSink(password); #ifndef OMITGOOD void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_41_goodG2BSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); static void goodG2B() { char * password; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 0}
