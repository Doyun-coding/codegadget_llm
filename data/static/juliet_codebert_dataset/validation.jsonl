{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_66a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_66_bad() { char * data; char * dataArray[5]; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_66a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_66_bad() { char * data; char * dataArray[5]; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); dataArray[2] = data; static void goodB2G() { char * data; char * dataArray[5]; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64a.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64a.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_badSink(&data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_65a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_65b_badSink(wchar_t * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_65b_badSink; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_65a.c", "text": "{ CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } funcPtr(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_65b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_65b_goodB2GSink; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_83_goodB2G.cpp", "text": "{ CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_83_goodB2G::CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_83_goodB2G(char * dataCopy) { data = dataCopy; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_12.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); { { size_t i; for (i=0; i < strlen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); both branches use the GoodSink */ static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_11.c", "text": "{ for (; *data != L'\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_05.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_05_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22a.c", "text": "int CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badGlobal = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22a.c", "text": "int CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badGlobal = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badGlobal = 1; CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badSink(data); int CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_goodB2G2Global = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22a.c", "text": "int CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badGlobal = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badGlobal = 1; CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_badSink(data); int CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_goodB2G2Global = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_goodB2G1Global = 0; CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_goodB2G1Sink(data); } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_01.c", "text": "{ CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_45.c", "text": "* Sinks: * GoodSink: free() memory correctly at the start of the buffer * BadSink : free() memory not at the start of the buffer * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_45_badData; for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_45_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_45.c", "text": "} #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_45_badData = data; static void goodB2GSink() { char * data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_45_goodB2GData; { size_t i; for (i=0; i < strlen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_15.c", "text": "case 6: for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_62b.cpp", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #ifndef OMITGOOD void goodB2GSource(wchar_t * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_62b.cpp", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); #ifndef OMITGOOD void goodB2GSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_41.c", "text": "* Sinks: * GoodSink: free() memory correctly at the start of the buffer * BadSink : free() memory not at the start of the buffer * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD static void badSink(wchar_t * data) { for (; *data != L'\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_41_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_41.c", "text": "#ifndef OMITGOOD static void goodB2GSink(wchar_t * data) { { size_t i; for (i=0; i < wcslen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); static void goodB2G() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_34.c", "text": "} #endif } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; for (; *data != L'\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { wchar_t * data; CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_34_unionType myUnion; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_51a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_51b_badSink(wchar_t * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_51_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_51a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_51b_badSink(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_51b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53b_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53a.c", "text": "#ifndef OMITBAD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53b_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53b_badSink(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_53b_goodB2GSink(char * data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_21.c", "text": "static int badStatic = 0; static void badSink(char * data) { for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_21_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_21.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } badStatic = 1; badSink(data); static int goodB2G2Static = 0; static void goodB2G1Sink(char * data) { { size_t i; for (i=0; i < strlen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); static void goodB2G1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_21.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(char * data) { { size_t i; for (i=0; i < strlen(data); i++) { if (data[i] == SEARCH_CHAR) break; } } free(data); static void goodB2G2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_64a.c", "text": "} } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_64b_badSink(&data); static void goodB2G() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_32.c", "text": "* memory block not at the start of the buffer */ for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_68a.c", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_68_badDataForBadSink = data; static void goodB2G() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54a.c", "text": "#ifndef OMITBAD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54b_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54a.c", "text": "#ifndef OMITBAD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54b_badSink(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING); CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54b_badSink(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_fixed_string_54b_goodB2GSink(char * data); static void goodB2G() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; strcpy(data, BAD_SOURCE_FIXED_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22a.c", "text": "int CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_badGlobal = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_badSink(wchar_t * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22a.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_badGlobal = 1; CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_badSink(data); int CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_goodB2G2Global = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_goodB2G1Sink(wchar_t * data); static void goodB2G1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22a.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_goodB2G1Global = 0; CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_goodB2G1Sink(data); } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_22_goodB2G2Sink(wchar_t * data); static void goodB2G2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_13.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_environment_13_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { for (; *data != '\\0'; data++) { if (*data == SEARCH_CHAR) break; } } free(data); static void goodB2G1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_66a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_66b_badSink(wchar_t * dataArray[]); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_66_bad() { wchar_t * data; wchar_t * dataArray[5]; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_66a.c", "text": "{ CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } dataArray[2] = data; #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_66b_goodB2GSink(wchar_t * dataArray[]); static void goodB2G() { wchar_t * data; wchar_t * dataArray[5]; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_52a.c", "text": "void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_52b_badSink(wchar_t * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_52_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE761_Free_Pointer_Not_at_Start_of_Buffer/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_52a.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_52b_badSink(data); #ifndef OMITGOOD void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_52b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_02.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_02_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_02.c", "text": "fscanf (stdin, \"%u\", &data); if(1) { { unsigned int result = data + 1; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_02.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_02_bad() { unsigned int data; data = 0; if(1) { fscanf (stdin, \"%u\", &data); if(1) { { unsigned int result = data + 1; static void goodB2G1() { unsigned int data; data = 0; if(1) { fscanf (stdin, \"%u\", &data); else { if (data < UINT_MAX) { unsigned int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD unsigned int CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b_badSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b.c", "text": "fscanf (stdin, \"%u\", &data); return data; #ifndef OMITGOOD unsigned int CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b_goodG2BSource(unsigned int data) { data = 2; return data; } unsigned int CWE190_Integer_Overflow__unsigned_int_fscanf_add_61b_goodB2GSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84_goodB2G.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84.h\" namespace CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84 { CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84_goodB2G::CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_84_goodB2G(unsigned int dataCopy) { data = dataCopy; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09.c", "text": "fscanf (stdin, \"%u\", &data); } if(GLOBAL_CONST_TRUE) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_09_bad() { unsigned int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%u\", &data); } if(GLOBAL_CONST_TRUE) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%u\", &data); } else { if(data > 0) { if (data < (UINT_MAX/2)) { unsigned int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_53a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_square_53b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_53_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_53a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_53b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_53_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_square_53b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_53b_goodG2BSink(unsigned int data); static void goodG2B() { unsigned int data; data = 0; data = 2; CWE190_Integer_Overflow__unsigned_int_fscanf_square_53b_goodG2BSink(data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_53b_goodB2GSink(unsigned int data); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_65a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_add_65_bad() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_badSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_65a.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_add_65_bad() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_badSink; data = 0; fscanf (stdin, \"%u\", &data); funcPtr(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_goodG2BSink(unsigned int data); static void goodG2B() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_goodG2BSink; data = 0; data = 2; funcPtr(data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_goodB2GSink(unsigned int data); static void goodB2G() { unsigned int data; void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_fscanf_add_65b_goodB2GSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_62b.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #include \"std_testcase.h\" namespace CWE190_Integer_Overflow__unsigned_int_fscanf_square_62 #ifndef OMITBAD void badSource(unsigned int &data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_62b.cpp", "text": "fscanf (stdin, \"%u\", &data); #ifndef OMITGOOD void goodG2BSource(unsigned int &data) { data = 2; } void goodB2GSource(unsigned int &data) fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__unsigned_int_fscanf_add_83.h\" namespace CWE190_Integer_Overflow__unsigned_int_fscanf_add_83 { CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad::CWE190_Integer_Overflow__unsigned_int_fscanf_add_83_bad(unsigned int dataCopy) { data = dataCopy; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22a.c", "text": "int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22a.c", "text": "int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badGlobal = 1; CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G1Sink(unsigned int data); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22a.c", "text": "int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badGlobal = 1; CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_badSink(data); #ifndef OMITGOOD int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G1Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G2Global = 0; int CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodG2BGlobal = 0; void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G1Sink(unsigned int data); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G1Global = 0; CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G1Sink(data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_22_goodB2G2Sink(unsigned int data); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { unsigned int data; data = 0; data = 2; CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_01.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_01_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_01.c", "text": "fscanf (stdin, \"%u\", &data); { unsigned int result = data * data; static void goodG2B() { unsigned int data; data = 0; data = 2; { unsigned int result = data * data; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02.c", "text": "fscanf (stdin, \"%u\", &data); } if(1) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_02_bad() { unsigned int data; data = 0; if(1) { fscanf (stdin, \"%u\", &data); } if(1) { if(data > 0) { unsigned int result = data * 2; static void goodB2G1() { unsigned int data; data = 0; if(1) { fscanf (stdin, \"%u\", &data); } else { if(data > 0) { if (data < (UINT_MAX/2)) { unsigned int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_square_54b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_54_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_54a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_54b_badSink(unsigned int data); void CWE190_Integer_Overflow__unsigned_int_fscanf_square_54_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_square_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_54b_goodG2BSink(unsigned int data); static void goodG2B() { unsigned int data; data = 0; data = 2; CWE190_Integer_Overflow__unsigned_int_fscanf_square_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_54b_goodB2GSink(unsigned int data); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__unsigned_int_fscanf_square_84.h\" #include <math.h> namespace CWE190_Integer_Overflow__unsigned_int_fscanf_square_84 { CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad::CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad(unsigned int dataCopy) { data = dataCopy; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_11_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c", "text": "fscanf (stdin, \"%u\", &data); if(globalReturnsTrue()) { { unsigned int result = data * data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_11_bad() { unsigned int data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%u\", &data); if(globalReturnsTrue()) { { unsigned int result = data * data; static void goodB2G1() { unsigned int data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%u\", &data); else { if (abs((long)data) < (long)sqrt((double)UINT_MAX)) { unsigned int result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_31.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_31_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_31.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_add_31_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); { unsigned int dataCopy = data; unsigned int data = dataCopy; { unsigned int result = data + 1; static void goodG2B() { unsigned int data; data = 0; data = 2; { unsigned int dataCopy = data; unsigned int data = dataCopy; { unsigned int result = data + 1; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_08.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_08_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_08.c", "text": "fscanf (stdin, \"%u\", &data); if(staticReturnsTrue()) { { unsigned int result = data * data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_08.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_08_bad() { unsigned int data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%u\", &data); if(staticReturnsTrue()) { { unsigned int result = data * data; static void goodB2G1() { unsigned int data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%u\", &data); else { if (abs((long)data) < (long)sqrt((double)UINT_MAX)) { unsigned int result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41.c", "text": "{ unsigned int result = data * 2; } } void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41.c", "text": "data = 0; fscanf (stdin, \"%u\", &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(unsigned int data) { if(data > 0) { unsigned int result = data * 2; static void goodG2B() { unsigned int data; data = 0; data = 2; goodG2BSink(data); } static void goodB2GSink(unsigned int data) { if(data > 0) { if (data < (UINT_MAX/2)) { unsigned int result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83_bad.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83.h\" namespace CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83 { CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83_bad::CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_83_bad(unsigned int dataCopy) { data = dataCopy; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_add_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_add_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_square_16.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_square_16_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s05/CWE190_Integer_Overflow__unsigned_int_fscanf_square_16.c", "text": "fscanf (stdin, \"%u\", &data); while(1) { { unsigned int result = data * data; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_84_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_84_goodB2G.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int64_t_fscanf_square_84.h\" #include <math.h> #include <inttypes.h> namespace CWE190_Integer_Overflow__int64_t_fscanf_square_84 { CWE190_Integer_Overflow__int64_t_fscanf_square_84_goodB2G::CWE190_Integer_Overflow__int64_t_fscanf_square_84_goodB2G(int64_t dataCopy) { data = dataCopy; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_square_10.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_10_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(globalTrue) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s02/CWE190_Integer_Overflow__int64_t_fscanf_square_10.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_square_10_bad() { int64_t data; data = 0LL; if(globalTrue) { fscanf (stdin, \"%\" SCNd64, &data); if(globalTrue) { { int64_t result = data * data; static void goodB2G1() { int64_t data; data = 0LL; if(globalTrue) { fscanf (stdin, \"%\" SCNd64, &data); else { if (imaxabs((intmax_t)data) <= sqrtl(LLONG_MAX)) { int64_t result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__int_fscanf_add_82", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__int_fscanf_add_82 void bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__int_fscanf_add_82 int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__int_fscanf_add_82_bad; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__int_fscanf_add_82_goodG2B;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82a.cpp", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer * */ #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__int_fscanf_add_82 void bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__int_fscanf_add_82_bad; baseObject->action(data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__int_fscanf_add_82_goodG2B; baseObject->action(data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_67a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_multiply_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_67a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_multiply_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_67a.c", "text": "#include \"std_testcase.h\" typedef struct _CWE190_Integer_Overflow__int_fscanf_multiply_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fscanf_multiply_67_structType; #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_multiply_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_multiply_67b_goodG2BSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_multiply_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__int_fscanf_multiply_67b_goodB2GSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_67a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); void CWE190_Integer_Overflow__int_fscanf_multiply_67_bad() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_multiply_67b_goodG2BSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct; data = 0; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__int_fscanf_multiply_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__int_fscanf_multiply_67b_goodB2GSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct); static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_53_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_53_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_53_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_53b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_53b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_53b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_add_53b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_53a.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_add_53b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_add_53_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_53b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_53b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_53b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_add_53b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_63a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_add_63_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_63a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_add_63_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_63a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_add_63_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_63b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_63b_goodG2BSink(int * data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_63b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_add_63b_goodB2GSink(int * data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_63a.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_add_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_add_63_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_63b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_63b_goodG2BSink(int * data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_63b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_add_63b_goodB2GSink(int * data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_84_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_06.c", "text": "data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_06.c", "text": "data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_FIVE==5) { { int result = data + 1; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_06.c", "text": "fscanf(stdin, \"%d\", &data); data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_06.c", "text": "{ int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_FIVE==5) { { int result = data + 1; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_listen_socket_multiply_07.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_83_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_83_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_square_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_square_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_add_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_add_64_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_add_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_add_64_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_64b_goodG2BSink(void * dataVoidPtr); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_add_64b_goodB2GSink(void * dataVoidPtr);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_64a.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_add_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_add_64_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_add_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_add_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_add_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_add_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_add_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_13.c", "text": "data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(GLOBAL_CONST_FIVE==5) { { int result = data + 1; static void goodB2G1() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_add_13.c", "text": "{ int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(GLOBAL_CONST_FIVE==5) { { int result = data + 1; static void goodB2G1() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { int result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s03/CWE190_Integer_Overflow__int_fscanf_multiply_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_multiply_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_63a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_multiply_63b_badSink(short * dataPtr); void CWE190_Integer_Overflow__short_fscanf_multiply_63_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_63a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_multiply_63b_badSink(short * dataPtr); void CWE190_Integer_Overflow__short_fscanf_multiply_63_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE190_Integer_Overflow__short_fscanf_multiply_63b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_multiply_63b_goodG2BSink(short * data); static void goodG2B() { short data; data = 0; data = 2; CWE190_Integer_Overflow__short_fscanf_multiply_63b_goodG2BSink(&data); } void CWE190_Integer_Overflow__short_fscanf_multiply_63b_goodB2GSink(short * data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_42.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static short badSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_42.c", "text": "* Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static short badSource(short data) { fscanf (stdin, \"%hd\", &data); return data; } void CWE190_Integer_Overflow__short_fscanf_square_42_bad() { short data; data = 0; data = badSource(data); { short result = data * data; #ifndef OMITGOOD static short goodG2BSource(short data) { data = 2; return data; static void goodG2B() { short data; data = 0; data = goodG2BSource(data); { short result = data * data; } static short goodB2GSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_67a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_square_67b_badSink(CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct); void CWE190_Integer_Overflow__short_fscanf_square_67_bad() { short data; CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_67a.c", "text": "typedef struct _CWE190_Integer_Overflow__short_fscanf_square_67_structType { short structFirst; } CWE190_Integer_Overflow__short_fscanf_square_67_structType; #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_square_67b_badSink(CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct); void CWE190_Integer_Overflow__short_fscanf_square_67_bad() { short data; CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__short_fscanf_square_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_square_67b_goodG2BSink(CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct); static void goodG2B() { short data; CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct; data = 0; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__short_fscanf_square_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__short_fscanf_square_67b_goodB2GSink(CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct); static void goodB2G() { short data; CWE190_Integer_Overflow__short_fscanf_square_67_structType myStruct; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_84_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_84_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_84_goodB2G.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__short_fscanf_add_84.h\" namespace CWE190_Integer_Overflow__short_fscanf_add_84 { CWE190_Integer_Overflow__short_fscanf_add_84_goodB2G::CWE190_Integer_Overflow__short_fscanf_add_84_goodB2G(short dataCopy) { data = dataCopy; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_square_17.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_square_17_bad() { int i,j; short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_square_17.c", "text": "fscanf (stdin, \"%hd\", &data); for(j = 0; j < 1; j++) { { short result = data * data; static void goodB2G() { int i,k; short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_42.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static short badSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_42.c", "text": "#ifndef OMITBAD static short badSource(short data) { fscanf (stdin, \"%hd\", &data); return data; } void CWE190_Integer_Overflow__short_fscanf_multiply_42_bad() { short data; data = 0; data = badSource(data); if(data > 0) { short result = data * 2; #ifndef OMITGOOD static short goodG2BSource(short data) { data = 2; return data; static void goodG2B() { short data; data = 0; data = goodG2BSource(data); if(data > 0) { short result = data * 2; } static short goodB2GSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_multiply_54b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_multiply_54_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_54a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_multiply_54b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_multiply_54_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE190_Integer_Overflow__short_fscanf_multiply_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_multiply_54b_goodG2BSink(short data); static void goodG2B() { short data; data = 0; data = 2; CWE190_Integer_Overflow__short_fscanf_multiply_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__short_fscanf_multiply_54b_goodB2GSink(short data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_06.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #include \"std_testcase.h\" /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_06_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_06.c", "text": "fscanf (stdin, \"%hd\", &data); if(STATIC_CONST_FIVE==5) { { short result = data + 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_06.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_add_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); if(STATIC_CONST_FIVE==5) { { short result = data + 1; static void goodB2G1() { short data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { short result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_multiply_73a.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__short_fscanf_multiply_73 void bad() { short data; list<short> dataList; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_multiply_73a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__short_fscanf_multiply_73 void bad() { short data; list<short> dataList; data = 0; fscanf (stdin, \"%hd\", &data); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { short data; list<short> dataList; data = 0; data = 2; dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { short data; list<short> dataList; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_add_43.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #include \"std_testcase.h\" namespace CWE190_Integer_Overflow__short_fscanf_add_43 #ifndef OMITBAD static void badSource(short &data) fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s04/CWE190_Integer_Overflow__short_fscanf_add_43.cpp", "text": "#include \"std_testcase.h\" namespace CWE190_Integer_Overflow__short_fscanf_add_43 #ifndef OMITBAD static void badSource(short &data) { fscanf (stdin, \"%hd\", &data); void bad() { short data; data = 0; badSource(data); { short result = data + 1; #ifndef OMITGOOD static void goodG2BSource(short &data) { data = 2; static void goodG2B() { short data; data = 0; goodG2BSource(data); { short result = data + 1; } static void goodB2GSource(short &data) fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_81a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_81a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__char_fscanf_square_81.h\" namespace CWE190_Integer_Overflow__char_fscanf_square_81 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_81a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__char_fscanf_square_81.h\" namespace CWE190_Integer_Overflow__char_fscanf_square_81 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); const CWE190_Integer_Overflow__char_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__char_fscanf_square_81_bad(); baseObject.action(data); static void goodG2B() { char data; data = ' '; data = 2; const CWE190_Integer_Overflow__char_fscanf_square_81_base& baseObject = CWE190_Integer_Overflow__char_fscanf_square_81_goodG2B(); baseObject.action(data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_05_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { char result = data + 1; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { char result = data + 1; static void goodB2G1() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_67a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct); void CWE190_Integer_Overflow__char_fscanf_multiply_67_bad() { char data; CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_67a.c", "text": "typedef struct _CWE190_Integer_Overflow__char_fscanf_multiply_67_structType { char structFirst; } CWE190_Integer_Overflow__char_fscanf_multiply_67_structType; #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct); void CWE190_Integer_Overflow__char_fscanf_multiply_67_bad() { char data; CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct; data = ' '; fscanf (stdin, \"%c\", &data); myStruct.structFirst = data; CWE190_Integer_Overflow__char_fscanf_multiply_67b_badSink(myStruct); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_multiply_67b_goodG2BSink(CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct); static void goodG2B() { char data; CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct; data = ' '; data = 2; myStruct.structFirst = data; CWE190_Integer_Overflow__char_fscanf_multiply_67b_goodG2BSink(myStruct); } void CWE190_Integer_Overflow__char_fscanf_multiply_67b_goodB2GSink(CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct); static void goodB2G() { char data; CWE190_Integer_Overflow__char_fscanf_multiply_67_structType myStruct; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_21.c", "text": "static int badStatic = 0; static void badSink(char data) { if(badStatic) { if(data > 0) { char result = data * 2; } } void CWE190_Integer_Overflow__char_fscanf_multiply_21_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_21.c", "text": "{ if(badStatic) { if(data > 0) { char result = data * 2; } } void CWE190_Integer_Overflow__char_fscanf_multiply_21_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(char data) } else { if(data > 0) { if (data < (CHAR_MAX/2)) { char result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_21.c", "text": "if(data > 0) { if (data < (CHAR_MAX/2)) { char result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(char data) { if(goodB2G2Static) { if(data > 0) { if (data < (CHAR_MAX/2)) { char result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_41.c", "text": "char result = data + 1; } } void CWE190_Integer_Overflow__char_fscanf_add_41_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_41.c", "text": "void CWE190_Integer_Overflow__char_fscanf_add_41_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(char data) { { char result = data + 1; static void goodG2B() { char data; data = ' '; data = 2; goodG2BSink(data); } static void goodB2GSink(char data) { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_51a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_add_51b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_add_51_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_51a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_51b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_add_51_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_add_51b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_add_51b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_add_51b_goodG2BSink(data); } void CWE190_Integer_Overflow__char_fscanf_add_51b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_12.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_12_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_12.c", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_12_bad() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%c\", &data); else { data = 2; if(globalReturnsTrueOrFalse()) { { char result = data + 1; else { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_12.c", "text": "* GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_12_bad() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%c\", &data); else { data = 2; if(globalReturnsTrueOrFalse()) { { char result = data + 1; else { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%c\", &data); fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_03.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_03_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(5==5) { { int64_t result = data + 1; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_03.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_add_03_bad() { int64_t data; data = 0LL; if(5==5) { fscanf (stdin, \"%\" SCNd64, &data); if(5==5) { { int64_t result = data + 1; static void goodB2G1() { int64_t data; data = 0LL; if(5==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data < LLONG_MAX) { int64_t result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_08.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_08_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_08.c", "text": "fscanf (stdin, \"%c\", &data); if(staticReturnsTrue()) { { char result = data + 1; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_08.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_08_bad() { char data; data = ' '; if(staticReturnsTrue()) { fscanf (stdin, \"%c\", &data); if(staticReturnsTrue()) { { char result = data + 1; static void goodB2G1() { char data; data = ' '; if(staticReturnsTrue()) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_multiply_05_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_multiply_05_bad() { int64_t data; data = 0LL; if(staticTrue) { fscanf (stdin, \"%\" SCNd64, &data); } if(staticTrue) { if(data > 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_05.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_multiply_05_bad() { int64_t data; data = 0LL; if(staticTrue) { fscanf (stdin, \"%\" SCNd64, &data); } if(staticTrue) { if(data > 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; if(staticTrue) { fscanf (stdin, \"%\" SCNd64, &data); } else { if(data > 0) { if (data < (LLONG_MAX/2)) { int64_t result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_add_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_add_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_66a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_square_66b_badSink(char dataArray[]); void CWE190_Integer_Overflow__char_fscanf_square_66_bad() { char data; char dataArray[5]; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_66a.c", "text": "* Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_66b_badSink(char dataArray[]); void CWE190_Integer_Overflow__char_fscanf_square_66_bad() { char data; char dataArray[5]; data = ' '; fscanf (stdin, \"%c\", &data); dataArray[2] = data; CWE190_Integer_Overflow__char_fscanf_square_66b_badSink(dataArray); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_square_66b_goodG2BSink(char dataArray[]); static void goodG2B() { char data; char dataArray[5]; data = ' '; data = 2; dataArray[2] = data; CWE190_Integer_Overflow__char_fscanf_square_66b_goodG2BSink(dataArray); } void CWE190_Integer_Overflow__char_fscanf_square_66b_goodB2GSink(char dataArray[]); static void goodB2G() { char data; char dataArray[5]; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__char_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__char_fscanf_add_82 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__char_fscanf_add_82.h\" namespace CWE190_Integer_Overflow__char_fscanf_add_82 void bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__char_fscanf_add_82_bad; baseObject->action(data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_add_82_base* baseObject = new CWE190_Integer_Overflow__char_fscanf_add_82_goodG2B; baseObject->action(data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_68a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_add_68b_badSink(); void CWE190_Integer_Overflow__char_fscanf_add_68_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_68a.c", "text": "* Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" char CWE190_Integer_Overflow__char_fscanf_add_68_badData; char CWE190_Integer_Overflow__char_fscanf_add_68_goodG2BData; char CWE190_Integer_Overflow__char_fscanf_add_68_goodB2GData; #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_68b_badSink(); void CWE190_Integer_Overflow__char_fscanf_add_68_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_add_68_badData = data; CWE190_Integer_Overflow__char_fscanf_add_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_add_68b_goodG2BSink(); void CWE190_Integer_Overflow__char_fscanf_add_68b_goodB2GSink(); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_add_68_goodG2BData = data; CWE190_Integer_Overflow__char_fscanf_add_68b_goodG2BSink(); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_34.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) { char unionFirst; char unionSecond; } CWE190_Integer_Overflow__char_fscanf_square_34_unionType; #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_34_bad() { char data; CWE190_Integer_Overflow__char_fscanf_square_34_unionType myUnion; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_34.c", "text": "{ char unionFirst; char unionSecond; } CWE190_Integer_Overflow__char_fscanf_square_34_unionType; #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_34_bad() { char data; CWE190_Integer_Overflow__char_fscanf_square_34_unionType myUnion; data = ' '; fscanf (stdin, \"%c\", &data); myUnion.unionFirst = data; { char data = myUnion.unionSecond; { char result = data * data; static void goodG2B() { char data; CWE190_Integer_Overflow__char_fscanf_square_34_unionType myUnion; data = ' '; data = 2; myUnion.unionFirst = data; { char data = myUnion.unionSecond; { char result = data * data; static void goodB2G() { char data; CWE190_Integer_Overflow__char_fscanf_square_34_unionType myUnion; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_07.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow #include \"std_testcase.h\" /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_07_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_07.c", "text": "fscanf (stdin, \"%c\", &data); if(staticFive==5) { { char result = data + 1; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_07.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_add_07_bad() { char data; data = ' '; if(staticFive==5) { fscanf (stdin, \"%c\", &data); if(staticFive==5) { { char result = data + 1; static void goodB2G1() { char data; data = ' '; if(staticFive==5) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c", "text": "{ int64_t result = data * 2; } } void CWE190_Integer_Overflow__int64_t_fscanf_multiply_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_44.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int64_t data) { if(data > 0) { int64_t result = data * 2; static void goodG2B() { int64_t data; void (*funcPtr) (int64_t) = goodG2BSink; data = 0LL; data = 2; funcPtr(data); } static void goodB2GSink(int64_t data) { if(data > 0) { if (data < (LLONG_MAX/2)) { int64_t result = data * 2; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int64_t data; void (*funcPtr) (int64_t) = goodB2GSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_multiply_54b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_multiply_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_54a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_multiply_54b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_multiply_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_multiply_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_multiply_54b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_multiply_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__char_fscanf_multiply_54b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_02.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_02_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_02.c", "text": "fscanf (stdin, \"%c\", &data); if(1) { { char result = data * data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_02.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_02_bad() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); if(1) { { char result = data * data; static void goodB2G1() { char data; data = ' '; if(1) { fscanf (stdin, \"%c\", &data); else { if (abs((long)data) <= (long)sqrt((double)CHAR_MAX)) { char result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_08.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_08_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_08.c", "text": "fscanf (stdin, \"%c\", &data); if(staticReturnsTrue()) { { char result = data * data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_08.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_08_bad() { char data; data = ' '; if(staticReturnsTrue()) { fscanf (stdin, \"%c\", &data); if(staticReturnsTrue()) { { char result = data * data; static void goodB2G1() { char data; data = ' '; if(staticReturnsTrue()) { fscanf (stdin, \"%c\", &data); else { if (abs((long)data) <= (long)sqrt((double)CHAR_MAX)) { char result = data * data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_multiply_17_bad() { int i,j; int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_17.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); } for(j = 0; j < 1; j++) { if(data > 0) { int64_t result = data * 2; static void goodB2G() { int i,k; int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_multiply_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_multiply_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_16.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: square * GoodSink: Ensure there will not be an overflow before squaring data * BadSink : Square data, which can lead to overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_square_16_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_16.c", "text": "fscanf (stdin, \"%c\", &data); while(1) { { char result = data * data; static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_square_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_square_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #include <inttypes.h> #include \"std_testcase.h\" #include \"CWE190_Integer_Overflow__int64_t_fscanf_multiply_83.h\" namespace CWE190_Integer_Overflow__int64_t_fscanf_multiply_83 { CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad::CWE190_Integer_Overflow__int64_t_fscanf_multiply_83_bad(int64_t dataCopy) { data = dataCopy; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_add_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_21.c", "text": "static int badStatic = 0; static void badSink(char data) if(badStatic) { { char result = data + 1; } } void CWE190_Integer_Overflow__char_fscanf_add_21_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_21.c", "text": "* GoodSource: Set data to a small, non-zero number (two) * Sinks: add * GoodSink: Ensure there will not be an overflow before adding 1 to data * BadSink : Add 1 to data, which can cause an overflow static int badStatic = 0; static void badSink(char data) if(badStatic) { { char result = data + 1; } } void CWE190_Integer_Overflow__char_fscanf_add_21_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(char data) else { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__char_fscanf_add_21.c", "text": "static int goodG2BStatic = 0; static void goodB2G1Sink(char data) else { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(char data) if(goodB2G2Static) { if (data < CHAR_MAX) { char result = data + 1; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_74a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_multiply_74a.cpp /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__int64_t_fscanf_multiply_74 void bad() { int64_t data; map<int, int64_t> dataMap; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s01/CWE190_Integer_Overflow__int64_t_fscanf_multiply_74a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: multiply * GoodSink: Ensure there will not be an overflow before multiplying data by 2 * BadSink : If data is positive, multiply by 2, which can cause an overflow * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files using namespace std; namespace CWE190_Integer_Overflow__int64_t_fscanf_multiply_74 void bad() { int64_t data; map<int, int64_t> dataMap; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { int64_t data; map<int, int64_t> dataMap; data = 0LL; data = 2; dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodB2G() { int64_t data; map<int, int64_t> dataMap; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_45.c", "text": "data++; int result = data; } } void CWE190_Integer_Overflow__int_fscanf_postinc_45_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_45.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_45_badData = data; static void goodG2BSink() { int data = CWE190_Integer_Overflow__int_fscanf_postinc_45_goodG2BData; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_45_goodG2BData = data; static void goodB2GSink() { int data = CWE190_Integer_Overflow__int_fscanf_postinc_45_goodB2GData;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_45.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_45_badData = data; static void goodG2BSink() { int data = CWE190_Integer_Overflow__int_fscanf_postinc_45_goodG2BData; { data++; int result = data; static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_45_goodG2BData = data; static void goodB2GSink() { int data = CWE190_Integer_Overflow__int_fscanf_postinc_45_goodB2GData; if (data < INT_MAX) { data++; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_44.c", "text": "data++; unsigned int result = data; } } void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_44.c", "text": "fscanf (stdin, \"%u\", &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(unsigned int data) { { data++; unsigned int result = data; static void goodG2B() { unsigned int data; void (*funcPtr) (unsigned int) = goodG2BSink; data = 0; data = 2; funcPtr(data); } static void goodB2GSink(unsigned int data) { if (data < UINT_MAX) { data++; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { unsigned int data; void (*funcPtr) (unsigned int) = goodB2GSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21.c", "text": "static int badStatic = 0; static void badSink(unsigned int data) if(badStatic) { { data++; unsigned int result = data; } } void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21.c", "text": "static int badStatic = 0; static void badSink(unsigned int data) if(badStatic) { { data++; unsigned int result = data; } } void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(unsigned int data) else { if (data < UINT_MAX) { data++; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_21.c", "text": "else { if (data < UINT_MAX) { data++; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(unsigned int data) if(goodB2G2Static) { if (data < UINT_MAX) { data++; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64a.c", "text": "void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { unsigned int data; data = 0; data = 2; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_63a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_63_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_63a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_63_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_63a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_63_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_63b_goodG2BSink(int * data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_63b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_postinc_63b_goodB2GSink(int * data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_63a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * dataPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_63_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_63b_goodG2BSink(int * data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_63b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_postinc_63b_goodB2GSink(int * data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_34.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_postinc_34_unionType myUnion; static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_postinc_34_unionType myUnion;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_34.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_34_bad() { int data; CWE190_Integer_Overflow__int_fscanf_postinc_34_unionType myUnion; data = 0; fscanf(stdin, \"%d\", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { data++; int result = data; static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_postinc_34_unionType myUnion; data = 0; data = 2; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { data++; int result = data; static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_postinc_34_unionType myUnion; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_13.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_postinc_13_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_13.c", "text": "fscanf (stdin, \"%hd\", &data); if(GLOBAL_CONST_FIVE==5) { { data++; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_13.c", "text": "void CWE190_Integer_Overflow__short_fscanf_postinc_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); if(GLOBAL_CONST_FIVE==5) { { data++; short result = data; static void goodB2G1() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_postinc_52b_badSink(int64_t data); void CWE190_Integer_Overflow__int64_t_fscanf_postinc_52_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_postinc_52b_badSink(int64_t data); void CWE190_Integer_Overflow__int64_t_fscanf_postinc_52_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE190_Integer_Overflow__int64_t_fscanf_postinc_52b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int64_t_fscanf_postinc_52b_goodG2BSink(int64_t data); static void goodG2B() { int64_t data; data = 0LL; data = 2; CWE190_Integer_Overflow__int64_t_fscanf_postinc_52b_goodG2BSink(data); } void CWE190_Integer_Overflow__int64_t_fscanf_postinc_52b_goodB2GSink(int64_t data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_postinc_13_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(GLOBAL_CONST_FIVE==5) { { data++; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_13.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_postinc_13_bad() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); if(GLOBAL_CONST_FIVE==5) { { data++; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data < LLONG_MAX) { data++; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_32.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_32_bad() { char data; char *dataPtr1 = &data; char *dataPtr2 = &data; data = ' '; { char data = *dataPtr1; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_32.c", "text": "{ char data = *dataPtr1; fscanf (stdin, \"%c\", &data); *dataPtr1 = data; } { char data = *dataPtr2; { data++; char result = data; static void goodG2B() { char data; char *dataPtr1 = &data; char *dataPtr2 = &data; data = ' '; { char data = *dataPtr1; data = 2; *dataPtr1 = data; } { char data = *dataPtr2; { data++; char result = data; static void goodB2G() { char data; char *dataPtr1 = &data; char *dataPtr2 = &data; data = ' '; { char data = *dataPtr1; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static int64_t badSource(int64_t data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_42.c", "text": "#ifndef OMITBAD static int64_t badSource(int64_t data) { fscanf (stdin, \"%\" SCNd64, &data); return data; } void CWE190_Integer_Overflow__int64_t_fscanf_postinc_42_bad() { int64_t data; data = 0LL; data = badSource(data); { data++; int64_t result = data; #ifndef OMITGOOD static int64_t goodG2BSource(int64_t data) { data = 2; return data; static void goodG2B() { int64_t data; data = 0LL; data = goodG2BSource(data); { data++; int64_t result = data; } static int64_t goodB2GSource(int64_t data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_postinc_16_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_16.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); while(1) { { data++; int64_t result = data; static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_15.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_postinc_15_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_15.c", "text": "fscanf (stdin, \"%hd\", &data); { case 7: { data++; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_15.c", "text": "void CWE190_Integer_Overflow__short_fscanf_postinc_15_bad() { short data; data = 0; { case 6: fscanf (stdin, \"%hd\", &data); { case 7: { data++; short result = data; static void goodB2G1() { short data; data = 0; { case 6: fscanf (stdin, \"%hd\", &data); break; default: if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_21.c", "text": "static int badStatic = 0; static void badSink(int data) if(badStatic) { { data++; int result = data; } } void CWE190_Integer_Overflow__int_fscanf_postinc_21_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_21.c", "text": "if(badStatic) { { data++; int result = data; } } void CWE190_Integer_Overflow__int_fscanf_postinc_21_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(int data) else { if (data < INT_MAX) { data++; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_21.c", "text": "if (data < INT_MAX) { data++; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G1() { int data; data = 0; fscanf(stdin, \"%d\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(int data) if(goodB2G2Static) { if (data < INT_MAX) { data++; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_11.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_postinc_11_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_11.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalReturnsTrue()) { { data++; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_11.c", "text": "void CWE190_Integer_Overflow__short_fscanf_postinc_11_bad() { short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data); if(globalReturnsTrue()) { { data++; short result = data; static void goodB2G1() { short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c", "text": "data++; int64_t result = data; } } void CWE190_Integer_Overflow__int64_t_fscanf_postinc_45_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_45.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_postinc_45_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE190_Integer_Overflow__int64_t_fscanf_postinc_45_badData = data; static void goodG2BSink() { int64_t data = CWE190_Integer_Overflow__int64_t_fscanf_postinc_45_goodG2BData; { data++; int64_t result = data; static void goodG2B() { int64_t data; data = 0LL; data = 2; CWE190_Integer_Overflow__int64_t_fscanf_postinc_45_goodG2BData = data; static void goodB2GSink() { int64_t data = CWE190_Integer_Overflow__int64_t_fscanf_postinc_45_goodB2GData; if (data < LLONG_MAX) { data++; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_postinc_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_63a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_postinc_63b_badSink(char * dataPtr); void CWE190_Integer_Overflow__char_fscanf_postinc_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__char_fscanf_postinc_63a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_postinc_63b_badSink(char * dataPtr); void CWE190_Integer_Overflow__char_fscanf_postinc_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_postinc_63b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_postinc_63b_goodG2BSink(char * data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_postinc_63b_goodG2BSink(&data); } void CWE190_Integer_Overflow__char_fscanf_postinc_63b_goodB2GSink(char * data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_64a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_64a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_64_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_64a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_64_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_64b_goodG2BSink(void * dataVoidPtr); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_postinc_64b_goodB2GSink(void * dataVoidPtr);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_64a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_postinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int_fscanf_postinc_64_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int_fscanf_postinc_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_postinc_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_postinc_05_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_postinc_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); if(staticTrue) { { data++; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__short_fscanf_postinc_05.c", "text": "void CWE190_Integer_Overflow__short_fscanf_postinc_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); if(staticTrue) { { data++; short result = data; static void goodB2G1() { short data; data = 0; if(staticTrue) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { data++; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) { unsigned int unionFirst; unsigned int unionSecond; } CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_unionType; #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_bad() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_unionType myUnion; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34.c", "text": "{ unsigned int unionFirst; unsigned int unionSecond; } CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_unionType; #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_bad() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_unionType myUnion; data = 0; fscanf (stdin, \"%u\", &data); myUnion.unionFirst = data; { unsigned int data = myUnion.unionSecond; { data++; unsigned int result = data; static void goodG2B() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_unionType myUnion; data = 0; data = 2; myUnion.unionFirst = data; { unsigned int data = myUnion.unionSecond; { data++; unsigned int result = data; static void goodB2G() { unsigned int data; CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_34_unionType myUnion; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int64_t_fscanf_postinc_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_postinc_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_postinc_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_postinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_54_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_54b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_postinc_54b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s06/CWE190_Integer_Overflow__int_fscanf_postinc_54a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_postinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_postinc_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_postinc_54b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_postinc_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_postinc_54b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54a.c", "text": "void CWE190_Integer_Overflow__char_fscanf_preinc_54b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_preinc_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_54a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_preinc_54b_badSink(char data); void CWE190_Integer_Overflow__char_fscanf_preinc_54_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE190_Integer_Overflow__char_fscanf_preinc_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__char_fscanf_preinc_54b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = 2; CWE190_Integer_Overflow__char_fscanf_preinc_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__char_fscanf_preinc_54b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c", "text": "++data; int64_t result = data; } } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_44.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int64_t data) { { ++data; int64_t result = data; static void goodG2B() { int64_t data; void (*funcPtr) (int64_t) = goodG2BSink; data = 0LL; data = 2; funcPtr(data); } static void goodB2GSink(int64_t data) { if (data < LLONG_MAX) { ++data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int64_t data; void (*funcPtr) (int64_t) = goodB2GSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int64_t_fscanf_preinc_64_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b_badSink(void * dataVoidPtr); void CWE190_Integer_Overflow__int64_t_fscanf_preinc_64_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b_badSink(&data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int64_t data; data = 0LL; data = 2; CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b_goodG2BSink(&data); } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_07.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #include \"std_testcase.h\" /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_preinc_07_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_07.c", "text": "fscanf (stdin, \"%hd\", &data); if(staticFive==5) { { ++data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_07.c", "text": "void CWE190_Integer_Overflow__short_fscanf_preinc_07_bad() { short data; data = 0; if(staticFive==5) { fscanf (stdin, \"%hd\", &data); if(staticFive==5) { { ++data; short result = data; static void goodB2G1() { short data; data = 0; if(staticFive==5) { fscanf (stdin, \"%hd\", &data); else { if (data < SHRT_MAX) { ++data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_01.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_01_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_01.c", "text": "fscanf (stdin, \"%u\", &data); { ++data; unsigned int result = data; static void goodG2B() { unsigned int data; data = 0; data = 2; { ++data; unsigned int result = data; static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_preinc_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_preinc_68_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_68a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_preinc_68_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_preinc_68_badData = data; CWE190_Integer_Overflow__int_fscanf_preinc_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_preinc_68b_goodG2BSink(); void CWE190_Integer_Overflow__int_fscanf_preinc_68b_goodB2GSink(); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_preinc_68_goodG2BData = data; CWE190_Integer_Overflow__int_fscanf_preinc_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_68a.c", "text": "int CWE190_Integer_Overflow__int_fscanf_preinc_68_badData; int CWE190_Integer_Overflow__int_fscanf_preinc_68_goodG2BData; int CWE190_Integer_Overflow__int_fscanf_preinc_68_goodB2GData; #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_preinc_68b_badSink(); void CWE190_Integer_Overflow__int_fscanf_preinc_68_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_preinc_68_badData = data; CWE190_Integer_Overflow__int_fscanf_preinc_68b_badSink(); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_preinc_68b_goodG2BSink(); void CWE190_Integer_Overflow__int_fscanf_preinc_68b_goodB2GSink(); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_preinc_68_goodG2BData = data; CWE190_Integer_Overflow__int_fscanf_preinc_68b_goodG2BSink(); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_preinc_05_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_05.c", "text": "#ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_preinc_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { ++data; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_05.c", "text": "void CWE190_Integer_Overflow__char_fscanf_preinc_05_bad() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); if(staticTrue) { { ++data; char result = data; static void goodB2G1() { char data; data = ' '; if(staticTrue) { fscanf (stdin, \"%c\", &data); else { if (data < CHAR_MAX) { ++data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__char_fscanf_preinc_15.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__char_fscanf_preinc_15_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_15.c", "text": "fscanf (stdin, \"%c\", &data); { case 7: { ++data; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__char_fscanf_preinc_15.c", "text": "void CWE190_Integer_Overflow__char_fscanf_preinc_15_bad() { char data; data = ' '; { case 6: fscanf (stdin, \"%c\", &data); { case 7: { ++data; char result = data; static void goodB2G1() { char data; data = ' '; { case 6: fscanf (stdin, \"%c\", &data); break; default: if (data < CHAR_MAX) { ++data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_17.c", "text": "data = 0; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data); for(j = 0; j < 1; j++) { { ++data; int result = data; static void goodB2G() { int i,k; int data; data = 0; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_44.c", "text": "++data; unsigned int result = data; } } void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_44.c", "text": "fscanf (stdin, \"%u\", &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(unsigned int data) { { ++data; unsigned int result = data; static void goodG2B() { unsigned int data; void (*funcPtr) (unsigned int) = goodG2BSink; data = 0; data = 2; funcPtr(data); } static void goodB2GSink(unsigned int data) { if (data < UINT_MAX) { ++data; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { unsigned int data; void (*funcPtr) (unsigned int) = goodB2GSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_02.c", "text": "data = 0; if(1) { fscanf(stdin, \"%d\", &data); if(1) { { ++data; int result = data; static void goodB2G1() { int data; data = 0; if(1) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_02.c", "text": "if(1) { fscanf(stdin, \"%d\", &data); if(1) { { ++data; int result = data; static void goodB2G1() { int data; data = 0; if(1) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { ++data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(1) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54a.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_54_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_preinc_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_preinc_54b_goodG2BSink(int data); data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_preinc_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_preinc_54b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_54a.c", "text": "* Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE190_Integer_Overflow__int_fscanf_preinc_54b_badSink(int data); void CWE190_Integer_Overflow__int_fscanf_preinc_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE190_Integer_Overflow__int_fscanf_preinc_54b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__int_fscanf_preinc_54b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = 2; CWE190_Integer_Overflow__int_fscanf_preinc_54b_goodG2BSink(data); } void CWE190_Integer_Overflow__int_fscanf_preinc_54b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_11.c", "text": "data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(globalReturnsTrue()) { { ++data; int result = data; static void goodB2G1() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_11.c", "text": "if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(globalReturnsTrue()) { { ++data; int result = data; static void goodB2G1() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data); else { if (data < INT_MAX) { ++data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int_fscanf_preinc_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_34.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_preinc_34_unionType myUnion; static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_preinc_34_unionType myUnion;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int_fscanf_preinc_34.c", "text": "void CWE190_Integer_Overflow__int_fscanf_preinc_34_bad() { int data; CWE190_Integer_Overflow__int_fscanf_preinc_34_unionType myUnion; data = 0; fscanf(stdin, \"%d\", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { ++data; int result = data; static void goodG2B() { int data; CWE190_Integer_Overflow__int_fscanf_preinc_34_unionType myUnion; data = 0; data = 2; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { ++data; int result = data; static void goodB2G() { int data; CWE190_Integer_Overflow__int_fscanf_preinc_34_unionType myUnion; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32_bad() { unsigned int data; unsigned int *dataPtr1 = &data; unsigned int *dataPtr2 = &data; data = 0; { unsigned int data = *dataPtr1; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_32.c", "text": "{ unsigned int data = *dataPtr1; fscanf (stdin, \"%u\", &data); *dataPtr1 = data; } { unsigned int data = *dataPtr2; { ++data; unsigned int result = data; static void goodG2B() { unsigned int data; unsigned int *dataPtr1 = &data; unsigned int *dataPtr2 = &data; data = 0; { unsigned int data = *dataPtr1; data = 2; *dataPtr1 = data; } { unsigned int data = *dataPtr2; { ++data; unsigned int result = data; static void goodB2G() { unsigned int data; unsigned int *dataPtr1 = &data; unsigned int *dataPtr2 = &data; data = 0; { unsigned int data = *dataPtr1; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_15.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_preinc_15_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_15.c", "text": "fscanf (stdin, \"%hd\", &data); { case 7: { ++data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_15.c", "text": "void CWE190_Integer_Overflow__short_fscanf_preinc_15_bad() { short data; data = 0; { case 6: fscanf (stdin, \"%hd\", &data); { case 7: { ++data; short result = data; static void goodB2G1() { short data; data = 0; { case 6: fscanf (stdin, \"%hd\", &data); break; default: if (data < SHRT_MAX) { ++data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__short_fscanf_preinc_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_52a.c", "text": "void CWE190_Integer_Overflow__short_fscanf_preinc_52b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_preinc_52_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__short_fscanf_preinc_52a.c", "text": "* @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE190_Integer_Overflow__short_fscanf_preinc_52b_badSink(short data); void CWE190_Integer_Overflow__short_fscanf_preinc_52_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE190_Integer_Overflow__short_fscanf_preinc_52b_badSink(data); #ifndef OMITGOOD void CWE190_Integer_Overflow__short_fscanf_preinc_52b_goodG2BSink(short data); static void goodG2B() { short data; data = 0; data = 2; CWE190_Integer_Overflow__short_fscanf_preinc_52b_goodG2BSink(data); } void CWE190_Integer_Overflow__short_fscanf_preinc_52b_goodB2GSink(short data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c /* * @description * CWE: 190 Integer Overflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (two) * Sinks: increment * GoodSink: Ensure there will not be an overflow before incrementing data * BadSink : Increment data, which can cause an overflow #ifndef OMITBAD void CWE190_Integer_Overflow__int64_t_fscanf_preinc_11_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(globalReturnsTrue()) { { ++data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE190_Integer_Overflow/s07/CWE190_Integer_Overflow__int64_t_fscanf_preinc_11.c", "text": "void CWE190_Integer_Overflow__int64_t_fscanf_preinc_11_bad() { int64_t data; data = 0LL; if(globalReturnsTrue()) { fscanf (stdin, \"%\" SCNd64, &data); if(globalReturnsTrue()) { { ++data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; if(globalReturnsTrue()) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data < LLONG_MAX) { ++data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_aes_encrypted_payload_15.c", "text": "* @description * CWE: 506 Embedded Malicious Code * Sinks: aes_encrypted_payload * GoodSink: Use a plaintext payload in a system call * BadSink : Use an AES encrypted payload in a system call case 6: { BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6}; DWORD payloadLen = strlen((char *)payload); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen)) break; } payload[payloadLen] = '\\0'; if(system((char*)payload) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_aes_encrypted_payload_15.c", "text": "* @description * CWE: 506 Embedded Malicious Code * Sinks: aes_encrypted_payload * GoodSink: Use a plaintext payload in a system call * BadSink : Use an AES encrypted payload in a system call case 6: { BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6}; DWORD payloadLen = strlen((char *)payload); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen)) break; } payload[payloadLen] = '\\0'; if(system((char*)payload) <= 0) default: { char * payload = \"calc.exe\"; if(system(payload) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE506_Embedded_Malicious_Code/CWE506_Embedded_Malicious_Code__w32_aes_encrypted_payload_15.c", "text": "* @description * CWE: 506 Embedded Malicious Code * Sinks: aes_encrypted_payload * GoodSink: Use a plaintext payload in a system call * BadSink : Use an AES encrypted payload in a system call case 6: { BYTE payload[20] = {0xfb, 0x50, 0xe5, 0x8d, 0xc5, 0x4b, 0xdd, 0xe0, 0x26, 0x2b, 0x98, 0x49, 0x73, 0xfb, 0x4c, 0xf6}; DWORD payloadLen = strlen((char *)payload); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, (BYTE *)payload, &payloadLen)) break; } payload[payloadLen] = '\\0'; if(system((char*)payload) <= 0) default: { char * payload = \"calc.exe\"; if(system(payload) <= 0) case 6: { char * payload = \"calc.exe\"; if(system(payload) <= 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_13.c", "text": "if(GLOBAL_CONST_FIVE==5) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_02.c", "text": "if(1) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_02.c", "text": "} recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); if(1) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_17.c", "text": "for(j = 0; j < 1; j++) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_17.c", "text": "} recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); for(k = 0; k < 1; k++) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_15.c", "text": "{ case 6: { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_01.c", "text": "void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_01_bad() { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_32.c", "text": "data = -1; { int data = *dataPtr1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_32.c", "text": "data = -1; { int data = *dataPtr1; fscanf(stdin, \"%d\", &data); *dataPtr1 = data; } { int data = *dataPtr2; printIntLine(100 % data); static void goodG2B() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = -1; { int data = *dataPtr1; data = 7; *dataPtr1 = data; } { int data = *dataPtr2; printIntLine(100 % data); static void goodB2G() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = -1; { int data = *dataPtr1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_54a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_54a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_54_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_54a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_54_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_54b_badSink(data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_goodG2BSink(int data); data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_54b_goodG2BSink(data); } void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_54a.c", "text": "* Sinks: modulo * GoodSink: Check for zero before modulo * BadSink : Modulo a constant with data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_54_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_54b_badSink(data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_goodG2BSink(int data); static void goodG2B() { int data; data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_54b_goodG2BSink(data); } void CWE369_Divide_by_Zero__int_fscanf_modulo_54b_goodB2GSink(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_13.c", "text": "data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_13.c", "text": "data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(GLOBAL_CONST_FIVE==5) { printIntLine(100 % data); static void goodB2G1() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_13.c", "text": "fscanf(stdin, \"%d\", &data); data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_13.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_modulo_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(GLOBAL_CONST_FIVE==5) { printIntLine(100 % data); static void goodB2G1() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); else { if( data != 0 ) { printIntLine(100 % data); static void goodB2G2() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_07.c", "text": "data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_07.c", "text": "data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); if(staticFive==5) { printIntLine(100 % data); static void goodB2G1() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_07.c", "text": "fscanf(stdin, \"%d\", &data); data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_07.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_modulo_07_bad() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); if(staticFive==5) { printIntLine(100 % data); static void goodB2G1() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data); else { if( data != 0 ) { printIntLine(100 % data); static void goodB2G2() { int data; data = -1; if(staticFive==5) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_04.c", "text": "data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_04.c", "text": "data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_TRUE) { printIntLine(100 % data); static void goodB2G1() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_04.c", "text": "fscanf(stdin, \"%d\", &data); data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_04.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_modulo_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_TRUE) { printIntLine(100 % data); static void goodB2G1() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data); else { if( data != 0 ) { printIntLine(100 % data); static void goodB2G2() { int data; data = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_53a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_53_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_53a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_53_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_53a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_53_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_53b_badSink(data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_goodG2BSink(int data); data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_53b_goodG2BSink(data); } void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_53a.c", "text": "* Sinks: modulo * GoodSink: Check for zero before modulo * BadSink : Modulo a constant with data * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_53_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_53b_badSink(data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_goodG2BSink(int data); static void goodG2B() { int data; data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_53b_goodG2BSink(data); } void CWE369_Divide_by_Zero__int_fscanf_modulo_53b_goodB2GSink(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_82.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_82", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_82.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_82 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_82.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_82 int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_fscanf_modulo_82_bad; data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_fscanf_modulo_82_goodG2B;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE369_Divide_by_Zero__int_fscanf_modulo_82.h\" namespace CWE369_Divide_by_Zero__int_fscanf_modulo_82 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_fscanf_modulo_82_bad; baseObject->action(data); static void goodG2B() { int data; data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_fscanf_modulo_82_goodG2B; baseObject->action(data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c", "text": "int CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_22_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c", "text": "int CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_22_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c", "text": "int CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_22_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 1; CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Sink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c", "text": "int CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_22_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 1; CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Sink(int data); static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c", "text": "int CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_modulo_22_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 1; CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Sink(int data); int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Global = 0; CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Sink(data); } void CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G2Sink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s02/CWE369_Divide_by_Zero__int_fscanf_modulo_22a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_modulo_22_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_22_badGlobal = 1; CWE369_Divide_by_Zero__int_fscanf_modulo_22_badSink(data); #ifndef OMITGOOD int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G2Global = 0; int CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodG2BGlobal = 0; void CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Sink(int data); static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Global = 0; CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G1Sink(data); } void CWE369_Divide_by_Zero__int_fscanf_modulo_22_goodB2G2Sink(int data); static void goodB2G2() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_connect_socket_07.c", "text": "#endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS \"127.0.0.1\" recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_72a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_72a.cpp", "text": "* Sinks: * GoodSink: Check value of or near zero before dividing * BadSink : Divide a constant by data * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE369_Divide_by_Zero__float_fscanf_72 void bad() { float data; vector<float> dataVector; data = 0.0F; fscanf (stdin, \"%f\", &data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { float data; vector<float> dataVector; data = 0.0F; data = 2.0F; dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodB2G() { float data; vector<float> dataVector; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_13.c", "text": "data = 0.0F; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_13.c", "text": "data = 0.0F; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%f\", &data); { { int result = (int)(100.0 / data); static void goodB2G1() { float data; data = 0.0F; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_13.c", "text": "fscanf (stdin, \"%f\", &data); data = 0.0F; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_13.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__float_fscanf_13_bad() { float data; data = 0.0F; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%f\", &data); { { int result = (int)(100.0 / data); static void goodB2G1() { float data; data = 0.0F; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%f\", &data); else { if(fabs(data) > 0.000001) { int result = (int)(100.0 / data); static void goodB2G2() { float data; data = 0.0F; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_listenSocket_04.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_54a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_divide_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_54a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_divide_54_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_54a.c", "text": "void CWE369_Divide_by_Zero__int_fscanf_divide_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_divide_54_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_divide_54b_badSink(data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_divide_54b_goodG2BSink(int data); data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_divide_54b_goodG2BSink(data); } void CWE369_Divide_by_Zero__int_fscanf_divide_54b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_54a.c", "text": "* Sinks: divide * GoodSink: Check for zero before dividing * BadSink : Divide a constant by data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE369_Divide_by_Zero__int_fscanf_divide_54b_badSink(int data); void CWE369_Divide_by_Zero__int_fscanf_divide_54_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE369_Divide_by_Zero__int_fscanf_divide_54b_badSink(data); #ifndef OMITGOOD void CWE369_Divide_by_Zero__int_fscanf_divide_54b_goodG2BSink(int data); static void goodG2B() { int data; data = -1; data = 7; CWE369_Divide_by_Zero__int_fscanf_divide_54b_goodG2BSink(data); } void CWE369_Divide_by_Zero__int_fscanf_divide_54b_goodB2GSink(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_04.c", "text": "data = 0.0F; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_04.c", "text": "data = 0.0F; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%f\", &data); { { int result = (int)(100.0 / data); static void goodB2G1() { float data; data = 0.0F; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_04.c", "text": "fscanf (stdin, \"%f\", &data); data = 0.0F; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%f\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_04.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__float_fscanf_04_bad() { float data; data = 0.0F; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%f\", &data); { { int result = (int)(100.0 / data); static void goodB2G1() { float data; data = 0.0F; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%f\", &data); else { if(fabs(data) > 0.000001) { int result = (int)(100.0 / data); static void goodB2G2() { float data; data = 0.0F; if(STATIC_CONST_TRUE) { fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_34.c", "text": "data = 0.0F; fscanf (stdin, \"%f\", &data); static void goodG2B() { float data; CWE369_Divide_by_Zero__float_fscanf_34_unionType myUnion; static void goodB2G() { float data; CWE369_Divide_by_Zero__float_fscanf_34_unionType myUnion;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_34.c", "text": "#ifndef OMITBAD void CWE369_Divide_by_Zero__float_fscanf_34_bad() { float data; CWE369_Divide_by_Zero__float_fscanf_34_unionType myUnion; data = 0.0F; fscanf (stdin, \"%f\", &data); myUnion.unionFirst = data; { float data = myUnion.unionSecond; { int result = (int)(100.0 / data); static void goodG2B() { float data; CWE369_Divide_by_Zero__float_fscanf_34_unionType myUnion; data = 0.0F; data = 2.0F; myUnion.unionFirst = data; { float data = myUnion.unionSecond; { int result = (int)(100.0 / data); static void goodB2G() { float data; CWE369_Divide_by_Zero__float_fscanf_34_unionType myUnion; data = 0.0F; fscanf (stdin, \"%f\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__float_fscanf_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__float_fscanf_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE369_Divide_by_Zero/s01/CWE369_Divide_by_Zero__int_fscanf_divide_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE369_Divide_by_Zero__int_fscanf_divide_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_13.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_13.c", "text": "data = 0; if(GLOBAL_CONST_FIVE==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_13.c", "text": "data = 0; if(GLOBAL_CONST_FIVE==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_13.c", "text": "{ short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_13.c", "text": "} else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_13.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_13.c", "text": "data = 0; if(GLOBAL_CONST_FIVE==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_05.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_05.c", "text": "data = 0; if(staticTrue) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_05.c", "text": "{ short data; data = 0; if(staticTrue) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_05.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(staticTrue) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_14.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_14.c", "text": "data = 0; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_14.c", "text": "{ short data; data = 0; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_14.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(globalFive==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_42.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_42.c", "text": "data = -1; return data; void CWE194_Unexpected_Sign_Extension__negative_memcpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_42.c", "text": "short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD static short goodG2BSource(short data) { data = 100-1; return data; static void goodG2B() { short data; data = 0; data = goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_72b.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_72b.cpp", "text": "short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_72b.cpp", "text": "short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void goodG2BSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_62a.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_62a.cpp", "text": "void badSource(short &data); void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_62a.cpp", "text": "void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_62a.cpp", "text": "#ifndef OMITBAD void badSource(short &data); void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void goodG2BSource(short &data); static void goodG2B() { short data; data = 0; goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_62a.cpp", "text": "static void goodG2B() { short data; data = 0; goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_83_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__negative_memmove_83_goodG2B::~CWE194_Unexpected_Sign_Extension__negative_memmove_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_02.c", "text": "data = 0; if(1) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_02.c", "text": "{ short data; data = 0; if(1) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_02.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(1) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_64b.c", "text": "short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_64b.c", "text": "short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_10.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_10_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_10.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(globalTrue) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_31.c", "text": "{ short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_31.c", "text": "} else { data = tempInt; #endif } { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; data = 100-1; { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_03.c", "text": "data = 0; if(5==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_03.c", "text": "{ short data; data = 0; if(5==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_03.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(5==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_10.c", "text": "data = 0; if(globalTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_10.c", "text": "{ short data; data = 0; if(globalTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_18.c", "text": "data = 0; goto source; source: data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_18.c", "text": "void CWE194_Unexpected_Sign_Extension__negative_memcpy_18_bad() { short data; data = 0; goto source; source: data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_65b.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_memcpy_65b_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_65b.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_memcpy_65b_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_07.c", "text": "data = 0; if(staticFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_07.c", "text": "#include \"std_testcase.h\"", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_07.c", "text": "{ short data; data = 0; if(staticFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_07.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(staticFive==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_09.c", "text": "data = 0; if(GLOBAL_CONST_TRUE) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_09.c", "text": "data = 0; if(GLOBAL_CONST_TRUE) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_09.c", "text": "{ short data; data = 0; if(GLOBAL_CONST_TRUE) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_09.c", "text": "data = 0; if(GLOBAL_CONST_TRUE) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_51b.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_strncpy_51b_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_51b.c", "text": "#ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_strncpy_51b_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_51b.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_strncpy_51b_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_51b.c", "text": "#ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_strncpy_51b_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_13.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_13_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_13.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_21.c", "text": "static int badStatic = 0; static short badSource(short data) if(badStatic) { data = (short)RAND32(); } return data; void CWE194_Unexpected_Sign_Extension__rand_memcpy_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_05.c", "text": "data = 0; if(staticTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_05.c", "text": "{ short data; data = 0; if(staticTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_05.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(staticTrue) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_32.c", "text": "data = 0; { short data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } #endif } *dataPtr1 = data; } { short data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_84_bad.cpp", "text": "data = -1; CWE194_Unexpected_Sign_Extension__negative_memcpy_84_bad::~CWE194_Unexpected_Sign_Extension__negative_memcpy_84_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22a.c", "text": "int CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22a.c", "text": "data = 0; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD int CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B2Global = 0; short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B1Source(short data); static void goodG2B1() { short data; data = 0; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B1Global = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22a.c", "text": "{ short data; data = 0; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B1Global = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B2Source(short data); static void goodG2B2() { short data; data = 0; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B2Global = 1; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_22_goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_83_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_83_goodG2B::~CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_44.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_44.c", "text": "#define CHAR_ARRAY_SIZE 8 #ifndef OMITBAD static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_44.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_03.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_03_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_34.c", "text": "data = 0; data = -1; myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_34.c", "text": "data = 0; data = -1; myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; CWE194_Unexpected_Sign_Extension__negative_memcpy_34_unionType myUnion; data = 0; data = 100-1; myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_53d.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_memcpy_53d_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_53d.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_memcpy_53d_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_07.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_07_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_07.c", "text": "{ short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { short data; data = 0; if(staticFive==5) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_44.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_44.c", "text": "static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE194_Unexpected_Sign_Extension__rand_strncpy_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; data = (short)RAND32(); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_52c.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__rand_memmove_52c_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_52c.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__rand_memmove_52c_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_43.cpp", "text": "data = -1; void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_43.cpp", "text": "{ short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD static void goodG2BSource(short &data) { data = 100-1; static void goodG2B() { short data; data = 0; goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_07.c", "text": "data = 0; if(staticFive==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_07.c", "text": "{ short data; data = 0; if(staticFive==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_65b.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__negative_strncpy_65b_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_65b.c", "text": "#include \"std_testcase.h\" #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__negative_strncpy_65b_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_65b.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__negative_strncpy_65b_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_65b.c", "text": "#ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__negative_strncpy_65b_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61a.c", "text": "short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61a.c", "text": "#ifndef OMITBAD short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61b_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61b_goodG2BSource(short data); static void goodG2B() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_61b_goodG2BSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_44.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_44.c", "text": "static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE194_Unexpected_Sign_Extension__negative_memcpy_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; data = -1; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_53d.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__negative_memcpy_53d_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_53d.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__negative_memcpy_53d_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_13.c", "text": "data = 0; if(GLOBAL_CONST_FIVE==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memmove_13.c", "text": "{ short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = (short)RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_83_bad.cpp", "text": "data = -1; CWE194_Unexpected_Sign_Extension__negative_memmove_83_bad::~CWE194_Unexpected_Sign_Extension__negative_memmove_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memmove_02.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_02_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_64b.c", "text": "void CWE194_Unexpected_Sign_Extension__negative_strncpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_strncpy_64b.c", "text": "void CWE194_Unexpected_Sign_Extension__negative_strncpy_64b_goodG2BSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_15.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_15_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_15.c", "text": "tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_15.c", "text": "data = 0; { case 6: data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_15.c", "text": "{ short data; data = 0; { case 6: data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_memcpy_82_goodG2B.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: rand Set data to result of RAND32(), which could be negative * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE194_Unexpected_Sign_Extension__rand_memcpy_82 { void CWE194_Unexpected_Sign_Extension__rand_memcpy_82_goodG2B::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_02.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_02_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_13.c", "text": "data = 0; if(GLOBAL_CONST_FIVE==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memcpy_13.c", "text": "{ short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_08.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_08_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_45.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { short data = CWE194_Unexpected_Sign_Extension__negative_memmove_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__negative_memmove_45.c", "text": "* GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { short data = CWE194_Unexpected_Sign_Extension__negative_memmove_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE194_Unexpected_Sign_Extension__negative_memmove_45_bad() { short data; data = 0; data = -1; CWE194_Unexpected_Sign_Extension__negative_memmove_45_badData = data; static void goodG2BSink() { short data = CWE194_Unexpected_Sign_Extension__negative_memmove_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_84_goodG2B.cpp", "text": "data = 100-1; CWE194_Unexpected_Sign_Extension__rand_strncpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__rand_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__rand_strncpy_84_goodG2B.cpp", "text": "data = 100-1; } CWE194_Unexpected_Sign_Extension__rand_strncpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__rand_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_01.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_01_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_01.c", "text": "inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_06.c", "text": "void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_06_bad() { short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s02/CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_06.c", "text": "#define CHAR_ARRAY_SIZE 8 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_14.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_14.c", "text": "data = 0; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_14.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_17.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_17.c", "text": "data = 0; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_17.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int h; short data; data = 0; for(h = 0; h < 1; h++) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_83_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_83_goodG2B.cpp", "text": "data = 100-1; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_83_goodG2B::~CWE194_Unexpected_Sign_Extension__fgets_strncpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_54c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b.c", "text": "* GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b_goodG2BSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b.c", "text": "void CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b_goodG2BSink(void * dataVoidPtr) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_84_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_84_goodG2B.cpp", "text": "data = 100-1; } CWE194_Unexpected_Sign_Extension__fscanf_strncpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__fscanf_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_13.c", "text": "{ short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_63b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_63b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_memmove_63b_badSink(short * dataPtr) { short data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_63b.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fgets_memmove_63b_goodG2BSink(short * dataPtr) { short data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_11.c", "text": "data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_11.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_11.c", "text": "data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_11.c", "text": "{ short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22a.c", "text": "int CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22a.c", "text": "data = 0; CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD int CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B2Global = 0; short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B1Source(short data); static void goodG2B1() { short data; data = 0; CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B1Global = 0; data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22a.c", "text": "{ short data; data = 0; CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B1Global = 0; data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B2Source(short data); static void goodG2B2() { short data; data = 0; CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B2Global = 1; data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_61b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_61b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_82_goodG2B.cpp", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_82 { void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_82_goodG2B::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } } void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include \"std_testcase.h\" static short CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_badData; static short CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_goodG2BData; static void badSink() { short data = CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c", "text": "static void badSink() { short data = CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_badData = data; static void goodG2BSink() { short data = CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45.c", "text": "data = 0; fscanf (stdin, \"%hd\", &data); CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_badData = data; static void goodG2BSink() { short data = CWE194_Unexpected_Sign_Extension__fscanf_strncpy_45_goodG2BData; dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68b.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68b_badSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68b.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68b_goodG2BSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_54b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_53a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_31.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_31.c", "text": "data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_31.c", "text": "} else { printLine(\"fgets() failed.\"); } } { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; data = 100-1; { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_34.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_34.c", "text": "data = 0; fscanf (stdin, \"%hd\", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_34.c", "text": "data = 0; fscanf (stdin, \"%hd\", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; CWE194_Unexpected_Sign_Extension__fscanf_memmove_34_unionType myUnion; data = 0; data = 100-1; myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_03.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_03.c", "text": "data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_03.c", "text": "{ short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_03.c", "text": "data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_13.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_32.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_32.c", "text": "* BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_32_bad() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } *dataPtr1 = data; } { short data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_02.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_02.c", "text": "data = 0; if(1) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_02.c", "text": "{ short data; data = 0; if(1) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_44.c", "text": "/* * @description * CWE: 194 Unexpected Sign Extension * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_memmove_44.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_08.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_08.c", "text": "data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_08.c", "text": "{ short data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_17.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_17.c", "text": "data = 0; for(i = 0; i < 1; i++) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_17.c", "text": "int i; short data; data = 0; for(i = 0; i < 1; i++) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int h; short data; data = 0; for(h = 0; h < 1; h++) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_17.c", "text": "data = 0; for(i = 0; i < 1; i++) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_68a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad.cpp", "text": "fscanf (stdin, \"%hd\", &data); } CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad::~CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad.cpp", "text": "fscanf (stdin, \"%hd\", &data); } CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad::~CWE194_Unexpected_Sign_Extension__fscanf_strncpy_83_bad() dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53b_badSink(short data); void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53b_badSink(short data); void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_53a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_65a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_malloc_65b_badSink(short data); void CWE194_Unexpected_Sign_Extension__fscanf_malloc_65_bad() { short data; void (*funcPtr) (short) = CWE194_Unexpected_Sign_Extension__fscanf_malloc_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_65a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_malloc_65b_badSink(short data); void CWE194_Unexpected_Sign_Extension__fscanf_malloc_65_bad() { short data; void (*funcPtr) (short) = CWE194_Unexpected_Sign_Extension__fscanf_malloc_65b_badSink; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_61b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_15.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_15.c", "text": "data = 0; case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_15.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_73a.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_44.c", "text": "if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\\0'; } } void CWE194_Unexpected_Sign_Extension__fscanf_malloc_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_43.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_84a.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_16.c", "text": "{ short data; data = 0; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_54a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_malloc_54b_badSink(short data); void CWE194_Unexpected_Sign_Extension__fscanf_malloc_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_54a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_malloc_54b_badSink(short data); void CWE194_Unexpected_Sign_Extension__fscanf_malloc_54_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_53a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_33.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_33.cpp", "text": "#define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_memmove_33 void bad() { short data; short &dataRef = data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_33.cpp", "text": "} else { printLine(\"fgets() failed.\"); } } { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; short &dataRef = data; data = 0; data = 100-1; { short data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_82_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_82_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fgets_memmove_82.h\" namespace CWE194_Unexpected_Sign_Extension__fgets_memmove_82 { void CWE194_Unexpected_Sign_Extension__fgets_memmove_82_bad::action(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_42.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_42.c", "text": "* BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static short badSource(short data) { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } return data; } void CWE194_Unexpected_Sign_Extension__fgets_memcpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_62a.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_13.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_13.c", "text": "data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_13.c", "text": "{ short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_strncpy_52c_goodG2BSink(short data) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c", "text": "#ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41_badSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41_goodG2BSink(short data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } } void CWE194_Unexpected_Sign_Extension__fscanf_memcpy_41_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_malloc_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_malloc_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_15.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_15.c", "text": "data = 0; case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_15.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_strncpy_43.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_strncpy_43.cpp", "text": "fscanf (stdin, \"%hd\", &data); void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_84_goodG2B.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_84_goodG2B.cpp", "text": "data = 100-1; } CWE194_Unexpected_Sign_Extension__fgets_memcpy_84_goodG2B::~CWE194_Unexpected_Sign_Extension__fgets_memcpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_81_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_81_bad.cpp /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE194_Unexpected_Sign_Extension__fgets_strncpy_81.h\" namespace CWE194_Unexpected_Sign_Extension__fgets_strncpy_81 { void CWE194_Unexpected_Sign_Extension__fgets_strncpy_81_bad::action(short data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memmove_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memmove_82.h /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_53b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_01.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_01.c", "text": "data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_01.c", "text": "{ char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { short data; data = 0; data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b.c", "text": "#define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType; #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b.c", "text": "#define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType; #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType myStruct) dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b.c", "text": "#define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType; #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_goodG2BSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b.c", "text": "#define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType; #ifndef OMITBAD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType myStruct) #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_goodG2BSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType myStruct) dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_52b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fgets_memcpy_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fgets_memcpy_64a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_66b.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_66b.c", "text": "short data = dataArray[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE194_Unexpected_Sign_Extension__fscanf_memmove_66b_goodG2BSink(short dataArray[]) { short data = dataArray[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_68a.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_68a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memmove_68b_badSink(); void CWE194_Unexpected_Sign_Extension__fscanf_memmove_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_68a.c", "text": "void CWE194_Unexpected_Sign_Extension__fscanf_memmove_68b_badSink(); void CWE194_Unexpected_Sign_Extension__fscanf_memmove_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_03.c /* * @description * CWE: 194 Unexpected Sign Extension * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_03.c", "text": "data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_03.c", "text": "{ short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { short data; data = 0; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE194_Unexpected_Sign_Extension/s01/CWE194_Unexpected_Sign_Extension__fscanf_memmove_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE194_Unexpected_Sign_Extension__fscanf_memmove_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_07.c", "text": "#endif size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_07.c", "text": "if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; else { strcat(data, NEW_PATH); } PUTENV(data); static void goodG2B2() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_04.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_01.c", "text": "connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_13.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_file_13_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_13.c", "text": "{ char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; else { strcat(data, NEW_PATH); } PUTENV(data); static void goodG2B2() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_16.c", "text": "{ char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); break; } PUTENV(data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_72a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_32.c", "text": "{ size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; PUTENV(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { char * data = *dataPtr1; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_73a.cpp", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void bad() { char * data; list<char *> dataList; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_62b.cpp", "text": "* GoodSource: Use a hardcoded path * Sinks: * BadSink : Set the environment variable * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_34.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; PUTENV(data); static void goodG2B() { char * data; CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_34_unionType myUnion; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_52a.c", "text": "#define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #ifndef OMITBAD void CWE427_Uncontrolled_Search_Path_Element__char_file_52b_badSink(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_file_52_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE427_Uncontrolled_Search_Path_Element__char_file_52b_badSink(data); #ifndef OMITGOOD void CWE427_Uncontrolled_Search_Path_Element__char_file_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_22b.c", "text": "extern int CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_22_badGlobal; wchar_t * CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_62b.cpp", "text": "* GoodSource: Use a hardcoded path * Sinks: * BadSink : Set the environment variable * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_05.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_33.cpp", "text": "void bad() { char * data; char * &dataRef = data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; PUTENV(data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_08.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE427_Uncontrolled_Search_Path_Element__char_environment_08_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_08.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_environment_08_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; else { strcat(data, NEW_PATH); } PUTENV(data); static void goodG2B2() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_43.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; badSource(data); PUTENV(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_12.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_file_12_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_12.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_file_12_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, NEW_PATH); } PUTENV(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_12.c", "text": "#define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_file_12_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, NEW_PATH); } PUTENV(data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, NEW_PATH); strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_06.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_environment_06_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_06.c", "text": "#define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif void CWE427_Uncontrolled_Search_Path_Element__char_environment_06_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_06.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_environment_06_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; else { strcat(data, NEW_PATH); } PUTENV(data); static void goodG2B2() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_environment_43.cpp", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 250-dataLen-1); void bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; badSource(data); PUTENV(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_file_02.c", "text": "#include <wchar.h> #ifdef _WIN32 #define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_file_02_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } PUTENV(data); static void goodG2B1() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_63a.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_63b_badSink(wchar_t * * dataPtr); void CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_63_bad() { wchar_t * data; wchar_t dataBuffer[250] = L\"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52a.c", "text": "void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52b_badSink(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52b_badSink(data); #ifndef OMITGOOD void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE427_Uncontrolled_Search_Path_Element/CWE427_Uncontrolled_Search_Path_Element__char_console_16.c", "text": "#define NEW_PATH \"%SystemRoot%\\\\system32\" #define PUTENV _putenv #else #define NEW_PATH \"/bin\" void CWE427_Uncontrolled_Search_Path_Element__char_console_16_bad() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; break; } PUTENV(data); static void goodG2B() { char * data; char dataBuffer[250] = \"PATH=\"; data = dataBuffer; strcat(data, NEW_PATH);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE780_Use_of_RSA_Algorithm_Without_OAEP/CWE780_Use_of_RSA_Algorithm_Without_OAEP__w32_14.c", "text": "#pragma comment (lib, \"Advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"String to be encrypted\" if(globalFive==5) { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE780_Use_of_RSA_Algorithm_Without_OAEP/CWE780_Use_of_RSA_Algorithm_Without_OAEP__w32_14.c", "text": "#pragma comment (lib, \"Advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"String to be encrypted\" if(globalFive==5) { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); else { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE780_Use_of_RSA_Algorithm_Without_OAEP/CWE780_Use_of_RSA_Algorithm_Without_OAEP__w32_14.c", "text": "HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); else { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, CRYPT_OAEP, (BYTE *)payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine((BYTE *) payload, payloadLen); if(globalFive==5) { { BYTE payload[200]; DWORD payloadLen = strlen(PAYLOAD); HCRYPTKEY hKey = (HCRYPTKEY)NULL; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_01.c", "text": "void CWE605_Multiple_Binds_Same_Port__basic_01_bad() { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_01.c", "text": "} recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); static void good1() { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_06.c", "text": "#define LISTEN_BACKLOG 5 /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized if(STATIC_CONST_FIVE==5) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE605_Multiple_Binds_Same_Port/CWE605_Multiple_Binds_Same_Port__basic_06.c", "text": "} recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[recvResult] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSACleanup(); } #endif printLine(data); if(STATIC_CONST_FIVE==5) { { char data[100] = \"\"; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_12.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_12.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; strcpy(data, \"hostname\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_12.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; else { strcpy(data, \"hostname\"); } if (!SetComputerNameA(data)) * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"hostname\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_12.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; else { strcpy(data, \"hostname\"); } if (!SetComputerNameA(data)) * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"hostname\"); strcpy(data, \"hostname\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_63a.c", "text": "* GoodSource: Get the hostname from a string literal * Sinks: * BadSink : Set the hostname * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE15_External_Control_of_System_or_Configuration_Setting__w32_63_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_63a.c", "text": "* GoodSource: Get the hostname from a string literal * Sinks: * BadSink : Set the hostname * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE15_External_Control_of_System_or_Configuration_Setting__w32_63_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; WSACleanup(); } } CWE15_External_Control_of_System_or_Configuration_Setting__w32_63b_badSink(&data); #ifndef OMITGOOD void CWE15_External_Control_of_System_or_Configuration_Setting__w32_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"hostname\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_32.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_32.c", "text": "char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; WSACleanup(); } } *dataPtr1 = data; } { char * data = *dataPtr2; if (!SetComputerNameA(data)) static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"hostname\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_17.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE15_External_Control_of_System_or_Configuration_Setting/CWE15_External_Control_of_System_or_Configuration_Setting__w32_17.c", "text": "void CWE15_External_Control_of_System_or_Configuration_Setting__w32_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; int recvResult; { break; } recvResult = recv(acceptSocket, data, 100 - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\\0'; } } } if (!SetComputerNameA(data)) static void goodG2B() { int h; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"hostname\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b.c", "text": "#include \"std_testcase.h\" #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b.c", "text": "#ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_65b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_82.h", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: rand Set data to result of rand(), which may be zero * GoodSource: Positive integer * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_16.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_16.c", "text": "data = -1; while(1) { data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_16.c", "text": "{ int data; data = -1; while(1) { data = -1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; while(1) { data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_04.c", "text": "data = -1; if(STATIC_CONST_TRUE) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_04.c", "text": "{ int data; data = -1; if(STATIC_CONST_TRUE) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_04.c", "text": "{ int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { int data; data = -1; if(STATIC_CONST_TRUE) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_82.h", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45.c", "text": "* GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_bad() { int data; data = -1; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_72b.cpp", "text": "int data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_72b.cpp", "text": "int data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void goodG2BSink(vector<int> dataVector) { int data = dataVector[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_63b_goodG2BSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11.c", "text": "data = -1; if(globalReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11.c", "text": "data = -1; if(globalReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11.c", "text": "{ int data; data = -1; if(globalReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11.c", "text": "{ int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { int data; data = -1; if(globalReturnsTrue()) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_11.c", "text": "data = -1; if(globalReturnsTrue()) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b.c", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b.c", "text": "#ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_65b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18.c", "text": "data = -1; goto source; source: data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18.c", "text": "data = -1; goto source; source: data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18_bad() { int data; data = -1; goto source; source: data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_18.c", "text": "data = -1; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_goodG2B.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_goodG2B::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_goodG2B.cpp", "text": "namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_81_goodG2B::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B.cpp", "text": "data = 100-1; CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_08.c", "text": "data = -1; if(staticReturnsTrue()) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_08.c", "text": "{ int data; data = -1; if(staticReturnsTrue()) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82.h", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_02.c", "text": "data = -1; if(1) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_02.c", "text": "data = -1; if(1) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_strncpy_02.c", "text": "{ int data; data = -1; if(1) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_17.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_17_bad() { int i; int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_17.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int h; int data; data = -1; for(h = 0; h < 1; h++) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_18.c", "text": "data = -1; goto source; source: data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_18.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_18_bad() { int data; data = -1; goto source; source: data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_01.c", "text": "data = -1; data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_01.c", "text": "* BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_01_bad() { int data; data = -1; data = -1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_bad() { int data; data = -1; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_41_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_11.c", "text": "data = -1; if(globalReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_11.c", "text": "{ int data; data = -1; if(globalReturnsTrue()) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: rand Set data to result of rand(), which may be zero * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memcpy_51b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_05.c", "text": "data = -1; if(staticTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_05.c", "text": "{ int data; data = -1; if(staticTrue) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_05.c", "text": "{ int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B2() { int data; data = -1; if(staticTrue) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18_bad() { int data; data = -1; goto source; source: WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18.c", "text": "} recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; goto source; source: data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44.c", "text": "#include \"std_testcase.h\" #ifndef OMITBAD static void badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44.c", "text": "static void badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; data = -1; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_44.c", "text": "#ifndef OMITGOOD static void goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22a.c", "text": "int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22a.c", "text": "{ int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22a.c", "text": "data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Global = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Source(int data); static void goodG2B1() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22a.c", "text": "{ int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22a.c", "text": "{ int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } int CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Source(int data); static void goodG2B2() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Global = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22a.c", "text": "{ int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Global = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_22_goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_03.c", "text": "data = -1; if(5==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_03.c", "text": "{ int data; data = -1; if(5==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_21.c", "text": "static int badStatic = 0; static int badSource(int data) { if(badStatic) { data = RAND32(); } return data; void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_bad.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_82_bad::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_goodG2B.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_goodG2B::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_goodG2B.cpp", "text": "namespace CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_81_goodG2B::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22a.c", "text": "int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22a.c", "text": "data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Global = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Source(int data); static void goodG2B1() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22a.c", "text": "{ int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Global = 0; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B1Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } int CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Source(int data); static void goodG2B2() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Global = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_22_goodG2B2Source(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B.cpp", "text": "data = 100-1; CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_32.c", "text": "data = -1; { int data = *dataPtr1; data = -1; *dataPtr1 = data; } { int data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_01.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_01_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_01.c", "text": "} recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; data = 100-1; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: rand Set data to result of rand(), which may be zero * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_54e_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_17.c", "text": "data = -1; for(i = 0; i < 1; i++) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_17.c", "text": "int i; int data; data = -1; for(i = 0; i < 1; i++) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int h; int data; data = -1; for(h = 0; h < 1; h++) { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_21.c", "text": "static int badStatic = 0; static int badSource(int data) if(badStatic) { data = -1; } return data; void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; while(1) { data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_12.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_12_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_goodG2B.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: negative Set data to a fixed negative number * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_82_goodG2B::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_32.c", "text": "data = -1; { int data = *dataPtr1; data = -1; *dataPtr1 = data; } { int data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_strncpy_32.c", "text": "data = -1; *dataPtr1 = data; } { int data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09.c", "text": "data = -1; if(GLOBAL_CONST_TRUE) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memcpy_09.c", "text": "{ int data; data = -1; if(GLOBAL_CONST_TRUE) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45.c", "text": "#ifndef OMITBAD static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_14.c", "text": "data = -1; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__negative_memmove_14.c", "text": "{ int data; data = -1; if(globalFive==5) { data = -1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B.cpp", "text": "data = 100-1; CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_08.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_08_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_13.c", "text": "data = -1; if(GLOBAL_CONST_FIVE==5) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s02/CWE195_Signed_to_Unsigned_Conversion_Error__rand_memmove_13.c", "text": "{ int data; data = -1; if(GLOBAL_CONST_FIVE==5) { data = RAND32(); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_83_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10.c", "text": "data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10.c", "text": "{ int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b_goodG2BSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65_bad() { int data; void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65_bad() { int data; void (*funcPtr) (int) = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_17.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_17_bad() { int i; int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_51_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22b.c", "text": "extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badGlobal; int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badSource(int data) { if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badGlobal)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22b.c", "text": "extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badGlobal; int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badSource(int data) { if(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_22_badGlobal) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_61b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_62b.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09.c", "text": "data = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09.c", "text": "{ int data; data = -1; if(GLOBAL_CONST_TRUE) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B.cpp", "text": "data = 100-1; } CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B::~CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_84_goodG2B() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83.h /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_goodG2B.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_goodG2B::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_goodG2B.cpp", "text": "namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_goodG2B::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b.c", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67b_goodG2BSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b.c", "text": "memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_52b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84.h /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad.cpp", "text": "* GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84 { CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad::CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad(int dataCopy) { data = dataCopy; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_84_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_09.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_09.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_09_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b.c", "text": "* BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_65b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_61b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_03.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_72a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b.c", "text": "#include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68b_goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_68_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_10.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_10_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_73b.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31.c", "text": "int data; data = -1; fscanf(stdin, \"%d\", &data); { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; data = 100-1; { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_17.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_17_bad() { int i; int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32.c", "text": "data = -1; { int data = *dataPtr1; fscanf(stdin, \"%d\", &data); *dataPtr1 = data; } { int data = *dataPtr2; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad.cpp", "text": "* GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) { CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad::CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad(int dataCopy) { data = dataCopy; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad::~CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_83_bad() { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sinks: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81.h\" namespace CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B::action(int data) const { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b.c", "text": "* GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_goodG2BSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_63b_goodG2BSink(int * dataPtr) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_72a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_67a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c", "text": "* GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68b_goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_68_goodG2BData; dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51b_badSink(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_51_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31.c", "text": "* GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 31 Data flow using a copy of data within the same function #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31.c", "text": "} else { printLine(\"fgets() failed.\"); } } { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; data = 100-1; { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16.c", "text": "data = -1; while(1) { fscanf(stdin, \"%d\", &data); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16.c", "text": "data = -1; while(1) { fscanf(stdin, \"%d\", &data); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; data = -1; while(1) { data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_16.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_16_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34.c", "text": "{ int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_unionType myUnion; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34.c", "text": "inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_unionType myUnion; data = -1; data = 100-1; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42.c", "text": "* GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_53b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_badData; static int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_goodG2BData; static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); } } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_45_goodG2BData; dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15.c", "text": "data = -1; case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_15.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12.c", "text": "data = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_52b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_54c.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_02.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_02_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_54e_goodG2BSink(int data) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_43.cpp", "text": "#ifndef OMITBAD static void badSource(int &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41.c", "text": "{ int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_badSink(data); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_41_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_33.cpp", "text": "void bad() { int data; int &dataRef = data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); #endif } { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_73a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_bad.cpp", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_bad::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_bad.cpp", "text": "namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_82_bad::action(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45.c", "text": "/* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45.c", "text": "{ int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_badData = data; static void goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_45_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_64b.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Positive integer * Sinks: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b.c", "text": "int data = dataArray[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_goodG2BSink(int dataArray[]) { int data = dataArray[2]; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_41_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68a.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_badSink(); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68a.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68b_badSink(); void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memmove_68_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c", "text": "strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_51b_goodG2BSink(int data) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Positive integer * Sink: memcpy * BadSink : Copy strings using memcpy() with the length of data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b.c", "text": "memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_33.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using memcpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_33.cpp", "text": "data = -1; fscanf(stdin, \"%d\", &data); { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_33.cpp", "text": "int data; int &dataRef = data; data = -1; fscanf(stdin, \"%d\", &data); { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B() { int data; int &dataRef = data; data = -1; data = 100-1; { int data = dataRef; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memcpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_memcpy_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_16.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_16_bad() { int data; data = -1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d.c", "text": "* BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_goodG2BSink(int data) { { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d.c", "text": "void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_goodG2BSink(int data) dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_bad()", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c", "text": "#ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06_bad() data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); dest[data] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_06.c", "text": "{ int data; data = -1; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; else { data = 100-1; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15.c", "text": "data = -1; case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_15.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); static void goodG2B1() { int data; data = -1; break; default: data = 100-1; break; } { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_malloc_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fscanf Read data from the console using fscanf() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42.c", "text": "fscanf(stdin, \"%d\", &data); return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42.c", "text": "fscanf(stdin, \"%d\", &data); return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__fscanf_strncpy_42_bad() dest[data] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_74b.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b.c /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * GoodSource: Positive integer * Sink: memmove * BadSink : Copy strings using memmove() with the length of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b.c", "text": "#include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_goodG2BData; #ifndef OMITBAD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\\0'; } printLine(dest); #ifndef OMITGOOD void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_goodG2BSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_goodG2BData; { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, memmove(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_43.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using strncpy() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_43.cpp", "text": "* GoodSource: Positive integer * Sinks: strncpy * BadSink : Copy strings using strncpy() with the length of data * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #include \"std_testcase.h\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_43 #ifndef OMITBAD static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(\"fgets() failed.\"); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = \"\"; memset(source, 'A', 100-1); source[100-1] = '\\0'; if (data < 100) { /* POTENTIAL FLAW: data is interpreted as an unsigned int - if its value is negative, strncpy(dest, source, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE195_Signed_to_Unsigned_Conversion_Error/s01/CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_62a.cpp /* * @description * CWE: 195 Signed to Unsigned Conversion Error * BadSource: fgets Read data from the console using fgets() * BadSink : Copy strings using memmove() with the length of data", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_08.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" if(staticReturnsTrue()) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_08.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" if(staticReturnsTrue()) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); else { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE685_Function_Call_With_Incorrect_Number_of_Arguments/CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_08.c", "text": "#include \"std_testcase.h\" #define DEST_SIZE 100 #define SOURCE_STRING \"AAA\" if(staticReturnsTrue()) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING); printLine(dest); else { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING); printLine(dest); if(staticReturnsTrue()) { { char dest[DEST_SIZE]; sprintf(dest, \"%s %s\", SOURCE_STRING, SOURCE_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE321_Hard_Coded_Cryptographic_Key/CWE321_Hard_Coded_Cryptographic_Key__w32_wchar_t_34.c", "text": "HCRYPTPROV hCryptProv; HCRYPTKEY hKey; HCRYPTHASH hHash; wchar_t toBeEncrypted[] = L\"String to be encrypted\"; DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t); BYTE encrypted[200]; memcpy(encrypted, toBeEncrypted, encryptedLen); } if(!CryptEncrypt(hKey, (HCRYPTHASH)NULL, 1, 0, encrypted, &encryptedLen, sizeof(encrypted))) printLine(\"Error in CryptEncrypt\"); exit(1); } printBytesLine(encrypted, encryptedLen); cryptoKey = cryptoKeyBuffer; { size_t cryptoKeyLen = wcslen(cryptoKey); HCRYPTPROV hCryptProv; HCRYPTKEY hKey; HCRYPTHASH hHash; wchar_t toBeEncrypted[] = L\"String to be encrypted\"; DWORD encryptedLen = wcslen(toBeEncrypted)*sizeof(wchar_t); BYTE encrypted[200]; memcpy(encrypted, toBeEncrypted, encryptedLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE321_Hard_Coded_Cryptographic_Key/CWE321_Hard_Coded_Cryptographic_Key__w32_char_11.c", "text": "/* * @description * CWE: 321 Use of Hard-coded Cryptographic Key * BadSource: Copy a hardcoded value into cryptoKey * GoodSource: Read cryptoKey from the console * Sink: * BadSink : Hash cryptoKey and use the value to encrypt a string #include \"std_testcase.h\" #define CRYPTO_KEY \"Hardcoded\" void CWE321_Hard_Coded_Cryptographic_Key__w32_char_11_bad() { char * cryptoKey; char cryptoKeyBuffer[100] = \"\"; cryptoKey = cryptoKeyBuffer; strcpy(cryptoKey, CRYPTO_KEY);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE321_Hard_Coded_Cryptographic_Key/CWE321_Hard_Coded_Cryptographic_Key__w32_char_43.cpp", "text": "/* * @description * CWE: 321 Use of Hard-coded Cryptographic Key * BadSource: Copy a hardcoded value into cryptoKey * GoodSource: Read cryptoKey from the console * Sinks: * BadSink : Hash cryptoKey and use the value to encrypt a string #include \"std_testcase.h\" #define CRYPTO_KEY \"Hardcoded\" #ifndef OMITBAD static void badSource(char * &cryptoKey) strcpy(cryptoKey, CRYPTO_KEY);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE321_Hard_Coded_Cryptographic_Key/CWE321_Hard_Coded_Cryptographic_Key__w32_char_02.c", "text": "/* * @description * CWE: 321 Use of Hard-coded Cryptographic Key * BadSource: Copy a hardcoded value into cryptoKey * GoodSource: Read cryptoKey from the console * Sink: * BadSink : Hash cryptoKey and use the value to encrypt a string #include \"std_testcase.h\" #define CRYPTO_KEY \"Hardcoded\" void CWE321_Hard_Coded_Cryptographic_Key__w32_char_02_bad() { char * cryptoKey; char cryptoKeyBuffer[100] = \"\"; cryptoKey = cryptoKeyBuffer; strcpy(cryptoKey, CRYPTO_KEY);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE321_Hard_Coded_Cryptographic_Key/CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad.cpp", "text": "/* * @description * CWE: 321 Use of Hard-coded Cryptographic Key * BadSource: Copy a hardcoded value into cryptoKey * GoodSource: Read cryptoKey from the console * Sinks: * BadSink : Hash cryptoKey and use the value to encrypt a string #include \"std_testcase.h\" #include \"CWE321_Hard_Coded_Cryptographic_Key__w32_char_83.h\" #define CRYPTO_KEY \"Hardcoded\" { CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad::CWE321_Hard_Coded_Cryptographic_Key__w32_char_83_bad(char * cryptoKeyCopy) { cryptoKey = cryptoKeyCopy; strcpy(cryptoKey, CRYPTO_KEY);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_62b.cpp", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(badStruct &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__connect_socket_12.c", "text": "void CWE123_Write_What_Where_Condition__connect_socket_12_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_64a.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE123_Write_What_Where_Condition__listen_socket_64_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_34.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE123_Write_What_Where_Condition__listen_socket_34_bad() { badStruct data; CWE123_Write_What_Where_Condition__listen_socket_34_unionType myUnion; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_72a.cpp", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { badStruct data; vector<badStruct> dataVector; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_21.c", "text": "static int badStatic = 0; static badStruct badSource(badStruct data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_31.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sinks: * BadSink : Remove element from list * Flow Variant: 31 Data flow using a copy of data within the same function void CWE123_Write_What_Where_Condition__listen_socket_31_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_68a.c", "text": "* GoodSource: Don't overwrite linked list pointers * Sink: * BadSink : Remove element from list * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE123_Write_What_Where_Condition__listen_socket_68_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_03.c", "text": "void CWE123_Write_What_Where_Condition__listen_socket_03_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE123_Write_What_Where_Condition/CWE123_Write_What_Where_Condition__listen_socket_13.c", "text": "void CWE123_Write_What_Where_Condition__listen_socket_13_bad() { badStruct data; linkedList head = { &head, &head }; data.list.next = head.next; data.list.prev = head.prev; head.next = &data.list; head.prev = &data.list; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, (char*)&data, sizeof(data), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_03.c", "text": "void CWE665_Improper_Initialization__char_ncat_03_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(5==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_03.c", "text": "; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_03.c", "text": "if(5!=5) { printLine(\"Benign, fixed string\"); } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_03.c", "text": "* BadSource: Do not initialize data properly * GoodSource: Initialize data * Sink: ncat * BadSink : Copy string to data using strncat void CWE665_Improper_Initialization__char_ncat_03_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(5==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_03.c", "text": "static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(5==5) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_03.c", "text": "sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(5==5) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_43.cpp", "text": "static void badSource(char * &data) { ; } void bad() { char * data; char dataBuffer[100]; data = dataBuffer; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_43.cpp", "text": "void bad() { char * data; char dataBuffer[100]; data = dataBuffer; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_43.cpp", "text": "static void goodG2BSource(char * &data) { data[0] = '\\0'; } static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_43.cpp", "text": "* GoodSource: Initialize data * Sinks: cat * BadSink : Copy string to data using strcat * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(char * &data) { void bad() { char * data; char dataBuffer[100]; data = dataBuffer; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { data[0] = '\\0'; static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_08.c", "text": "#ifndef OMITBAD void CWE665_Improper_Initialization__char_cat_08_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { ; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_08.c", "text": "; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_08.c", "text": "char dataBuffer[100]; data = dataBuffer; if(staticReturnsFalse()) { printLine(\"Benign, fixed string\"); } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_08.c", "text": "* @description * CWE: 665 Improper Initialization * BadSource: Do not initialize data properly * GoodSource: Initialize data * Sink: cat * BadSink : Copy string to data using strcat void CWE665_Improper_Initialization__char_cat_08_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { ; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_08.c", "text": "static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_08.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_83_bad.cpp", "text": "namespace CWE665_Improper_Initialization__char_cat_83 { CWE665_Improper_Initialization__char_cat_83_bad::CWE665_Improper_Initialization__char_cat_83_bad(char * dataCopy) { data = dataCopy; ; } CWE665_Improper_Initialization__char_cat_83_bad::~CWE665_Improper_Initialization__char_cat_83_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_83_bad.cpp", "text": "CWE665_Improper_Initialization__char_cat_83_bad::~CWE665_Improper_Initialization__char_cat_83_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_68b.c", "text": "#include <wchar.h> extern char * CWE665_Improper_Initialization__char_cat_68_badData; extern char * CWE665_Improper_Initialization__char_cat_68_goodG2BData; #ifndef OMITBAD void CWE665_Improper_Initialization__char_cat_68b_badSink() { char * data = CWE665_Improper_Initialization__char_cat_68_badData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_68b.c", "text": "printLine(data); } } #endif #ifndef OMITGOOD void CWE665_Improper_Initialization__char_cat_68b_goodG2BSink() { char * data = CWE665_Improper_Initialization__char_cat_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_68b.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); void CWE665_Improper_Initialization__char_cat_68b_goodG2BSink() { char * data = CWE665_Improper_Initialization__char_cat_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_31.c", "text": "void CWE665_Improper_Initialization__char_ncat_31_bad() { char * data; char dataBuffer[100]; data = dataBuffer; ; { char * dataCopy = data; char * data = dataCopy; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_31.c", "text": "; { char * dataCopy = data; char * data = dataCopy; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_31.c", "text": "static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_31.c", "text": "* GoodSource: Initialize data * Sinks: ncat * BadSink : Copy string to data using strncat * Flow Variant: 31 Data flow using a copy of data within the same function void CWE665_Improper_Initialization__char_ncat_31_bad() { char * data; char dataBuffer[100]; data = dataBuffer; ; { char * dataCopy = data; char * data = dataCopy; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_82_bad.cpp", "text": "* * */ #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE665_Improper_Initialization__char_cat_82.h\" namespace CWE665_Improper_Initialization__char_cat_82 { void CWE665_Improper_Initialization__char_cat_82_bad::action(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_53d.c", "text": "* */ #include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE665_Improper_Initialization__char_cat_53d_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_53d.c", "text": "strcat(data, source); printLine(data); } } #endif #ifndef OMITGOOD void CWE665_Improper_Initialization__char_cat_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_53d.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); #ifndef OMITGOOD void CWE665_Improper_Initialization__char_cat_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_65b.c", "text": "* Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer * * */ #include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE665_Improper_Initialization__char_cat_65b_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_65b.c", "text": "strcat(data, source); printLine(data); } } #endif #ifndef OMITGOOD void CWE665_Improper_Initialization__char_cat_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_65b.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); #ifndef OMITGOOD void CWE665_Improper_Initialization__char_cat_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_84_goodG2B.cpp", "text": "{ CWE665_Improper_Initialization__char_ncat_84_goodG2B::CWE665_Improper_Initialization__char_ncat_84_goodG2B(char * dataCopy) { data = dataCopy; data[0] = '\\0'; } CWE665_Improper_Initialization__char_ncat_84_goodG2B::~CWE665_Improper_Initialization__char_ncat_84_goodG2B() { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_84_goodG2B.cpp", "text": "data[0] = '\\0'; CWE665_Improper_Initialization__char_ncat_84_goodG2B::~CWE665_Improper_Initialization__char_ncat_84_goodG2B() { { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_62a.cpp", "text": "#ifndef OMITBAD void badSource(char * &data); void bad() { char * data; char dataBuffer[100]; data = dataBuffer; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; char dataBuffer[100]; data = dataBuffer; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_62a.cpp", "text": "#ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_62a.cpp", "text": "* @description * CWE: 665 Improper Initialization * BadSource: Do not initialize data properly * GoodSource: Initialize data * Sinks: cat * BadSink : Copy string to data using strcat * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; char dataBuffer[100]; data = dataBuffer; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_06.c", "text": "void CWE665_Improper_Initialization__char_ncat_06_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(STATIC_CONST_FIVE==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_06.c", "text": "#include <wchar.h> void CWE665_Improper_Initialization__char_ncat_06_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(STATIC_CONST_FIVE==5) { ; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_06.c", "text": "sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(STATIC_CONST_FIVE==5) { data[0] = '\\0'; } { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_cat_07.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticFive==5) { data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_74b.cpp", "text": "namespace CWE665_Improper_Initialization__char_ncat_74 { #ifndef OMITBAD void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_74b.cpp", "text": "char * data = dataMap[2]; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_74b.cpp", "text": "} #endif #ifndef OMITGOOD void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE665_Improper_Initialization/CWE665_Improper_Initialization__char_ncat_74b.cpp", "text": "char * data = dataMap[2]; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen); printLine(data); void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { size_t sourceLen; char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; sourceLen = strlen(source); strncat(data, source, sourceLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_18.c", "text": "data = -1; goto source; source: fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_11.c", "text": "data = -1; if(globalReturnsTrue()) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_68a.c", "text": "void CWE197_Numeric_Truncation_Error__short_fscanf_68b_badSink(); void CWE197_Numeric_Truncation_Error__short_fscanf_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_68a.c", "text": "void CWE197_Numeric_Truncation_Error__short_fscanf_68b_badSink(); void CWE197_Numeric_Truncation_Error__short_fscanf_68_bad() { short data; data = -1; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_41.c", "text": "char charData = (char)data; } } void CWE197_Numeric_Truncation_Error__short_fscanf_41_bad() { short data; data = -1; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_14.c", "text": "data = -1; if(globalFive==5) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_17.c", "text": "data = -1; for(i = 0; i < 1; i++) { fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s02/CWE197_Numeric_Truncation_Error__short_fscanf_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__short_fscanf_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_41.c", "text": "char charData = (char)data; } } void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_41_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67b_badSink(CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67_structType myStruct); void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67_bad() { int data; CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67b_badSink(CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67_structType myStruct); void CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67_bad() { int data; CWE197_Numeric_Truncation_Error__int_fscanf_to_char_67_structType myStruct; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53b_badSink(int data); void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53a.c", "text": "void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53b_badSink(int data); void CWE197_Numeric_Truncation_Error__int_fscanf_to_short_53_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_74a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82.h\" namespace CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82.h\" namespace CWE197_Numeric_Truncation_Error__int_fscanf_to_short_82 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_char_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE197_Numeric_Truncation_Error/s01/CWE197_Numeric_Truncation_Error__int_fscanf_to_short_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE197_Numeric_Truncation_Error__int_fscanf_to_short_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_11.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_11.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_system_45.c", "text": "#define SYSTEM system #endif static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_system_45_badData; static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_system_45_goodG2BData; static void badSink() { wchar_t * data = CWE78_OS_Command_Injection__wchar_t_connect_socket_system_45_badData; if (SYSTEM(data) != 0) void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_45_bad() { wchar_t * data; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45.c", "text": "#include <process.h> static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45_badData; static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45_goodG2BData; static void badSink() { wchar_t * data = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45_badData; { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_system_41.c", "text": "* GoodSource: Fixed string * Sink: system * BadSink : Execute command in data using system() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_41_badSink(wchar_t * data) { if (SYSTEM(data) != 0) void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_41_bad() { wchar_t * data; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_15.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_15.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; switch(6) { case 6: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_04.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #define EXECV _wexecv connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_52a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_52b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_52a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_52b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_52_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_33.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with wexecv * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_45.c", "text": "#endif static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_45_badData; static wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_45_goodG2BData; static void badSink() { wchar_t * data = CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_45_badData; { FILE *pipe; pipe = POPEN(data, L\"w\"); void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_45_bad() { wchar_t * data; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_52a.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnv * BadSink : execute command with spawnv * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_67a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data typedef struct _CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_67_structType { wchar_t * structFirst; void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_67_bad() { wchar_t * data; CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_67_structType myStruct; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_43.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badSource(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_67a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data typedef struct _CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_67_structType { wchar_t * structFirst; void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_67_bad() { wchar_t * data; CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_67_structType myStruct; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_51a.c", "text": "void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_51b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_51_bad() { wchar_t * data; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_52a.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_81a.cpp", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_81_base& baseObject = CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_66a.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_66b_badSink(wchar_t * dataArray[]); void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_66_bad() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_33.cpp", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with wspawnl * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnvp * BadSink : execute command with wspawnvp * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_64_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s05/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_34.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data typedef union { wchar_t * unionFirst; wchar_t * unionSecond; void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_34_bad() { wchar_t * data; CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_34_unionType myUnion; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_53a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_spawnvp_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_spawnvp_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_18.c", "text": "/* * @description * CWE: 78 OS Command Injection * BadSource: console Read input from the console * GoodSource: Fixed string * Sink: system * BadSink : Execute command in data using system()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_18.c", "text": "{ char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; source: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; goto source; source: strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_45.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_execvp_45_badData = data; static void goodG2BSink() { char * data = CWE78_OS_Command_Injection__char_console_w32_execvp_45_goodG2BData; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnlp_66a.c", "text": "void CWE78_OS_Command_Injection__char_console_w32_spawnlp_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_83_goodG2B.cpp", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE78_OS_Command_Injection__char_console_w32spawnl_83_goodG2B::CWE78_OS_Command_Injection__char_console_w32spawnl_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnlp_31.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_spawnlp_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_41.c", "text": "void CWE78_OS_Command_Injection__char_environment_execlp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_41.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_execlp_41_badSink(char * data) void CWE78_OS_Command_Injection__char_environment_execlp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_execlp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_execlp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_43.cpp", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badSource(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_06.c", "text": "{ char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_06.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } if (SYSTEM(data) != 0) static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_09.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_spawnvp_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_07.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_03.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_spawnv_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_64a.c", "text": "* GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE78_OS_Command_Injection__char_console_popen_64_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_popen_64b_badSink(&data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_66a.c", "text": "void CWE78_OS_Command_Injection__char_console_w32_spawnvp_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_11.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_execvp_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_11.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_54a.c", "text": "void CWE78_OS_Command_Injection__char_environment_execlp_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_execlp_54_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_54a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_execlp_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_execlp_54_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_execlp_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_execlp_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_08.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execlp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_08.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execlp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_08.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_execvp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_08.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_02.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_popen_02_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_02.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(1) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_54a.c", "text": "{ char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_system_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_system_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_16.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execl_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_06.c", "text": "void CWE78_OS_Command_Injection__char_environment_execlp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_06.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif void CWE78_OS_Command_Injection__char_environment_execlp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_06.c", "text": "#endif void CWE78_OS_Command_Injection__char_environment_execlp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_61b.c", "text": "* GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * CWE78_OS_Command_Injection__char_console_popen_61b_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_console_popen_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_42.c", "text": "#ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE78_OS_Command_Injection__char_console_w32_execvp_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_10.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32spawnl_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_53a.c", "text": "void CWE78_OS_Command_Injection__char_environment_execl_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_execl_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_53a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_execl_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_execl_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_execl_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_execl_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_16.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_popen_16_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; while(1) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_65a.c", "text": "void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_w32spawnl_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32spawnl_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_w32spawnl_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_51a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32spawnl_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32spawnl_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_system_82.h", "text": "/* * @description * CWE: 78 OS Command Injection * BadSource: environment Read input from an environment variable * GoodSource: Fixed string * BadSink : Execute command in data using system()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_66a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_execl_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execl_33.cpp", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * data = dataRef; static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_04.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_18.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_popen_18_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; goto source; source: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_82a.cpp", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_execlp_82_base* baseObject = new CWE78_OS_Command_Injection__char_environment_execlp_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execv_65a.c", "text": "void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_w32_execv_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_execv_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_w32_execv_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execv_12.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_execv_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_system_17.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sink: system * BadSink : Execute command in data using system() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_system_17_bad() { int i; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } if (SYSTEM(data) != 0) static void goodG2B() { int h; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(h = 0; h < 1; h++) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_82a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE78_OS_Command_Injection__char_console_w32_spawnvp_82_base* baseObject = new CWE78_OS_Command_Injection__char_console_w32_spawnvp_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_environment_execlp_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_execlp_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_execlp_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_22b.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE78_OS_Command_Injection__char_environment_execlp_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_execlp_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_execlp_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE78_OS_Command_Injection__char_environment_execlp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_environment_execlp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_execlp_22b.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE78_OS_Command_Injection__char_environment_execlp_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_execlp_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_execlp_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE78_OS_Command_Injection__char_environment_execlp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_environment_execlp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_environment_execlp_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_environment_execlp_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_system_74a.cpp", "text": "* GoodSource: Fixed string * Sinks: system * BadSink : Execute command in data using system() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; map<int, char *> dataMap; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_05.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_system_81a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Fixed string * Sinks: system * BadSink : Execute command in data using system() * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } const CWE78_OS_Command_Injection__char_environment_system_81_base& baseObject = CWE78_OS_Command_Injection__char_environment_system_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_16.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_spawnvp_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_system_17.c", "text": "int i; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B() { int h; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(h = 0; h < 1; h++) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnvp_08.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_w32_spawnvp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_environment_popen_31.c", "text": "* GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 31 Data flow using a copy of data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_popen_31_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execv_41.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_execv_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_execv_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_execvp_67a.c", "text": "void CWE78_OS_Command_Injection__char_console_w32_execvp_67_bad() { char * data; CWE78_OS_Command_Injection__char_console_w32_execvp_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_console_w32_execvp_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_22b.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data extern int CWE78_OS_Command_Injection__char_console_w32spawnl_22_badGlobal; char * CWE78_OS_Command_Injection__char_console_w32spawnl_22_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_w32spawnl_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_w32spawnl_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32spawnl_22b.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_console_w32spawnl_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_console_w32spawnl_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_console_w32spawnl_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_console_w32spawnl_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_popen_06.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s02/CWE78_OS_Command_Injection__char_console_w32_spawnv_53a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_w32_spawnv_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_w32_spawnv_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_81a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sinks: system * BadSink : Execute command in data using system() * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE78_OS_Command_Injection__char_file_system_81_base& baseObject = CWE78_OS_Command_Injection__char_file_system_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnv_51a.c", "text": "void CWE78_OS_Command_Injection__char_environment_w32_spawnv_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnv_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnv_51a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_w32_spawnv_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnv_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_spawnv_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_w32_spawnv_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_68a.c", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE78_OS_Command_Injection__char_file_popen_68_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_popen_68_badData = data; static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_44.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) { void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_44.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_32.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32_execvp_66a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_execvp_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_73a.cpp", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void bad() { char * data; list<char *> dataList; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) void CWE78_OS_Command_Injection__char_file_execlp_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_15.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_15.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; switch(6) { case 6: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_42.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; void CWE78_OS_Command_Injection__char_environment_w32spawnl_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_10.c", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sink: system * BadSink : Execute command in data using system() void CWE78_OS_Command_Injection__char_file_system_10_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_10.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } if (SYSTEM(data) != 0) static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22b.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22b.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv extern int CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badGlobal; char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badSource(char * data) if(CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_badGlobal) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; extern int CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_environment_w32_spawnvp_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_54a.c", "text": "void CWE78_OS_Command_Injection__char_environment_w32_execvp_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_execvp_54_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_54a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_w32_execvp_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_execvp_54_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_execvp_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_w32_execvp_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_44.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) { char *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_44.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_72a.cpp", "text": "* GoodSource: Fixed string * Sinks: system * BadSink : Execute command in data using system() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_61b.c", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with execvp * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * CWE78_OS_Command_Injection__char_environment_w32_execvp_61b_badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_environment_w32_execvp_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_63a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_63_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_execv_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_w32_execv_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_31.c", "text": "* GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE78_OS_Command_Injection__char_file_popen_31_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_11.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_11.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_34.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_34_bad() { char * data; CWE78_OS_Command_Injection__char_environment_w32spawnl_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_environment_w32spawnl_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_81a.cpp", "text": "* GoodSource: Fixed string * Sinks: execl * BadSink : execute command with execl * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE78_OS_Command_Injection__char_file_execl_81_base& baseObject = CWE78_OS_Command_Injection__char_file_execl_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_10.c", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sink: popen * BadSink : Execute command in data using popen() void CWE78_OS_Command_Injection__char_file_popen_10_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_10.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_popen_44.c", "text": "void CWE78_OS_Command_Injection__char_file_popen_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_13.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_13.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52a.c", "text": "void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_09.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execlp_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_09.c", "text": "void CWE78_OS_Command_Injection__char_file_execlp_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_51a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_execl_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_execl_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_execl_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_execl_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_08.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_08.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_05.c", "text": "void CWE78_OS_Command_Injection__char_file_execl_05_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_61b.c", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD char * CWE78_OS_Command_Injection__char_file_execlp_61b_badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_file_execlp_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51a.c", "text": "void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_environment_w32_spawnlp_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_14.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_14.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_82.h", "text": "/* * @description * CWE: 78 OS Command Injection * BadSource: file Read input from a file * GoodSource: Fixed string * BadSink : Execute command in data using system()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_10.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_10.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_51a.c", "text": "* GoodSource: Fixed string * Sink: system * BadSink : Execute command in data using system() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_system_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_system_51_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_system_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_system_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_53a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32spawnl_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_w32spawnl_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32spawnl_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32spawnl_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_08.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execlp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_08.c", "text": "void CWE78_OS_Command_Injection__char_file_execlp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_system_64a.c", "text": "* BadSource: file Read input from a file * GoodSource: Fixed string * Sinks: system * BadSink : Execute command in data using system() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE78_OS_Command_Injection__char_file_system_64_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_system_64b_badSink(&data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_66a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32spawnl_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_07.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #define EXECV _execv size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_07.c", "text": "#define EXECV _execv size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with execv * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_64_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE78_OS_Command_Injection__char_environment_w32_execv_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execlp_82a.cpp", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE78_OS_Command_Injection__char_file_execlp_82_base* baseObject = new CWE78_OS_Command_Injection__char_file_execlp_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32_execvp_81a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with execvp * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE78_OS_Command_Injection__char_file_w32_execvp_81_base& baseObject = CWE78_OS_Command_Injection__char_file_w32_execvp_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_32.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32spawnl_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_14.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_14.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execv_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_execl_68a.c", "text": "* GoodSource: Fixed string * Sink: execl * BadSink : execute command with execl * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_execl_68_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_execl_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32spawnl_62b.cpp", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); #ifndef OMITGOOD void goodG2BSource(char * &data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32_execvp_54a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32_execvp_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_w32_execvp_54_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_execvp_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32_execvp_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_31.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnv_42.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; void CWE78_OS_Command_Injection__char_environment_w32_spawnv_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_11.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32spawnl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_11.c", "text": "void CWE78_OS_Command_Injection__char_file_w32spawnl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execv_84_goodG2B.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with execv * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE78_OS_Command_Injection__char_environment_w32_execv_84_goodG2B::CWE78_OS_Command_Injection__char_environment_w32_execv_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_spawnvp_18.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_spawnvp_18_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_file_w32spawnl_15.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32spawnl_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s03/CWE78_OS_Command_Injection__char_environment_w32_execvp_66a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE78_OS_Command_Injection__char_environment_w32_execvp_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_67a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnv_67_bad() { char * data; CWE78_OS_Command_Injection__char_file_w32_spawnv_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_file_w32_spawnv_67_structType myStruct; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_54a.c", "text": "* GoodSource: Fixed string * Sink: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_54_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_54a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_33.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * data = dataRef; { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char * &dataRef = data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_63a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_execv_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_42.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_17.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_execv_17_bad() { int i; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B() { int h; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; for(h = 0; h < 1; h++) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execlp_42.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void CWE78_OS_Command_Injection__char_listen_socket_execlp_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_11.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnlp_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_11.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_spawnlp_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_41.c", "text": "* GoodSource: Fixed string * Sink: w32_execvp * BadSink : execute command with execvp * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_41_badSink(char * data) void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_41.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_22b.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data extern int CWE78_OS_Command_Injection__char_file_w32_spawnv_22_badGlobal; char * CWE78_OS_Command_Injection__char_file_w32_spawnv_22_badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_file_w32_spawnv_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_file_w32_spawnv_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_file_w32_spawnv_22_badGlobal; char * CWE78_OS_Command_Injection__char_file_w32_spawnv_22_badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE78_OS_Command_Injection__char_file_w32_spawnv_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_file_w32_spawnv_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_file_w32_spawnv_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_file_w32_spawnv_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execlp_41.c", "text": "* GoodSource: Fixed string * Sink: execlp * BadSink : execute command with execlp * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink(char * data) void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execlp_41.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_63a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execlp_52a.c", "text": "* GoodSource: Fixed string * Sink: execlp * BadSink : execute command with execlp * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_execlp_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_execlp_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execlp_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_execlp_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_execlp_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_14.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnv_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_14.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_spawnv_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_73a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_31.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnv_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_44.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Fixed string * Sinks: popen * BadSink : Execute command in data using popen() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { FILE *pipe; pipe = POPEN(data, \"w\"); void CWE78_OS_Command_Injection__char_listen_socket_popen_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_44.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_41.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32_spawnv_41_badSink(char * data) void CWE78_OS_Command_Injection__char_file_w32_spawnv_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_spawnv_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32_spawnv_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_03.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnlp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_03.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_spawnlp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with execv * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_execv_64_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_execv_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnlp_64_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_spawnlp_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execlp_81a.cpp", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE78_OS_Command_Injection__char_listen_socket_execlp_81_base& baseObject = CWE78_OS_Command_Injection__char_listen_socket_execlp_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_05.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_execv_05_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnvp_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) void CWE78_OS_Command_Injection__char_file_w32_spawnvp_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnvp_51a.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_file_w32_spawnvp_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_file_w32_spawnvp_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_file_w32_spawnvp_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_file_w32_spawnvp_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_listen_socket_popen_22_badGlobal; char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_22b.c", "text": "extern int CWE78_OS_Command_Injection__char_listen_socket_popen_22_badGlobal; char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; extern int CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_22b.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; extern int CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B2Global; char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; } char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B2Source(char * data) { if(CWE78_OS_Command_Injection__char_listen_socket_popen_22_goodG2B2Global) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_83_goodG2B.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE78_OS_Command_Injection__char_file_w32_spawnlp_83_goodG2B::CWE78_OS_Command_Injection__char_file_w32_spawnlp_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_execv_81a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with execv * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE78_OS_Command_Injection__char_file_w32_execv_81_base& baseObject = CWE78_OS_Command_Injection__char_file_w32_execv_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_15.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnv_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_execlp_64a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_execlp_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_system_07.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } if (SYSTEM(data) != 0) static void goodG2B1() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; } else { strcat(data, \"*.*\"); } if (SYSTEM(data) != 0) static void goodG2B2() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_52a.c", "text": "void CWE78_OS_Command_Injection__char_listen_socket_popen_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_popen_52_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_popen_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_popen_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_52a.c", "text": "* GoodSource: Fixed string * Sink: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_52_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnvp_03.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnvp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnvp_03.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_spawnvp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_51a.c", "text": "* GoodSource: Fixed string * Sink: w32_execv * BadSink : execute command with execv * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_51a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_w32_execv_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_31.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnlp_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_32.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } *dataPtr1 = data; } { char * data = *dataPtr2; { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char data_buf[100] = FULL_COMMAND; data = data_buf; { char * data = *dataPtr1; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_14.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_file_w32_spawnlp_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnlp_14.c", "text": "void CWE78_OS_Command_Injection__char_file_w32_spawnlp_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_file_w32_spawnv_81a.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_spawnv * BadSink : execute command with spawnv * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE78_OS_Command_Injection__char_file_w32_spawnv_81_base& baseObject = CWE78_OS_Command_Injection__char_file_w32_spawnv_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_17.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { int h; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(h = 0; h < 1; h++) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_system_43.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; badSource(data); if (SYSTEM(data) != 0) #ifndef OMITGOOD static void goodG2BSource(char * &data) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_21.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_21.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { strcat(data, \"*.*\"); } return data; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_53a.c", "text": "void CWE78_OS_Command_Injection__char_listen_socket_popen_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_listen_socket_popen_53_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_popen_53a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_popen_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_listen_socket_popen_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s04/CWE78_OS_Command_Injection__char_listen_socket_system_64a.c", "text": "{ char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_listen_socket_system_64b_badSink(&data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_34.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_34_bad() { char * data; CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_34.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_09.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execl_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execv_65a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_65b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_65_bad() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_w32_execv_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execv_65a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_w32_execv_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_74a.cpp", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_74a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_68a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_68_badData = data; static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_61b.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_connect_socket_execl_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_33.cpp", "text": "* GoodSource: Fixed string * Sinks: w32spawnl * BadSink : execute command with spawnl * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_05.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_05.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\"); static void goodG2B2() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticTrue) { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63a.c", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with execvp * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_52a.c", "text": "{ char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE78_OS_Command_Injection__char_console_execl_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_execl_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_52a.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_popen_52b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_popen_52_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_52a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_52b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_popen_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_82_base* baseObject = new CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_61b.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD char * CWE78_OS_Command_Injection__char_console_execlp_61b_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_console_execlp_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_34.c", "text": "void CWE78_OS_Command_Injection__char_console_execlp_34_bad() { char * data; CWE78_OS_Command_Injection__char_console_execlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_console_execlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_63a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_popen_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_51a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_execl_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_execl_51_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_51a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_execl_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_execl_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_84_goodG2B.cpp", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE78_OS_Command_Injection__char_console_execlp_84_goodG2B::CWE78_OS_Command_Injection__char_console_execlp_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_65a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_execl_65b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_execl_65_bad() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_execl_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_65a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_execl_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_execl_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_67a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE78_OS_Command_Injection__char_connect_socket_popen_67_structType myStruct; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_53a.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_popen_53b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_popen_53_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_53a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_53b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_popen_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_64a.c", "text": "* GoodSource: Fixed string * Sinks: execlp * BadSink : execute command with execlp * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_execlp_64_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_64a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_execlp_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execv_33.cpp", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with execv * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_81a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_81_base& baseObject = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_popen_01.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } { FILE *pipe; pipe = POPEN(data, \"w\"); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_64a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnvp * BadSink : execute command with spawnvp * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_64_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_64a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_15.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execl_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_63a.c", "text": "* GoodSource: Fixed string * Sinks: execl * BadSink : execute command with execl * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_execl_63_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_63a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_execl_63b_badSink(&data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_execl_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_42.c", "text": "#ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE78_OS_Command_Injection__char_console_execl_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_system_54a.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_system_54b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_system_54_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_system_54a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_system_54b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_system_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_06.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #define EXECVP _execvp void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_06.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #endif void CWE78_OS_Command_Injection__char_connect_socket_execl_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_42.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_31.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with spawnlp * Flow Variant: 31 Data flow using a copy of data within the same function #define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_65a.c", "text": "void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_execl_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_console_execl_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_console_execl_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execl_08.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execl_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_console_execlp_09.c", "text": "#define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data void CWE78_OS_Command_Injection__char_console_execlp_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; static void goodG2B1() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_system_51a.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_system_51b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_system_51_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_system_51a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_system_51b_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_system_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_65a.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_65b_badSink(char * data); void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_65_bad() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_65b_badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_65a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_65b_goodG2BSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execl_12.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_execl_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_41.c", "text": "#define COMMAND_INT \"cmd.exe\" #define COMMAND_ARG1 \"/c\" #define COMMAND_ARG2 \"dir \" #define COMMAND_ARG3 data #define COMMAND_INT \"sh\" #define COMMAND_ARG1 \"-c\" #define COMMAND_ARG2 \"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(char * data) void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_41.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(data); #ifndef OMITGOOD void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_goodG2BSink(char * data) static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_12.c", "text": "void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcat(data, \"*.*\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_61b.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_execlp_61b.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * CWE78_OS_Command_Injection__char_connect_socket_execlp_61b_goodG2BSource(char * data) { strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s01/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_81a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_81_base& baseObject = CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; strcat(data, \"*.*\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_06.c", "text": "void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_06_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_51a.c", "text": "* GoodSource: Fixed string * Sink: execlp * BadSink : execute command with wexeclp * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_51b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_system_44.c", "text": "if (SYSTEM(data) != 0) void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_65a.c", "text": "* GoodSource: Fixed string * Sinks: w32_execvp * BadSink : execute command with wexecvp * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_65b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execvp_65b_badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_53a.c", "text": "* GoodSource: Fixed string * Sink: execlp * BadSink : execute command with wexeclp * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_53b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_53_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_44.c", "text": "* GoodSource: Fixed string * Sinks: execl * BadSink : execute command with wexecl * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD static void badSink(wchar_t * data) void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_system_22b.c", "text": "extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_system_22_badGlobal; wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_system_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_system_41.c", "text": "if (SYSTEM(data) != 0) void CWE78_OS_Command_Injection__wchar_t_listen_socket_system_41_bad() { wchar_t * data; wchar_t data_buf[100] = FULL_COMMAND; data = data_buf; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_22b.c", "text": "extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_22_badGlobal; wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s08/CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_66a.c", "text": "* GoodSource: Fixed string * Sinks: execl * BadSink : execute command with wexecl * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_66b_badSink(wchar_t * dataArray[]); void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_66_bad() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22b.c", "text": "extern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badGlobal; wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_63a.c", "text": "* GoodSource: Fixed string * Sinks: w32_execv * BadSink : execute command with wexecv * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_63b_badSink(wchar_t * * dataPtr); void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_63_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_67a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with wspawnlp * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data typedef struct _CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_67_structType { wchar_t * structFirst; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_67_bad() { wchar_t * data; CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_67_structType myStruct; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_63a.c", "text": "* GoodSource: Fixed string * Sinks: w32_spawnlp * BadSink : execute command with wspawnlp * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_63b_badSink(wchar_t * * dataPtr); void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_63_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_45.c", "text": "#define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #include <process.h> #define EXECV _wexecv static wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_45_badData; static wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_45_goodG2BData; static void badSink() { wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_45_badData; { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_51a.c", "text": "* GoodSource: Fixed string * Sink: w32_spawnv * BadSink : execute command with wspawnv * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_51b_badSink(wchar_t * data); void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE78_OS_Command_Injection/s09/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_41.c", "text": "* GoodSource: Fixed string * Sink: w32_execv * BadSink : execute command with wexecv * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #define COMMAND_INT L\"cmd.exe\" #define COMMAND_ARG1 L\"/c\" #define COMMAND_ARG2 L\"dir \" #define COMMAND_ARG3 data #define COMMAND_INT L\"sh\" #define COMMAND_ARG1 L\"-c\" #define COMMAND_ARG2 L\"ls \" #define COMMAND_ARG3 data #ifndef OMITBAD void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_41_badSink(wchar_t * data) { { wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL}; void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_execv_41_bad() { wchar_t * data; wchar_t dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_32.c", "text": "count = -1; { int count = *countPtr1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_32.c", "text": "fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_32.c", "text": "count = -1; { int count = *countPtr1; fscanf(stdin, \"%d\", &count); *countPtr1 = count; } { int count = *countPtr2; SLEEP(count); static void goodG2B() { int count; int *countPtr1 = &count; int *countPtr2 = &count; count = -1; { int count = *countPtr1; count = 20; *countPtr1 = count; } { int count = *countPtr2; SLEEP(count); static void goodB2G() { int count; int *countPtr1 = &count; int *countPtr2 = &count; count = -1; { int count = *countPtr1; fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_52a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_fwrite_52_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_52a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_fwrite_52_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_52a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_fwrite_52_bad() int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(count); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodG2BSink(int count); count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodG2BSink(count); } void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodB2GSink(int count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_52a.c", "text": "* GoodSource: Assign count to be a relatively small number * Sinks: fwrite * GoodSink: Write to a file count number of times, but first validate count * BadSink : Write to a file count number of times #ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(int count); void CWE400_Resource_Exhaustion__fscanf_fwrite_52_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_fwrite_52b_badSink(count); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodG2BSink(int count); static void goodG2B() { int count; count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodG2BSink(count); } void CWE400_Resource_Exhaustion__fscanf_fwrite_52b_goodB2GSink(int count); static void goodB2G() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_03.c", "text": "count = -1; if(5==5) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_03.c", "text": "count = -1; if(5==5) { fscanf(stdin, \"%d\", &count); } if(5==5) { SLEEP(count); static void goodB2G1() { int count; count = -1; if(5==5) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_03.c", "text": "fscanf(stdin, \"%d\", &count); count = -1; if(5==5) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_03.c", "text": "void CWE400_Resource_Exhaustion__fscanf_sleep_03_bad() { int count; count = -1; if(5==5) { fscanf(stdin, \"%d\", &count); } if(5==5) { SLEEP(count); static void goodB2G1() { int count; count = -1; if(5==5) { fscanf(stdin, \"%d\", &count); } else { if (count > 0 && count <= 2000) { SLEEP(count); static void goodB2G2() { int count; count = -1; if(5==5) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_83_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_05.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_05.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_05.c", "text": "#ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_05_bad()", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_05.c", "text": "#ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_05_bad() { int count; count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_05.c", "text": "#ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_05_bad() count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_05.c", "text": "#ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_05_bad() { int count; count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count); { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_05.c", "text": "#ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_05_bad() count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count); count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_05.c", "text": "{ int count; count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count); { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count); size_t i = 0; FILE *pFile = NULL; const char *filename = \"output_good.txt\"; if (count > 0 && count <= 20) { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G2() { int count; count = -1; if(staticTrue) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__connect_socket_fwrite_04.c", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #define SENTENCE \"This is the sentence we are printing to the file. \" connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_66a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(int countArray[]); void CWE400_Resource_Exhaustion__fscanf_for_loop_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_66a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(int countArray[]); void CWE400_Resource_Exhaustion__fscanf_for_loop_66_bad() { int count; int countArray[5]; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_66a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(int countArray[]); void CWE400_Resource_Exhaustion__fscanf_for_loop_66_bad() int countArray[5]; count = -1; fscanf(stdin, \"%d\", &count); countArray[2] = count; CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(countArray); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodG2BSink(int countArray[]); count = 20; countArray[2] = count; CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodG2BSink(countArray); } void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodB2GSink(int countArray[]);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_66a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(int countArray[]); void CWE400_Resource_Exhaustion__fscanf_for_loop_66_bad() { int count; int countArray[5]; count = -1; fscanf(stdin, \"%d\", &count); countArray[2] = count; CWE400_Resource_Exhaustion__fscanf_for_loop_66b_badSink(countArray); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodG2BSink(int countArray[]); static void goodG2B() { int count; int countArray[5]; count = -1; count = 20; countArray[2] = count; CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodG2BSink(countArray); } void CWE400_Resource_Exhaustion__fscanf_for_loop_66b_goodB2GSink(int countArray[]); static void goodB2G() { int count; int countArray[5]; count = -1; fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_68a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink(); void CWE400_Resource_Exhaustion__fscanf_fwrite_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_68a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink(); void CWE400_Resource_Exhaustion__fscanf_fwrite_68_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_68a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink(); void CWE400_Resource_Exhaustion__fscanf_fwrite_68_bad() int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_fwrite_68_badData = count; CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink(); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodG2BSink(); void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodB2GSink(); count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodG2BData = count; CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_68a.c", "text": "int CWE400_Resource_Exhaustion__fscanf_fwrite_68_badData; int CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodG2BData; int CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodB2GData; #ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink(); void CWE400_Resource_Exhaustion__fscanf_fwrite_68_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_fwrite_68_badData = count; CWE400_Resource_Exhaustion__fscanf_fwrite_68b_badSink(); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodG2BSink(); void CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodB2GSink(); static void goodG2B() { int count; count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_fwrite_68_goodG2BData = count; CWE400_Resource_Exhaustion__fscanf_fwrite_68b_goodG2BSink(); static void goodB2G() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_67a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); void CWE400_Resource_Exhaustion__fscanf_for_loop_67_bad() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_67a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); void CWE400_Resource_Exhaustion__fscanf_for_loop_67_bad() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_67a.c", "text": "#include \"std_testcase.h\" typedef struct _CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType { int structFirst; } CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType; #ifndef OMITBAD void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); void CWE400_Resource_Exhaustion__fscanf_for_loop_67_bad() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct; count = -1; fscanf(stdin, \"%d\", &count); myStruct.structFirst = count; CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(myStruct); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodG2BSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); static void goodG2B() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct; count = 20; myStruct.structFirst = count; CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodG2BSink(myStruct); } void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodB2GSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); static void goodB2G() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_67a.c", "text": "void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); void CWE400_Resource_Exhaustion__fscanf_for_loop_67_bad() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct; count = -1; fscanf(stdin, \"%d\", &count); myStruct.structFirst = count; CWE400_Resource_Exhaustion__fscanf_for_loop_67b_badSink(myStruct); #ifndef OMITGOOD void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodG2BSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); static void goodG2B() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct; count = -1; count = 20; myStruct.structFirst = count; CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodG2BSink(myStruct); } void CWE400_Resource_Exhaustion__fscanf_for_loop_67b_goodB2GSink(CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct); static void goodB2G() { int count; CWE400_Resource_Exhaustion__fscanf_for_loop_67_structType myStruct; count = -1; fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_02.c", "text": "count = -1; if(1) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_02.c", "text": "count = -1; if(1) { fscanf(stdin, \"%d\", &count); { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(1) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_02.c", "text": "fscanf(stdin, \"%d\", &count); count = -1; if(1) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_02.c", "text": "{ int count; count = -1; if(1) { fscanf(stdin, \"%d\", &count); { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(1) { fscanf(stdin, \"%d\", &count); size_t i = 0; FILE *pFile = NULL; const char *filename = \"output_good.txt\"; if (count > 0 && count <= 20) { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G2() { int count; count = -1; if(1) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_fwrite_04.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #define SENTENCE \"This is the sentence we are printing to the file. \" /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_31.c", "text": "void CWE400_Resource_Exhaustion__fscanf_fwrite_31_bad() { int count; count = -1; fscanf(stdin, \"%d\", &count); { int countCopy = count; int count = countCopy; { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodG2B() { int count; count = -1; count = 20; { int countCopy = count; int count = countCopy; { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__listen_socket_for_loop_06.c", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_72a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_72a.cpp", "text": "* GoodSource: Assign count to be a relatively small number * Sinks: fwrite * GoodSink: Write to a file count number of times, but first validate count * BadSink : Write to a file count number of times using namespace std; namespace CWE400_Resource_Exhaustion__fscanf_fwrite_72 void bad() { int count; vector<int> countVector; count = -1; fscanf(stdin, \"%d\", &count); countVector.insert(countVector.end(), 1, count); countVector.insert(countVector.end(), 1, count); countVector.insert(countVector.end(), 1, count); static void goodG2B() { int count; vector<int> countVector; count = -1; count = 20; countVector.insert(countVector.end(), 1, count); countVector.insert(countVector.end(), 1, count); countVector.insert(countVector.end(), 1, count); static void goodB2G() { int count; vector<int> countVector; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_sleep_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_08.c", "text": "count = -1; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &count); } if(staticReturnsTrue()) { SLEEP(count); static void goodB2G1() { int count; count = -1; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_sleep_08.c", "text": "void CWE400_Resource_Exhaustion__fscanf_sleep_08_bad() { int count; count = -1; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &count); } if(staticReturnsTrue()) { SLEEP(count); static void goodB2G1() { int count; count = -1; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &count); } else { if (count > 0 && count <= 2000) { SLEEP(count); static void goodB2G2() { int count; count = -1; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_43.cpp", "text": "static void badSource(int &count) { fscanf(stdin, \"%d\", &count); void bad() { int count; count = -1; badSource(count); { exit(1); } for (i = 0; i < (size_t)count; i++) #ifndef OMITGOOD static void goodG2BSource(int &count) { count = 20; static void goodG2B() { int count; count = -1; goodG2BSource(count); { exit(1); } for (i = 0; i < (size_t)count; i++) } static void goodB2GSource(int &count) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_fwrite_04.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_04.c", "text": "count = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &count); { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_fwrite_04.c", "text": "{ int count; count = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &count); { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &count); size_t i = 0; FILE *pFile = NULL; const char *filename = \"output_good.txt\"; if (count > 0 && count <= 20) { exit(1); } for (i = 0; i < (size_t)count; i++) static void goodB2G2() { int count; count = -1; if(STATIC_CONST_TRUE) { fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE400_Resource_Exhaustion__fscanf_for_loop_82.h\" namespace CWE400_Resource_Exhaustion__fscanf_for_loop_82", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE400_Resource_Exhaustion__fscanf_for_loop_82.h\" namespace CWE400_Resource_Exhaustion__fscanf_for_loop_82 void bad() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE400_Resource_Exhaustion__fscanf_for_loop_82.h\" namespace CWE400_Resource_Exhaustion__fscanf_for_loop_82 int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_82_bad; count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodG2B;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_82a.cpp", "text": "* @description * CWE: 400 Resource Exhaustion * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Assign count to be a relatively small number * Sinks: for_loop * GoodSink: Validate count before using it as the loop variant in a for loop * BadSink : Use count as the loop variant in a for loop * */ #include \"std_testcase.h\" #include \"CWE400_Resource_Exhaustion__fscanf_for_loop_82.h\" namespace CWE400_Resource_Exhaustion__fscanf_for_loop_82 void bad() { int count; count = -1; fscanf(stdin, \"%d\", &count); CWE400_Resource_Exhaustion__fscanf_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_82_bad; baseObject->action(count); static void goodG2B() { int count; count = -1; count = 20; CWE400_Resource_Exhaustion__fscanf_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__fscanf_for_loop_82_goodG2B; baseObject->action(count); static void goodB2G() { int count; count = -1; fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE400_Resource_Exhaustion__fscanf_for_loop_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_15.c", "text": "count = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &count); case 7: { size_t i = 0; for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE400_Resource_Exhaustion/s01/CWE400_Resource_Exhaustion__fscanf_for_loop_15.c", "text": "{ int count; count = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &count); case 7: { size_t i = 0; for (i = 0; i < (size_t)count; i++) static void goodB2G1() { int count; count = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &count); default: { size_t i = 0; if (count > 0 && count <= 20) { for (i = 0; i < (size_t)count; i++) static void goodB2G2() { int count; count = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &count);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_12.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, BAD_OS_COMMAND); } else { strcpy(data, GOOD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_12.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, GOOD_OS_COMMAND); } else { strcpy(data, GOOD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_12.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void CWE426_Untrusted_Search_Path__char_popen_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_12.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, BAD_OS_COMMAND); strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_12.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, BAD_OS_COMMAND); else { strcpy(data, GOOD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_12.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, BAD_OS_COMMAND); else { strcpy(data, GOOD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, GOOD_OS_COMMAND); strcpy(data, GOOD_OS_COMMAND);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_32.c", "text": "void CWE426_Untrusted_Search_Path__char_system_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, BAD_OS_COMMAND); *dataPtr1 = data; } { char * data = *dataPtr2; /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_32.c", "text": "static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, GOOD_OS_COMMAND); *dataPtr1 = data; } { char * data = *dataPtr2; /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_32.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void CWE426_Untrusted_Search_Path__char_system_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_32.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_system_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, BAD_OS_COMMAND); *dataPtr1 = data; } { char * data = *dataPtr2; if (SYSTEM(data) <= 0) static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, GOOD_OS_COMMAND);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_42.c", "text": "static char * badSource(char * data) { strcpy(data, BAD_OS_COMMAND); return data; } void CWE426_Untrusted_Search_Path__char_popen_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_42.c", "text": "static char * goodG2BSource(char * data) { strcpy(data, GOOD_OS_COMMAND); return data; } static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = goodG2BSource(data); { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_42.c", "text": "* GoodSource: Specify the full path in the OS command * Sink: popen * BadSink : Execute the popen function * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #ifndef OMITBAD static char * badSource(char * data) strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_42.c", "text": "* GoodSource: Specify the full path in the OS command * Sink: popen * BadSink : Execute the popen function * Flow Variant: 42 Data flow: data returned from one function to another in the same source file * and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" #ifndef OMITBAD static char * badSource(char * data) { strcpy(data, BAD_OS_COMMAND); return data; void CWE426_Untrusted_Search_Path__char_popen_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); FILE *pipe; pipe = POPEN(data, \"wb\"); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_82a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: system * BadSink : Execute the system function * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_82a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: system * BadSink : Execute the system function * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); CWE426_Untrusted_Search_Path__char_system_82_base* baseObject = new CWE426_Untrusted_Search_Path__char_system_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_04.c", "text": "#endif /* The two variables below are declared \"const\", so a tool should * be able to identify that reads of these will always return their /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_04.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #endif /* The two variables below are declared \"const\", so a tool should * be able to identify that reads of these will always return their void CWE426_Untrusted_Search_Path__char_system_04_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_81a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_81a.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); const CWE426_Untrusted_Search_Path__char_popen_81_base& baseObject = CWE426_Untrusted_Search_Path__char_popen_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_62b.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #ifndef OMITBAD void badSource(char * &data) strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_62b.cpp", "text": "* GoodSource: Specify the full path in the OS command * Sinks: popen * BadSink : Execute the popen function * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files * and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" #ifndef OMITBAD void badSource(char * &data) { strcpy(data, BAD_OS_COMMAND); #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_44.c", "text": "#define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" #endif #ifdef _WIN32 #define SYSTEM system #else #define SYSTEM system #endif #ifndef OMITBAD static void badSink(char * data) { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_44.c", "text": "void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); funcPtr(data); } #endif #ifndef OMITGOOD static void goodG2BSink(char * data) { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_44.c", "text": "* GoodSource: Specify the full path in the OS command * Sinks: system * BadSink : Execute the system function * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #ifndef OMITBAD static void badSink(char * data) { if (SYSTEM(data) <= 0) void CWE426_Untrusted_Search_Path__char_system_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_44.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" #ifndef OMITBAD static void badSink(char * data) { if (SYSTEM(data) <= 0) void CWE426_Untrusted_Search_Path__char_system_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { if (SYSTEM(data) <= 0) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_68a.c", "text": "* GoodSource: Specify the full path in the OS command * Sink: popen * BadSink : Execute the popen function * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void CWE426_Untrusted_Search_Path__char_popen_68_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_68a.c", "text": "* GoodSource: Specify the full path in the OS command * Sink: popen * BadSink : Execute the popen function * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files * and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_68_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND); CWE426_Untrusted_Search_Path__char_popen_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_21.c", "text": "{ strcpy(data, BAD_OS_COMMAND); } return data; } void CWE426_Untrusted_Search_Path__char_popen_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_21.c", "text": "{ strcpy(data, GOOD_OS_COMMAND); } return data; } static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_21.c", "text": "{ strcpy(data, GOOD_OS_COMMAND); } return data; } static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2B2Static = 1; data = goodG2B2Source(data); { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_21.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" static int badStatic = 0; static char * badSource(char * data) if(badStatic) { strcpy(data, BAD_OS_COMMAND); } return data; void CWE426_Untrusted_Search_Path__char_popen_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); FILE *pipe; pipe = POPEN(data, \"wb\"); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_21.c", "text": "strcpy(data, BAD_OS_COMMAND); } return data; void CWE426_Untrusted_Search_Path__char_popen_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); FILE *pipe; pipe = POPEN(data, \"wb\"); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) else { strcpy(data, GOOD_OS_COMMAND); } return data; static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); FILE *pipe; pipe = POPEN(data, \"wb\"); } static char * goodG2B2Source(char * data) strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_52c.c", "text": "#ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_popen_52c_badSink(char * data) { { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_52c.c", "text": "if (pipe != NULL) { PCLOSE(pipe); } } } #endif #ifndef OMITGOOD void CWE426_Untrusted_Search_Path__char_popen_52c_goodG2BSink(char * data) { { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_73b.cpp", "text": "#define SYSTEM system #else #define SYSTEM system #endif using namespace std; namespace CWE426_Untrusted_Search_Path__char_system_73 { #ifndef OMITBAD void badSink(list<char *> dataList) { char * data = dataList.back(); /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_73b.cpp", "text": "* can allow an attacker to run their own program */ if (SYSTEM(data) <= 0) { printLine(\"command execution failed!\"); exit(1); } } #endif #ifndef OMITGOOD void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_system_82_bad.cpp", "text": "#ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE426_Untrusted_Search_Path__char_system_82.h\" #ifdef _WIN32 #define SYSTEM system #else #define SYSTEM system #endif namespace CWE426_Untrusted_Search_Path__char_system_82 { void CWE426_Untrusted_Search_Path__char_system_82_bad::action(char * data) { /* POTENTIAL FLAW: Executing the system() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_13.c", "text": "#endif #ifndef OMITBAD void CWE426_Untrusted_Search_Path__char_popen_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcpy(data, BAD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_13.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE!=5) { printLine(\"Benign, fixed string\"); } else { strcpy(data, GOOD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_13.c", "text": "} } static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcpy(data, GOOD_OS_COMMAND); } { FILE *pipe; /* POTENTIAL FLAW: Executing the popen() function without specifying the full path to the executable", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_13.c", "text": "#include <wchar.h> #ifdef _WIN32 #define BAD_OS_COMMAND \"cmd.exe /c dir\" */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" void CWE426_Untrusted_Search_Path__char_popen_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, BAD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_13.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcpy(data, BAD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE426_Untrusted_Search_Path/CWE426_Untrusted_Search_Path__char_popen_13.c", "text": "* and could introduce code execution vulnerabilities on Windows systems that * have a system drive on an alternate drive letter (e.g., d:\\windows) */ #define GOOD_OS_COMMAND \"c:\\\\windows\\\\system32\\\\cmd.exe /c dir\" #else #define BAD_OS_COMMAND \"ls -la\" #define GOOD_OS_COMMAND \"/usr/bin/ls -la\" void CWE426_Untrusted_Search_Path__char_popen_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcpy(data, BAD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, GOOD_OS_COMMAND); FILE *pipe; pipe = POPEN(data, \"wb\"); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, GOOD_OS_COMMAND);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE223_Omission_of_Security_Relevant_Information/CWE223_Omission_of_Security_Relevant_Information__w32_06.c", "text": "* @description * CWE: 223 Omission of Security Relevant Information * Sinks: * GoodSink: Log the username #define PASSWORD \"ABCD1234!\" /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized WSADATA wsaData; BOOL wsaDataInit = FALSE; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; struct sockaddr_in service; char username[USERNAME_SZ+1]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == INVALID_SOCKET) if (sizeof(username)-sizeof(char) != recv(acceptSocket, username, sizeof(username)-sizeof(char), 0))", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_54a.cpp", "text": "void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_54a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_open_05.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_01.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_w32CreateFile_33.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_63a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(&data); #ifndef OMITGOOD void goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_13.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_13.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_66a.cpp", "text": "char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_66a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_w32CreateFile_53a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_fopen_74a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_open_62b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_fopen_53a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_84_goodG2B.cpp", "text": "/* * @description * CWE: 23 Relative Path Traversal * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE23_Relative_Path_Traversal__char_listen_socket_fopen_84_goodG2B::CWE23_Relative_Path_Traversal__char_listen_socket_fopen_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_01.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_fopen_73a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_10.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_10.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_04.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv using namespace std; size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_04.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_02.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_02.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_41.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_open_43.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_11.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_11.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_41.cpp", "text": "{ ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_fopen_52a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_42.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_12.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_12.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_12.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"file.txt\"); strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_73a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_open_63a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(&data); #ifndef OMITGOOD void goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ifstream_44.cpp", "text": "void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_fopen_67a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void bad() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_21.cpp", "text": "static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_21.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_ofstream_81a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } const CWE23_Relative_Path_Traversal__char_environment_ofstream_81_base& baseObject = CWE23_Relative_Path_Traversal__char_environment_ofstream_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_open_43.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_ofstream_22b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) else { strcat(data, \"file.txt\"); } return data; } char * goodG2B2Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_open_66a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void bad() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_fopen_33.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_83_goodG2B.cpp", "text": "/* * @description * CWE: 23 Relative Path Traversal * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_83_goodG2B::CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_environment_w32CreateFile_61b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_61b.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s02/CWE23_Relative_Path_Traversal__char_file_open_16.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed file name * Sink: open * BadSink : Open the file named in data using open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_73a.cpp", "text": "void badSink(list<wchar_t *> dataList); void bad() { wchar_t * data; list<wchar_t *> dataList; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ifstream_41.cpp", "text": "* GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(wchar_t * data) { ifstream inputFile; inputFile.open((char *)data); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_84_goodG2B.cpp", "text": "/* * @description * CWE: 23 Relative Path Traversal * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Use a fixed file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_84_goodG2B::CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ifstream_65a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void badSink(wchar_t * data); void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_22b.cpp", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Use a fixed file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_45.cpp", "text": "hFile = CreateFileA(data, void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_45.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badData = data; static void goodG2BSink() { char * data = goodG2BData; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_open_45.cpp", "text": "{ static wchar_t * badData; static wchar_t * goodG2BData; static void badSink() { wchar_t * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s03/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_41.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_open_54a.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_w32CreateFile_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_01.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_68a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_34.cpp", "text": "char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_12.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_12.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); else { strcat(data, \"file.txt\"); { ifstream inputFile; inputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_12.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); else { strcat(data, \"file.txt\"); { ifstream inputFile; inputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"file.txt\"); strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_12.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_12.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"file.txt\"); { ifstream inputFile; inputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_12.cpp", "text": "{ { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"file.txt\"); { ifstream inputFile; inputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"file.txt\"); strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_34.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_17.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_w32CreateFile_73a.cpp", "text": "void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_45.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_45.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badData = data; static void goodG2BSink() { char * data = goodG2BData; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_44.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_44.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_w32CreateFile_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_open_83_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE23_Relative_Path_Traversal__char_console_open_83_goodG2B::CWE23_Relative_Path_Traversal__char_console_open_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_ifstream_82a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } CWE23_Relative_Path_Traversal__char_environment_ifstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_environment_ifstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_ifstream_31.cpp", "text": "* GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 31 Data flow using a copy of data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_41.cpp", "text": "* GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(char * data) { ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_41.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_ifstream_54a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_41.cpp", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_ifstream_02.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_ifstream_02.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_22b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() a C++ namespace, it doesn't need a globally unique name. */ extern int badGlobal; char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int goodG2B2Global; char * goodG2B1Source(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_open_16.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: open * BadSink : Open the file named in data using open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_45.cpp", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_61b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_31.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_66a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_01.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_68a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE23_Relative_Path_Traversal__char_console_ofstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_15.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; case 6: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_15.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; break; default: strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_fopen_68a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE23_Relative_Path_Traversal__char_console_fopen_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE23_Relative_Path_Traversal__char_connect_socket_fopen_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_connect_socket_fopen_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_13.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_13.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_04.cpp", "text": "using namespace std; size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ifstream_68a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE23_Relative_Path_Traversal__char_console_ifstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_34.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_12.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_12.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_console_ofstream_12.cpp", "text": "{ { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"file.txt\"); { ofstream outputFile; outputFile.open((char *)data); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"file.txt\"); strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_open_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE23_Relative_Path_Traversal__char_connect_socket_open_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_connect_socket_open_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_11.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_fopen_11.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; else { strcat(data, \"file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_41.cpp", "text": "* GoodSource: Use a fixed file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_41.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE23_Relative_Path_Traversal/s01/CWE23_Relative_Path_Traversal__char_environment_ifstream_53a.cpp", "text": "* GoodSource: Use a fixed file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; strcat(data, \"file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_84_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__malloc_char_memcpy_84_goodG2B::~CWE127_Buffer_Underread__malloc_char_memcpy_84_goodG2B() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_53d.c", "text": "dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_53d.c", "text": "dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_memmove_53d_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_54e.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_54e.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_ncpy_54e_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_53d.c", "text": "dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_53d.c", "text": "dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_memcpy_53d_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_41.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_wchar_t_memmove_41_badSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); data = dataBuffer - 8; } CWE127_Buffer_Underread__malloc_wchar_t_memmove_41_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__malloc_wchar_t_memmove_41_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_05.c", "text": "data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_05.c", "text": "if(staticTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_05.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(staticTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_15.c", "text": "data = dataBuffer - 8; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_15.c", "text": "{ case 6: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; break; default: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_15.c", "text": "break; default: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; { case 6: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_14.c", "text": "if(globalFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_14.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(globalFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_10.c", "text": "if(globalTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_10.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(globalTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_11.c", "text": "if(globalReturnsTrue()) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_11.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void (*funcPtr) (char *) = badSink; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_83_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__malloc_char_cpy_83_goodG2B::~CWE127_Buffer_Underread__malloc_char_cpy_83_goodG2B() { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_54e.c", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void CWE127_Buffer_Underread__malloc_wchar_t_memcpy_54e_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_64b.c", "text": "wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_64b.c", "text": "wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void CWE127_Buffer_Underread__malloc_wchar_t_memmove_64b_goodG2BSink(void * dataVoidPtr) { wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_84_bad.cpp", "text": "data = dataBuffer - 8; } } CWE127_Buffer_Underread__malloc_wchar_t_memmove_84_bad::~CWE127_Buffer_Underread__malloc_wchar_t_memmove_84_bad() { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_65b.c", "text": "dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_memmove_65b_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_83_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__malloc_wchar_t_memmove_83_goodG2B::~CWE127_Buffer_Underread__malloc_wchar_t_memmove_83_goodG2B() { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_42.c", "text": "data = dataBuffer - 8; } return data; } void CWE127_Buffer_Underread__malloc_char_ncpy_42_bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_42.c", "text": "data = dataBuffer - 8; } return data; } void CWE127_Buffer_Underread__malloc_char_ncpy_42_bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer; } return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_14.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy #ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_cpy_14_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_05.c", "text": "data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_66b.c", "text": "char * data = dataArray[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_66b.c", "text": "char * data = dataArray[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void CWE127_Buffer_Underread__malloc_char_ncpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_13.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_ncpy_13_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_16.c", "text": "data = dataBuffer - 8; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_16.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memcpy_16_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_07.c", "text": "if(staticFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_07.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(staticFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_17.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_ncpy_17_bad() { int i; char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_11.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy #ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_cpy_11_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_43.cpp", "text": "data = dataBuffer - 8; void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_43.cpp", "text": "wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2BSource(wchar_t * &data) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; static void goodG2B() { wchar_t * data; data = NULL; goodG2BSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_08.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memcpy_08_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_cpy_62a.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #include <wchar.h> namespace CWE127_Buffer_Underread__malloc_char_cpy_62 #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_22a.c", "text": "int CWE127_Buffer_Underread__malloc_char_memcpy_22_badGlobal = 0; char * CWE127_Buffer_Underread__malloc_char_memcpy_22_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_memcpy_22_bad() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memcpy_22_badGlobal = 1; data = CWE127_Buffer_Underread__malloc_char_memcpy_22_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_22a.c", "text": "int CWE127_Buffer_Underread__malloc_char_memcpy_22_badGlobal = 0; char * CWE127_Buffer_Underread__malloc_char_memcpy_22_badSource(char * data); void CWE127_Buffer_Underread__malloc_char_memcpy_22_bad() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memcpy_22_badGlobal = 1; data = CWE127_Buffer_Underread__malloc_char_memcpy_22_badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); int CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Global = 0; int CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B2Global = 0; char * CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Global = 0; data = CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_22a.c", "text": "#ifndef OMITGOOD int CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Global = 0; int CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B2Global = 0; char * CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Global = 0; data = CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B1Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); char * CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B2Global = 1; data = CWE127_Buffer_Underread__malloc_char_memcpy_22_goodG2B2Source(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_04.c", "text": "if(STATIC_CONST_TRUE) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memmove_04.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(STATIC_CONST_TRUE) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_15.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memcpy_15_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_15.c", "text": "dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_67b.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #include <wchar.h> typedef struct _CWE127_Buffer_Underread__malloc_wchar_t_memcpy_67_structType { wchar_t * structFirst; } CWE127_Buffer_Underread__malloc_wchar_t_memcpy_67_structType; #ifndef OMITBAD void CWE127_Buffer_Underread__malloc_wchar_t_memcpy_67b_badSink(CWE127_Buffer_Underread__malloc_wchar_t_memcpy_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void CWE127_Buffer_Underread__malloc_wchar_t_memcpy_67b_goodG2BSink(CWE127_Buffer_Underread__malloc_wchar_t_memcpy_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memmove_07.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__malloc_char_memmove_07_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_63b.c", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void CWE127_Buffer_Underread__malloc_wchar_t_memcpy_63b_goodG2BSink(wchar_t * * dataPtr) { wchar_t * data = *dataPtr; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_83_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__malloc_char_memcpy_83_goodG2B::~CWE127_Buffer_Underread__malloc_char_memcpy_83_goodG2B() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_ncpy_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); void (*funcPtr) (char *) = badSink; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_34.c", "text": "data = dataBuffer - 8; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_wchar_t_memcpy_34.c", "text": "if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; CWE127_Buffer_Underread__malloc_wchar_t_memcpy_34_unionType myUnion; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s02/CWE127_Buffer_Underread__malloc_char_memcpy_45.c", "text": "#include <wchar.h> static char * CWE127_Buffer_Underread__malloc_char_memcpy_45_badData; static char * CWE127_Buffer_Underread__malloc_char_memcpy_45_goodG2BData; static void badSink() { char * data = CWE127_Buffer_Underread__malloc_char_memcpy_45_badData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer - 8; } CWE127_Buffer_Underread__malloc_char_memcpy_45_badData = data; static void goodG2BSink() { char * data = CWE127_Buffer_Underread__malloc_char_memcpy_45_goodG2BData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_42.cpp", "text": "data = dataBuffer - 8; } return data; void bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_42.cpp", "text": "data = dataBuffer - 8; } return data; void bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer; } return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memmove_65b.cpp", "text": "dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); void goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_31.cpp", "text": "void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char * dataCopy = data; char * data = dataCopy; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char * dataCopy = data; char * data = dataCopy; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_13.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_ncpy_13 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_13.cpp", "text": "dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_84_bad.cpp", "text": "data = dataBuffer - 8; } } CWE127_Buffer_Underread__new_char_memcpy_84_bad::~CWE127_Buffer_Underread__new_char_memcpy_84_bad() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_83_bad.cpp", "text": "data = dataBuffer - 8; } } CWE127_Buffer_Underread__new_wchar_t_memcpy_83_bad::~CWE127_Buffer_Underread__new_wchar_t_memcpy_83_bad() { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_08.cpp", "text": "return 0; } namespace CWE127_Buffer_Underread__new_char_memmove_08 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_34.cpp", "text": "{ char * data; unionType myUnion; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; unionType myUnion; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE127_Buffer_Underread__new_char_ncpy_04 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_04.cpp", "text": "static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE127_Buffer_Underread__new_char_ncpy_04 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_62a.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #include <wchar.h> namespace CWE127_Buffer_Underread__new_char_cpy_62 #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_22a.cpp", "text": "int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = NULL; badGlobal = 1; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_22a.cpp", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy #include <wchar.h> namespace CWE127_Buffer_Underread__new_char_cpy_22 a C++ namespace, it doesn't need a globally unique name. */ int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = NULL; badGlobal = 1; data = badSource(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_22a.cpp", "text": "memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); char * goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; goodG2B2Global = 1; data = goodG2B2Source(data); { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_08.cpp", "text": "return 0; } namespace CWE127_Buffer_Underread__new_char_cpy_08 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_08.cpp", "text": "strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B2() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_67b.cpp", "text": "dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink(structType myStruct) { char * data = myStruct.structFirst; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_17.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_ncpy_17 void bad() { int i; char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_33.cpp", "text": "wchar_t * &dataRef = data; data = NULL; { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t * data = dataRef; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t * data = dataRef; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_14.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_memmove_14 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_02.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(1) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_02.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(1) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_17.cpp", "text": "{ int i; wchar_t * data; data = NULL; for(i = 0; i < 1; i++) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_68b.cpp", "text": "dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); void goodG2BSink() { char * data = CWE127_Buffer_Underread__new_char_memcpy_68_goodG2BData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_06.cpp", "text": "static const int STATIC_CONST_FIVE = 5; namespace CWE127_Buffer_Underread__new_char_cpy_06 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_06.cpp", "text": "value. */ static const int STATIC_CONST_FIVE = 5; namespace CWE127_Buffer_Underread__new_char_cpy_06 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_07.cpp", "text": "static int staticFive = 5; namespace CWE127_Buffer_Underread__new_char_memcpy_07 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memcpy_07.cpp", "text": "this will always give its initialized value. */ static int staticFive = 5; namespace CWE127_Buffer_Underread__new_char_memcpy_07 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_09.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_ncpy_09 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE127_Buffer_Underread__new_wchar_t_memcpy_05 void bad() { wchar_t * data; data = NULL; if(staticTrue) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_05.cpp", "text": "void bad() { wchar_t * data; data = NULL; if(staticTrue) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_wchar_t_memcpy_05.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; data = NULL; if(staticTrue) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_07.cpp", "text": "static int staticFive = 5; namespace CWE127_Buffer_Underread__new_char_memmove_07 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_07.cpp", "text": "this will always give its initialized value. */ static int staticFive = 5; namespace CWE127_Buffer_Underread__new_char_memmove_07 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_11.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__new_char_memmove_11 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_04.cpp", "text": "static const int STATIC_CONST_FALSE = 0; namespace CWE127_Buffer_Underread__new_char_memmove_04 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_memmove_04.cpp", "text": "static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE127_Buffer_Underread__new_char_memmove_04 void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_ncpy_83_goodG2B.cpp", "text": "data = dataBuffer; } } CWE127_Buffer_Underread__new_char_ncpy_83_goodG2B::~CWE127_Buffer_Underread__new_char_ncpy_83_goodG2B() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s03/CWE127_Buffer_Underread__new_char_cpy_67b.cpp", "text": "dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); void goodG2BSink(structType myStruct) { char * data = myStruct.structFirst; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_01.c", "text": "data = dataBuffer - 8; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_01.c", "text": "data = dataBuffer - 8; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_03.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_alloca_memmove_03_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(5==5) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_03.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(5==5) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memcpy_16.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_declare_memcpy_16_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; while(1) { data = dataBuffer - 8; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; while(1) { data = dataBuffer; break; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_07.c", "text": "#include <wchar.h> data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_07.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(staticFive==5) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_10.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_alloca_memmove_10_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalTrue) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_10.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalTrue) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_04.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(STATIC_CONST_TRUE) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memcpy_51b.c", "text": "dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_declare_memcpy_51b_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_13.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__wchar_t_alloca_memcpy_13_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_13.c", "text": "memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_63b.c", "text": "dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_alloca_memmove_63b_goodG2BSink(wchar_t * * dataPtr) { wchar_t * data = *dataPtr; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_05.c", "text": "data = dataBuffer - 8; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_05.c", "text": "memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(staticTrue) { data = dataBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memmove_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_alloca_memcpy_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s04/CWE127_Buffer_Underread__wchar_t_declare_memmove_54e.c", "text": "dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__wchar_t_declare_memmove_54e_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_05.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_05.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(staticTrue) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_63b.c", "text": "dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_memcpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memmove_10.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_memmove_10_bad() { char * data; dataBuffer[100-1] = '\\0'; if(globalTrue) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memmove_10.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(globalTrue) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_41.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_memcpy_41_badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); } } void CWE127_Buffer_Underread__char_declare_memcpy_41_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE127_Buffer_Underread__char_declare_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_memcpy_41_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_33.cpp", "text": "/* * @description * CWE: 127 Buffer Underread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE127_Buffer_Underread__CWE839_listen_socket_33 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_33.cpp", "text": "struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_05.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_05_bad()", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_05.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_05_bad() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_05.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_05_bad() data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_05.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_05_bad() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); static void goodB2G1() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_05.c", "text": "#ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_05_bad() data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); { { int buffer[10] = { 0 };", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_05.c", "text": "{ int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); static void goodB2G1() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data); { { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); static void goodB2G2() { int data; data = -1; if(staticTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_13.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_memcpy_13_bad() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_13.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_68a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_68b_badSink(); void CWE127_Buffer_Underread__CWE839_fscanf_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_68a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_68b_badSink(); void CWE127_Buffer_Underread__CWE839_fscanf_68_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_68a.c", "text": "void CWE127_Buffer_Underread__CWE839_fscanf_68b_badSink(); void CWE127_Buffer_Underread__CWE839_fscanf_68_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_68_badData = data; CWE127_Buffer_Underread__CWE839_fscanf_68b_badSink(); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_fscanf_68b_goodG2BSink(); void CWE127_Buffer_Underread__CWE839_fscanf_68b_goodB2GSink(); data = 7; CWE127_Buffer_Underread__CWE839_fscanf_68_goodG2BData = data; CWE127_Buffer_Underread__CWE839_fscanf_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_fscanf_68a.c", "text": "int CWE127_Buffer_Underread__CWE839_fscanf_68_badData; int CWE127_Buffer_Underread__CWE839_fscanf_68_goodG2BData; int CWE127_Buffer_Underread__CWE839_fscanf_68_goodB2GData; #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_fscanf_68b_badSink(); void CWE127_Buffer_Underread__CWE839_fscanf_68_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE127_Buffer_Underread__CWE839_fscanf_68_badData = data; CWE127_Buffer_Underread__CWE839_fscanf_68b_badSink(); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_fscanf_68b_goodG2BSink(); void CWE127_Buffer_Underread__CWE839_fscanf_68b_goodB2GSink(); static void goodG2B() { int data; data = -1; data = 7; CWE127_Buffer_Underread__CWE839_fscanf_68_goodG2BData = data; CWE127_Buffer_Underread__CWE839_fscanf_68b_goodG2BSink(); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_31.c", "text": "data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_cpy_31_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * dataCopy = data; char * data = dataCopy; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_05.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_05.c", "text": "data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(staticTrue) { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_08.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_memcpy_08_bad() { char * data; dataBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_08.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_02.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_memcpy_02_bad() { char * data; dataBuffer[100-1] = '\\0'; if(1) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_02.c", "text": "memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(1) { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_memcpy_33.cpp", "text": "#include <wchar.h> namespace CWE127_Buffer_Underread__char_declare_memcpy_33 void bad() { char * data; char * &dataRef = data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_15.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_cpy_15_bad() { char * data; switch(6) { case 6: data = dataBuffer - 8; break; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_15.c", "text": "{ char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B2() { char * data; switch(6) { case 6: data = dataBuffer; break; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_22a.c", "text": "int CWE127_Buffer_Underread__CWE839_connect_socket_22_badGlobal = 0; void CWE127_Buffer_Underread__CWE839_connect_socket_22_badSink(int data); void CWE127_Buffer_Underread__CWE839_connect_socket_22_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_22a.c", "text": "data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE127_Buffer_Underread__CWE839_connect_socket_22_badGlobal = 1; CWE127_Buffer_Underread__CWE839_connect_socket_22_badSink(data); #ifndef OMITGOOD int CWE127_Buffer_Underread__CWE839_connect_socket_22_goodB2G1Global = 0; int CWE127_Buffer_Underread__CWE839_connect_socket_22_goodB2G2Global = 0; int CWE127_Buffer_Underread__CWE839_connect_socket_22_goodG2BGlobal = 0; void CWE127_Buffer_Underread__CWE839_connect_socket_22_goodB2G1Sink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_22a.c", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE127_Buffer_Underread__CWE839_connect_socket_22_goodB2G1Global = 0; CWE127_Buffer_Underread__CWE839_connect_socket_22_goodB2G1Sink(data); } void CWE127_Buffer_Underread__CWE839_connect_socket_22_goodB2G2Sink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_54e.c", "text": "dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_cpy_54e_goodG2BSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: ncpy * BadSink : Copy data to string using strncpy * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_ncpy_31_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_34.c", "text": "data = dataBuffer - 8; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_34.c", "text": "{ char * unionFirst; char * unionSecond; } CWE127_Buffer_Underread__char_alloca_cpy_34_unionType; #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_cpy_34_bad() { char * data; CWE127_Buffer_Underread__char_alloca_cpy_34_unionType myUnion; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B() { char * data; CWE127_Buffer_Underread__char_alloca_cpy_34_unionType myUnion; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_04.c", "text": "data = dataBuffer - 8; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_TRUE) { data = dataBuffer; } { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_16.c", "text": "/* * @description * CWE: 127 Buffer Underread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_listen_socket_16_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_01.c", "text": "data = dataBuffer - 8; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_09.c", "text": "/* * @description * CWE: 127 Buffer Underread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_listen_socket_09_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_ncpy_64b.c", "text": "*/ char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_ncpy_64b_goodG2BSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_45.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include <wchar.h> static char * CWE127_Buffer_Underread__char_declare_cpy_45_badData; static char * CWE127_Buffer_Underread__char_declare_cpy_45_goodG2BData; static void badSink() { char * data = CWE127_Buffer_Underread__char_declare_cpy_45_badData; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); } } void CWE127_Buffer_Underread__char_declare_cpy_45_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE127_Buffer_Underread__char_declare_cpy_45_badData = data; static void goodG2BSink() { char * data = CWE127_Buffer_Underread__char_declare_cpy_45_goodG2BData; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_51a.c", "text": "void CWE127_Buffer_Underread__CWE839_connect_socket_51b_badSink(int data); void CWE127_Buffer_Underread__CWE839_connect_socket_51_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_51a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE127_Buffer_Underread__CWE839_connect_socket_51b_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_connect_socket_51b_goodG2BSink(int data); data = 7; CWE127_Buffer_Underread__CWE839_connect_socket_51b_goodG2BSink(data); } void CWE127_Buffer_Underread__CWE839_connect_socket_51b_goodB2GSink(int data); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_cpy_31_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * dataCopy = data; char * data = dataCopy; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_65a.c", "text": "void CWE127_Buffer_Underread__CWE839_connect_socket_65b_badSink(int data); void CWE127_Buffer_Underread__CWE839_connect_socket_65_bad() { int data; void (*funcPtr) (int) = CWE127_Buffer_Underread__CWE839_connect_socket_65b_badSink; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_connect_socket_65a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #ifndef OMITGOOD void CWE127_Buffer_Underread__CWE839_connect_socket_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE127_Buffer_Underread__CWE839_connect_socket_65b_goodG2BSink; } void CWE127_Buffer_Underread__CWE839_connect_socket_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE127_Buffer_Underread__CWE839_connect_socket_65b_goodB2GSink; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memmove_02.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_memmove_02_bad() { char * data; dataBuffer[100-1] = '\\0'; if(1) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_declare_cpy_41.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE127_Buffer_Underread__char_declare_cpy_41_badSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); } } void CWE127_Buffer_Underread__char_declare_cpy_41_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE127_Buffer_Underread__char_declare_cpy_41_badSink(data); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_declare_cpy_41_goodG2BSink(char * data) { { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_08.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_memcpy_08_bad() { char * data; dataBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memcpy_02.c", "text": "* @description * CWE: 127 Buffer Under-read * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE127_Buffer_Underread__char_alloca_memcpy_02_bad() { char * data; dataBuffer[100-1] = '\\0'; if(1) { data = dataBuffer - 8; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_cpy_68b.c", "text": "dest[100*2-1] = '\\0'; strcpy(dest, data); printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_cpy_68b_goodG2BSink() { char * data = CWE127_Buffer_Underread__char_alloca_cpy_68_goodG2BData; { char dest[100*2]; memset(dest, 'C', 100*2-1); dest[100*2-1] = '\\0'; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_memmove_64b.c", "text": "*/ char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_memmove_64b_goodG2BSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__CWE839_listen_socket_10.c", "text": "/* * @description * CWE: 127 Buffer Underread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE127_Buffer_Underread__CWE839_listen_socket_10_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE127_Buffer_Underread/s01/CWE127_Buffer_Underread__char_alloca_ncpy_53d.c", "text": "dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE127_Buffer_Underread__char_alloca_ncpy_53d_goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; strncpy(dest, data, strlen(dest));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_wchar_t_connect_socket_22b.c", "text": "extern int CWE114_Process_Control__w32_wchar_t_connect_socket_22_badGlobal; wchar_t * CWE114_Process_Control__w32_wchar_t_connect_socket_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_17.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE114_Process_Control__w32_char_environment_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { int h; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_81a.cpp", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE114_Process_Control__w32_char_listen_socket_81_base& baseObject = CWE114_Process_Control__w32_char_listen_socket_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_62b.cpp", "text": "break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_05.c", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_05.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_connect_socket_74a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_08.c", "text": "void CWE114_Process_Control__w32_char_relativePath_08_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_08.c", "text": "void CWE114_Process_Control__w32_char_relativePath_08_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_08.c", "text": "void CWE114_Process_Control__w32_char_relativePath_08_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_66a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE114_Process_Control__w32_char_environment_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_84_goodG2B.cpp", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE114_Process_Control__w32_char_relativePath_84_goodG2B::CWE114_Process_Control__w32_char_relativePath_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_31.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 31 Data flow using a copy of data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE114_Process_Control__w32_char_environment_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_connect_socket_72a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_11.c", "text": "void CWE114_Process_Control__w32_char_relativePath_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_11.c", "text": "void CWE114_Process_Control__w32_char_relativePath_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_11.c", "text": "void CWE114_Process_Control__w32_char_relativePath_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_connect_socket_73a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_listen_socket_73a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_05.c", "text": "/* The two variables below are not defined as \"const\", but are never * assigned any other value, so a tool should be able to identify that * reads of these will always return their initialized values. void CWE114_Process_Control__w32_char_relativePath_05_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_05.c", "text": "strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_05.c", "text": "strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_21.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv static int badStatic = 0; static char * badSource(char * data) if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } } return data; void CWE114_Process_Control__w32_char_environment_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); HMODULE hModule; hModule = LoadLibraryA(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_21.c", "text": "} } } return data; void CWE114_Process_Control__w32_char_environment_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); HMODULE hModule; hModule = LoadLibraryA(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); } return data; static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); HMODULE hModule; hModule = LoadLibraryA(data); } static char * goodG2B2Source(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_65a.c", "text": "#ifndef OMITBAD void CWE114_Process_Control__w32_char_file_65b_badSink(char * data); void CWE114_Process_Control__w32_char_file_65_bad() { char * data; void (*funcPtr) (char *) = CWE114_Process_Control__w32_char_file_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE114_Process_Control__w32_char_file_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE114_Process_Control__w32_char_file_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_connect_socket_83_goodG2B.cpp", "text": "/* * @description * CWE: 114 Process Control * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE114_Process_Control__w32_char_connect_socket_83_goodG2B::CWE114_Process_Control__w32_char_connect_socket_83_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_connect_socket_84_goodG2B.cpp", "text": "/* * @description * CWE: 114 Process Control * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE114_Process_Control__w32_char_connect_socket_84_goodG2B::CWE114_Process_Control__w32_char_connect_socket_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_68a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sink: * BadSink : Load a dynamic link library * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE114_Process_Control__w32_char_console_68_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE114_Process_Control__w32_char_console_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_wchar_t_listen_socket_22b.c", "text": "extern int CWE114_Process_Control__w32_wchar_t_listen_socket_22_badGlobal; wchar_t * CWE114_Process_Control__w32_wchar_t_listen_socket_22_badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_22b.c", "text": "extern int CWE114_Process_Control__w32_char_console_22_badGlobal; char * CWE114_Process_Control__w32_char_console_22_badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE114_Process_Control__w32_char_console_22_goodG2B2Global; char * CWE114_Process_Control__w32_char_console_22_goodG2B1Source(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_22b.c", "text": "{ { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; extern int CWE114_Process_Control__w32_char_console_22_goodG2B2Global; char * CWE114_Process_Control__w32_char_console_22_goodG2B1Source(char * data) else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); } return data; } char * CWE114_Process_Control__w32_char_console_22_goodG2B2Source(char * data) strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_04.c", "text": "#include <windows.h> /* The two variables below are declared \"const\", so a tool should * be able to identify that reads of these will always return their void CWE114_Process_Control__w32_char_relativePath_04_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_04.c", "text": "#include <windows.h> strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_04.c", "text": "#include <windows.h> strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_console_41.c", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE114_Process_Control__w32_char_console_41_badSink(data); #ifndef OMITGOOD void CWE114_Process_Control__w32_char_console_41_goodG2BSink(char * data) HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_wchar_t_listen_socket_45.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define LISTEN_BACKLOG 5 static wchar_t * CWE114_Process_Control__w32_wchar_t_listen_socket_45_badData; static wchar_t * CWE114_Process_Control__w32_wchar_t_listen_socket_45_goodG2BData; static void badSink() { wchar_t * data = CWE114_Process_Control__w32_wchar_t_listen_socket_45_badData; HMODULE hModule; hModule = LoadLibraryW(data); void CWE114_Process_Control__w32_wchar_t_listen_socket_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_17.c", "text": "void CWE114_Process_Control__w32_char_relativePath_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_17.c", "text": "void CWE114_Process_Control__w32_char_relativePath_17_bad() { int i; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { int h; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_65a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE114_Process_Control__w32_char_relativePath_65b_badSink(char * data); void CWE114_Process_Control__w32_char_relativePath_65_bad() { char * data; void (*funcPtr) (char *) = CWE114_Process_Control__w32_char_relativePath_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_65a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE114_Process_Control__w32_char_relativePath_65b_badSink(char * data); void CWE114_Process_Control__w32_char_relativePath_65_bad() { char * data; void (*funcPtr) (char *) = CWE114_Process_Control__w32_char_relativePath_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\"); funcPtr(data); #ifndef OMITGOOD void CWE114_Process_Control__w32_char_relativePath_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE114_Process_Control__w32_char_relativePath_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_environment_64a.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE114_Process_Control__w32_char_environment_64_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE114_Process_Control__w32_char_environment_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_09.c", "text": "void CWE114_Process_Control__w32_char_relativePath_09_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_09.c", "text": "void CWE114_Process_Control__w32_char_relativePath_09_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_relativePath_09.c", "text": "void CWE114_Process_Control__w32_char_relativePath_09_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcpy(data, \"winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\"); HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_char_file_31.c", "text": "* GoodSource: Hard code the full pathname to the library * Sinks: * BadSink : Load a dynamic link library * Flow Variant: 31 Data flow using a copy of data within the same function void CWE114_Process_Control__w32_char_file_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; HMODULE hModule; hModule = LoadLibraryA(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE114_Process_Control/CWE114_Process_Control__w32_wchar_t_listen_socket_66a.c", "text": "void CWE114_Process_Control__w32_wchar_t_listen_socket_66b_badSink(wchar_t * dataArray[]); void CWE114_Process_Control__w32_wchar_t_listen_socket_66_bad() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_12.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_12.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); * both branches use the GoodSource */ static void goodG2B() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; if(globalReturnsTrueOrFalse()) { data = dataGoodBuffer; data[0] = L'\\0'; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54e.c", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54e.c", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54e_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #include <wchar.h> static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45_badData; static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45_goodG2BData; static void badSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45_badData; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBadBuffer; data[0] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_45_goodG2BData; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_13.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_13_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(GLOBAL_CONST_FIVE==5) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_13.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(GLOBAL_CONST_FIVE==5) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_10.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_10_bad() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; if(globalTrue) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_10.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; if(globalTrue) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45.c", "text": "static void badSink() { twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45_badData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45_bad() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; data = dataBadBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45_badData = data; static void goodG2BSink() { twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45_goodG2BData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_32.c", "text": "{ wchar_t * data = *dataPtr1; data = dataBadBuffer; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; { wchar_t * data = *dataPtr1; data = dataGoodBuffer; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_51b.c", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_51b_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41.c", "text": "#ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41_badSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41_bad() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; data = dataBadBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45.c", "text": "static void badSink() { twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_badData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_bad() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); data = dataBadBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_badData = data; static void goodG2BSink() { twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_goodG2BData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_34.c", "text": "data = dataBadBuffer; myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_34.c", "text": "data = dataBadBuffer; myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { twoIntsStruct * data; CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_34_unionType myUnion; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); data = dataGoodBuffer; myUnion.unionFirst = data; { twoIntsStruct * data = myUnion.unionSecond; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_51b.c", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_51b_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_51b.c", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_51b_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67b.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_07.c", "text": "#include <wchar.h> data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_07.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(staticFive==5) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_14.c", "text": "{ twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; if(globalFive==5) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_14.c", "text": "{ twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; if(globalFive==5) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41_badSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBadBuffer; data[0] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52c.c", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52c_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_31.c", "text": "twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); data = dataBadBuffer; { twoIntsStruct * dataCopy = data; twoIntsStruct * data = dataCopy; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); data = dataGoodBuffer; { twoIntsStruct * dataCopy = data; twoIntsStruct * data = dataCopy; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_13.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_13_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(GLOBAL_CONST_FIVE==5) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_13.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); if(GLOBAL_CONST_FIVE==5) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_73b.cpp", "text": "twoIntsStruct * data = dataList.back(); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_73b.cpp", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sinks: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #ifndef OMITBAD void badSink(list<twoIntsStruct *> dataList) { twoIntsStruct * data = dataList.back(); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); #ifndef OMITGOOD void goodG2BSink(list<twoIntsStruct *> dataList) { twoIntsStruct * data = dataList.back(); { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_03.c", "text": "{ twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; if(5==5) { data = dataBadBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B1() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_03.c", "text": "{ twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; else { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B2() { twoIntsStruct * data; twoIntsStruct dataBadBuffer[50]; twoIntsStruct dataGoodBuffer[100]; if(5==5) { data = dataGoodBuffer; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_11.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_11_bad() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; if(globalReturnsTrue()) { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_11.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; if(globalReturnsTrue()) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s05/CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_07.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; else { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; if(staticFive==5) { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_68a.c", "text": "/* * @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_05.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_05.c", "text": "* BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_05.c", "text": "{ wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52c.c", "text": "memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52c_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_52c.c", "text": "memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_52c_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_45.c", "text": "memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_45_bad() { char * data; char dataGoodBuffer[10+1]; data = dataBadBuffer; data[0] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_45_badData = data; static void goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_45_goodG2BData; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void goodG2BSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52c.c", "text": "memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52c_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_31.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_31.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_31_bad() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); static void goodG2B() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_17.c", "text": "data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { int h; char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_33.cpp", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_33.cpp", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char dataGoodBuffer[10+1]; data = dataGoodBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_14.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_14_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_74b.cpp", "text": "char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_74b.cpp", "text": "char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_12.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_12.c", "text": "{ wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataBadBuffer; data[0] = L'\\0'; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); * both branches use the GoodSource */ static void goodG2B() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataGoodBuffer; data[0] = L'\\0'; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68b.c", "text": "strncpy(data, source, strlen(source) + 1); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68_goodG2BData; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54e.c", "text": "memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54e_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54e.c", "text": "memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54e_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_33.cpp", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_33.cpp", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67b.c", "text": "strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_02.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_02_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66b.c", "text": "char * data = dataArray[2]; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66b.c", "text": "char * data = dataArray[2]; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_82.h", "text": "/* * @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * BadSink : Copy string to data using strcpy()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_06_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_06_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_06_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52c.c", "text": "memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52c_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_14.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_14_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67b.c", "text": "memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_31.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_31_bad() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); static void goodG2B() { char * data; char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_31.c", "text": "data = dataBadBuffer; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s02/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_31.c", "text": "* GoodSource: Point data to a buffer that includes space for a NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_31_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); data = dataBadBuffer; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t)); data = dataGoodBuffer; data[0] = L'\\0'; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_33.cpp", "text": "data = dataBadBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_33.cpp", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: ncat * BadSink : Copy string to data using strncat * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B() { char * data; char * &dataRef = data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_14.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Point data to a buffer that does not have space for a NULL terminator * GoodSource: Point data to a buffer that includes space for a NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_14_bad() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataBadBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_14.c", "text": "{ wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; { data = dataGoodBuffer; data[0] = L'\\0'; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_13.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); static void goodG2B2() { char * data; if(GLOBAL_CONST_FIVE==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_65b.c", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_10.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_10_bad() { char * data; if(globalTrue) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_10.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(globalTrue) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_06_bad() { char * data; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_06.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: ncpy * BadSink : Copy string to data using strncpy #include <wchar.h> void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_06_bad() { char * data; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52c.c", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52c_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52c.c", "text": "memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52c_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_07.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(staticFive==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_03.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_03_bad() { char * data; if(5==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_03.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(5==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_09.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_09_bad() { char * data; if(GLOBAL_CONST_TRUE) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_63b.c", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_72b.cpp", "text": "char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_72b.cpp", "text": "char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54e.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54e_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_14.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_14_bad() { char * data; if(globalFive==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_14.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; if(globalFive==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_73b.cpp", "text": "char * data = dataList.back(); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_73b.cpp", "text": "char * data = dataList.back(); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_01.c", "text": "data = dataBadBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBadBuffer[50]; char dataGoodBuffer[100]; data = dataGoodBuffer; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_51b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_51b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68b.c", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_08.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_08_bad() { char * data; if(staticReturnsTrue()) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_51b.c", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_51b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_41.c", "text": "memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_41_bad() { wchar_t * data; wchar_t dataBadBuffer[10]; wchar_t dataGoodBuffer[10+1]; data = dataBadBuffer; data[0] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_41_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s03/CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_13.c", "text": "data = dataBadBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_13.c", "text": "data = dataBadBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_13.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_13_bad() { int * data; if(GLOBAL_CONST_FIVE==5) { data = dataBadBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(GLOBAL_CONST_FIVE==5) { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_07.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_07_bad() { int * data; if(staticFive==5) { data = dataBadBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(staticFive==5) { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_09.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_09_bad() { int * data; if(GLOBAL_CONST_TRUE) { data = dataBadBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(GLOBAL_CONST_TRUE) { data = dataGoodBuffer; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_03.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); if(5==5) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_16.c", "text": "data = dataBadBuffer; break; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_16.c", "text": "data = dataBadBuffer; break; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; while(1) { data = dataGoodBuffer; break; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53d.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53d_goodG2BSink(int * data) { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_02.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_02_bad() { int * data; if(1) { data = dataBadBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(1) { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_15.c", "text": "data = dataBadBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; break; default: data = dataGoodBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_15.c", "text": "{ case 6: data = dataBadBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; break; default: data = dataGoodBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; { case 6: data = dataGoodBuffer; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_13.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); if(GLOBAL_CONST_FIVE==5) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_05.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: memmove * BadSink : Copy int64_t array to data using memmove data = dataBadBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_05.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; if(staticTrue) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45.c", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45_bad() { int * data; int dataBadBuffer[50]; int dataGoodBuffer[100]; data = dataBadBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45_badData = data; static void goodG2BSink() { int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45_goodG2BData; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_11.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_11_bad() { int * data; if(globalReturnsTrue()) { data = dataBadBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(globalReturnsTrue()) { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66b.c", "text": "int * data = dataArray[2]; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66b_goodG2BSink(int * dataArray[]) { int * data = dataArray[2]; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_09.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); if(GLOBAL_CONST_TRUE) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_31.c", "text": "data = dataBadBuffer; { int64_t * dataCopy = data; int64_t * data = dataCopy; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_31.c", "text": "data = dataBadBuffer; { int64_t * dataCopy = data; int64_t * data = dataCopy; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); data = dataGoodBuffer; { int64_t * dataCopy = data; int64_t * data = dataCopy; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_05.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_05_bad() { int * data; if(staticTrue) { data = dataBadBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(staticTrue) { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_52c.c", "text": "memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_52c_goodG2BSink(int64_t * data) { { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_04.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_04_bad() { int * data; if(STATIC_CONST_TRUE) { data = dataBadBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(STATIC_CONST_TRUE) { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: memmove * BadSink : Copy int64_t array to data using memmove * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) typedef union { int64_t * unionFirst; int64_t * unionSecond; void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34_bad() { int64_t * data; CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34_unionType myUnion; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); data = dataBadBuffer; myUnion.unionFirst = data; { int64_t * data = myUnion.unionSecond; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34_unionType myUnion; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); data = dataGoodBuffer; myUnion.unionFirst = data; { int64_t * data = myUnion.unionSecond; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_63b.c", "text": "memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_63b_goodG2BSink(int64_t * * dataPtr) { int64_t * data = *dataPtr; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_04.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_04_bad() { int * data; if(STATIC_CONST_TRUE) { data = dataBadBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; else { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; if(STATIC_CONST_TRUE) { data = dataGoodBuffer; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_16.c", "text": "{ data = dataBadBuffer; break; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); static void goodG2B() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); while(1) { data = dataGoodBuffer; break; } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_11.c", "text": "{ data = dataBadBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B1() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); else { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B2() { int64_t * data; int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t)); int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t)); if(globalReturnsTrue()) { data = dataGoodBuffer; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45.c", "text": "static void badSink() { twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45_badData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45_bad() { twoIntsStruct * data; twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct)); twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct)); data = dataBadBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45_badData = data; static void goodG2BSink() { twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45_goodG2BData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_32.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_32_bad() { int64_t * data; int64_t * *dataPtr1 = &data; int64_t * *dataPtr2 = &data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; { int64_t * data = *dataPtr1; data = dataBadBuffer; *dataPtr1 = data; } { int64_t * data = *dataPtr2; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); static void goodG2B() { int64_t * data; int64_t * *dataPtr1 = &data; int64_t * *dataPtr2 = &data; int64_t dataBadBuffer[50]; int64_t dataGoodBuffer[100]; { int64_t * data = *dataPtr1; data = dataGoodBuffer; *dataPtr1 = data; } { int64_t * data = *dataPtr2; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s04/CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54e.c", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54e_goodG2BSink(int * data) { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_64b.c", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files { void * * dataPtr = (void * *)dataVoidPtr; void * data = (*dataPtr); { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printLine((char *)dest); { void * * dataPtr = (void * *)dataVoidPtr; void * data = (*dataPtr); { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15.c", "text": "data = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15.c", "text": "{ int data; data = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &data); int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; switch(6) { case 6: fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_02.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(1) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_02.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(1) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_02.c", "text": "#endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; if(1) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); if(1) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_82_goodG2B.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_82 { void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_82_goodG2B::action(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54e.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54e_badSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54e.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54e_badSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54e_goodG2BSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_06.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; } charVoid; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_06.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; } charVoid; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_06.c", "text": "typedef struct _charVoid { char charFirst[16]; } charVoid; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); if(STATIC_CONST_FIVE==5) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_goodG2BSink(int data); data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_goodG2BSink(data); } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a.c", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking the upper bound * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_goodG2BSink(int data); static void goodG2B() { int data; data = -1; data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_goodG2BSink(data); } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_goodB2GSink(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_15.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; { case 6: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_15.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; { case 6: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); break; default: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_15.c", "text": "#endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; { case 6: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); break; default: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); { case 6: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_18.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; goto sink; sink: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_18.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; goto sink; sink: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid.charFirst); printLine((char *)structCharVoid.voidSecond); goto sink; sink: { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files { int * * dataPtr = (int * *)dataVoidPtr; int * data = (*dataPtr); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files { int * * dataPtr = (int * *)dataVoidPtr; int * data = (*dataPtr); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); { int * * dataPtr = (int * *)dataVoidPtr; int * data = (*dataPtr); { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 1; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G2Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodG2BGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Sink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 1; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G2Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodG2BGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Sink(int data); static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 1; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G2Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodG2BGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Sink(int data); int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Global = 0; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Sink(data); } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G2Sink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badGlobal = 1; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G2Global = 0; int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodG2BGlobal = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Sink(int data); static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Global = 0; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G1Sink(data); } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_goodB2G2Sink(int data); static void goodB2G2() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_03.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_03_bad() { char * data; { data = dataBadBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; { data = dataGoodBuffer; data[0] = '\\0'; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_08.c", "text": "if(staticReturnsTrue()) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodB2G2() { void * data; data = NULL; if(staticReturnsTrue()) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodG2B1() { void * data; data = NULL; } else { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_08.c", "text": "if(staticReturnsTrue()) { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodG2B1() { void * data; data = NULL; } else { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data); printLine((char *)dest); static void goodG2B2() { void * data; data = NULL; if(staticReturnsTrue()) { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10_bad() { int * data; data = NULL; if(globalTrue) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10_bad() { int * data; data = NULL; if(globalTrue) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; else { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10_bad() { int * data; data = NULL; if(globalTrue) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; else { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; data = NULL; if(globalTrue) { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_44.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_44.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_44_bad() { int * data; void (*funcPtr) (int *) = badSink; data = NULL; data = (int *)ALLOCA(10); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82.h\" namespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82.h\" namespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82.h\" namespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82 int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_base* baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_bad; data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_base* baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_goodG2B;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82.h\" namespace CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82 void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_base* baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_bad; baseObject->action(data); static void goodG2B() { int data; data = -1; data = 7; CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_base* baseObject = new CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_82_goodG2B; baseObject->action(data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodG2BSink; } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodB2GSink;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65a.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink(int data); void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65_bad() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_badSink; data = -1; fscanf(stdin, \"%d\", &data); funcPtr(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodG2BSink; data = -1; data = 7; funcPtr(data); } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_65b_goodB2GSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_82_goodB2G.cpp", "text": "size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} memcpy(dest, data, (dataLen+1)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_72b.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<int *> dataVector) { int * data = dataVector[2]; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_72b.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<int *> dataVector) { int * data = dataVector[2]; { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); void goodG2BSink(vector<int *> dataVector) { int * data = dataVector[2]; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_12.c", "text": "if(globalReturnsTrueOrFalse()) { data = (void *)WIDE_STRING; } else { data = (void *)WIDE_STRING; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); use the BadSink */ static void goodG2B() { void * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (void *)CHAR_STRING; } else { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_12.c", "text": "{ { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); use the BadSink */ static void goodG2B() { void * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (void *)CHAR_STRING; } else { data = (void *)CHAR_STRING; { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data); printLine((char *)dest); { { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_18.c", "text": "goto source; source: data = (void *)WIDE_STRING; sink: { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printLine((char *)dest); static void goodB2G() { void * data; data = NULL; goto source; source: data = (void *)WIDE_STRING; sink: { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy(dest, data); printWLine((wchar_t *)dest); static void goodG2B() { void * data; data = NULL; goto source; source: data = (void *)CHAR_STRING; sink: { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() #include \"std_testcase.h\" void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() #include \"std_testcase.h\" void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; else { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)ALLOCA(10); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B1() { int * data; data = NULL; else { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); static void goodG2B2() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)ALLOCA(10*sizeof(int)); } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE135_62a.cpp", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(void * &data); void bad() { void * data; data = NULL; badSource(data); { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t)); (void)wcscpy((wchar_t *)dest, (wchar_t *)data); printLine((char *)dest); #ifndef OMITGOOD void goodG2BSource(void * &data); static void goodG2B() { void * data; data = NULL; goodG2BSource(data); { size_t dataLen = strlen((char *)data); void * dest = (void *)ALLOCA((dataLen+1) * 1); (void)strcpy((char *)dest, (char *)data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44.c", "text": "if (data >= 0) { buffer[data] = 1; } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44.c", "text": "fscanf(stdin, \"%d\", &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int data) int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; static void goodG2B() { int data; void (*funcPtr) (int) = goodG2BSink; data = -1; data = 7; funcPtr(data); } static void goodB2GSink(int data) int i; int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G() { int data; void (*funcPtr) (int) = goodB2GSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s01/CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b.c", "text": "strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_16.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_16_bad() { char * data; char dataBuffer[100]; data = dataBuffer; while(1) { memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; while(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_07.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncat * BadSink : Copy data to string using strncat #include <wchar.h> memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_07.c", "text": "{ char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_54e.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_54e_goodG2BSink(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_17.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { int h; char * data; char dataBuffer[100]; data = dataBuffer; for(h = 0; h < 1; h++) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_73b.cpp", "text": "char * data = dataList.back(); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_73b.cpp", "text": "char * data = dataList.back(); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_08.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_08_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_08.c", "text": "{ char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68b.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68_goodG2BData; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_44.c", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_15.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_15_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; switch(6) { case 6: memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_15.c", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; switch(6) { case 6: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_51b.c", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_51b_goodG2BSink(char * data) { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_84_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_84_bad::~CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_84_bad() { { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; badSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; goodG2BSource(data); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_06_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_06.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncat * BadSink : Copy data to string using strncat #include <wchar.h> void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_06_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_06.c", "text": "{ char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_41.c", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_41_bad() { char * data; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_41_badSink(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_41_goodG2BSink(char * data) { { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_05.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncpy * BadSink : Copy data to string using strncpy memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_05.c", "text": "{ char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticTrue) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52c.c", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52c_goodG2BSink(char * data) { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45.c", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45_bad() { char * data; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45_badData = data; static void goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45_goodG2BData; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_02.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_02_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(1) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_02.c", "text": "{ char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_51b.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_51b_goodG2BSink(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_08.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncpy * BadSink : Copy data to string using strncpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_08_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(staticReturnsTrue()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_08.c", "text": "{ char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(staticReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_17.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { int h; char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; for(h = 0; h < 1; h++) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21_bad() { char * data; char dataBuffer[100]; data = dataBuffer; badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } return data; void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21_bad() { char * data; char dataBuffer[100]; data = dataBuffer; badStatic = 1; data = badSource(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21.c", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2B1Static = 0; data = goodG2B1Source(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } return data; static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; goodG2B2Static = 1; data = goodG2B2Source(data); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52c.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52c_goodG2BSink(char * data) { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66b.c", "text": "char * data = dataArray[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66b.c", "text": "char * data = dataArray[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_83_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_83_goodG2B::~CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_83_goodG2B() { { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_13.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_13_bad() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_13.c", "text": "{ char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_83_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_83_goodG2B::~CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_83_goodG2B() { { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_65b.c", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_65b_goodG2BSink(char * data) { { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_68b.c", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_68b_goodG2BSink() { char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_68_goodG2BData; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_03.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_03_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(5==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_03.c", "text": "{ char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(5==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s06/CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_18.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; goto source; source: memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53d.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_83_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_83_goodG2B::~CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_83_goodG2B() { { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_04.c", "text": "data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_04.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cpy * BadSink : Copy string to data using strcpy #include <wchar.h> data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_04.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; if(STATIC_CONST_TRUE) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_06_bad() { char * data; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_06.c", "text": "* BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cat * BadSink : Copy string to data using strcat #include <wchar.h> void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_06_bad() { char * data; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_06.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B2() { char * data; if(STATIC_CONST_FIVE==5) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_03.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_03.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_03.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(5==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54e.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54e_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_65b.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_02.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B2() { char * data; if(1) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_05.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_05.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(staticTrue) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_65b.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53d.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_31.c", "text": "* GoodSource: Set data pointer to the good buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 31 Data flow using a copy of data within the same function void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_31_bad() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBadBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataGoodBuffer; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_74b.cpp", "text": "char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_74b.cpp", "text": "char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_04.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(STATIC_CONST_TRUE) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_08.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; if(staticReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_63b.c", "text": "strcpy(dest, data); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_42.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_42_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_42.c", "text": "#ifndef OMITBAD static char * badSource(char * data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_42_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; return data; static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; data = goodG2BSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_09.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B1() { char * data; else { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B2() { char * data; if(GLOBAL_CONST_TRUE) { data = dataGoodBuffer; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_16.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_16.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cpy * BadSink : Copy data to string using strcpy void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_16_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; while(1) { memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; while(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_67b.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_67_structType myStruct) { char * data = myStruct.structFirst; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61a.c", "text": "char * CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61b_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61_bad() { char * data; char dataBuffer[100]; data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61b_badSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61a.c", "text": "char * CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61b_badSource(char * data); void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61_bad() { char * data; char dataBuffer[100]; data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61b_badSource(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); #ifndef OMITGOOD char * CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61b_goodG2BSource(char * data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_61b_goodG2BSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_52c.c", "text": "strcat(dest, data); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_52c_goodG2BSink(char * data) { { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_16.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Set data pointer to the bad buffer * GoodSource: Set data pointer to the good buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_16_bad() { char * data; while(1) { data = dataBadBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; while(1) { data = dataGoodBuffer; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_31.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strcat(dest, data); printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_15.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cpy * BadSink : Copy data to string using strcpy void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_15_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; switch(6) { case 6: memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_15.c", "text": "char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B1() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B2() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); data = dataBuffer; switch(6) { case 6: memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_51b.c", "text": "strcat(dest, data); printLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_51b_goodG2BSink(char * data) { { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s08/CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_32.c", "text": "char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); { char * data = *dataPtr1; data = dataBadBuffer; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char)); char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char)); { char * data = *dataPtr1; data = dataGoodBuffer; data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_84_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_84_bad::~CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_84_bad() { { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42_bad() { char * data; char dataBuffer[100]; data = dataBuffer; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42.c", "text": "#ifndef OMITBAD static char * badSource(char * data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42_bad() { char * data; char dataBuffer[100]; data = dataBuffer; data = badSource(data); { char dest[50] = \"\"; strcpy(dest, data); printLine(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; return data; static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; data = goodG2BSource(data); { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_34.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_34_bad() { char * data; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_34_unionType myUnion; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B() { char * data; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_34_unionType myUnion; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_05.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cpy * BadSink : Copy data to string using strcpy memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_05.c", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B1() { char * data; char dataBuffer[100]; data = dataBuffer; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B2() { char * data; char dataBuffer[100]; data = dataBuffer; if(staticTrue) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01_bad() { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_01_bad() { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); static void good1() { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(staticTrue) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(staticTrue) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_05.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; if(staticTrue) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); if(staticTrue) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_01.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; data = dataBuffer; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_16.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; while(1) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_16.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; while(1) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); while(1) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_83_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_83_bad::~CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_83_bad() { { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_04.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; } charVoid; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); else { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst)); structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid.charFirst); printWLine((wchar_t *)structCharVoid.voidSecond); if(STATIC_CONST_TRUE) { { charVoid structCharVoid; structCharVoid.voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid.voidSecond); memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s09/CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_17.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); static void goodG2B() { int h; char * data; char dataBuffer[100]; data = dataBuffer; for(h = 0; h < 1; h++) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_05.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_05.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_05.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(staticTrue) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_68b.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_68b.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_68b_goodG2BSink() { wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_68_goodG2BData; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badGlobal = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badSource(wchar_t * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22a.c", "text": "int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badGlobal = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badSource(wchar_t * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badGlobal = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B2Global = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22a.c", "text": "data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); int CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B2Global = 0; wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B1Global = 0; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); } wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B2Source(wchar_t * data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B2Global = 1; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_22_goodG2B2Source(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_05.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_05.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(staticTrue) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_14.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_14_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(globalFive==5) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_14.c", "text": "{ wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(globalFive==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_11.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_11_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(globalReturnsTrue()) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_11.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(globalReturnsTrue()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_15.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_15.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_15_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; switch(6) { case 6: wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_15.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; printLine(\"Benign, fixed string\"); break; default: wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; switch(6) { case 6: wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_44.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_06.c", "text": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_06_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_06.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy #include <wchar.h> void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_06_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_06.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(STATIC_CONST_FIVE==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_64b.c", "text": "wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_64b.c", "text": "wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_64b_goodG2BSink(void * dataVoidPtr) { wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_67b.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_07.c", "text": "{ wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(staticFive==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_18.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; goto source; source: wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_83_goodG2B.cpp", "text": "wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_83_goodG2B::~CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_83_goodG2B() { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_18.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; goto source; source: wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_67b.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_67b_goodG2BSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54e.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54e_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53d.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53d_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_44.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[100]; data = dataBuffer; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_07.c", "text": "{ wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; if(staticFive==5) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61a.c", "text": "wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61b_badSource(wchar_t * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61b_badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61a.c", "text": "wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61b_badSource(wchar_t * data); void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61_bad() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61b_badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61b_goodG2BSource(wchar_t * data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; data = dataBuffer; data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_61b_goodG2BSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_10.c", "text": "* @description * CWE: 121 Stack Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memcpy * BadSink : Copy data to string using memcpy void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_10_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(globalTrue) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE121_Stack_Based_Buffer_Overflow/s07/CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_10.c", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); data = dataBuffer; if(globalTrue) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_08.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_08.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_21.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_21.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_42.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_42.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_41.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_41.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_41.cpp", "text": "dataBytes = data * sizeof(int); intPointer = (int*)new char[dataBytes]; for (i = 0; i < (size_t)data; i++) void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_83a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_83a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_16.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_16.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE680_Integer_Overflow_to_Buffer_Overflow/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_02.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_02.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_06.c", "text": "#define DEST_SIZE 100 /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized if(STATIC_CONST_FIVE==5) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%s\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_06.c", "text": "#define DEST_SIZE 100 sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument/CWE688_Function_Call_With_Incorrect_Variable_or_Reference_as_Argument__basic_06.c", "text": "#define DEST_SIZE 100 sprintf(dest, \"%s\", intFive); printLine(dest); else { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive); printLine(dest); if(STATIC_CONST_FIVE==5) { { char dest[DEST_SIZE]; int intFive = 5; sprintf(dest, \"%d\", intFive);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE328_Reversible_One_Way_Hash/CWE328_Reversible_One_Way_Hash__w32_MD2_06.c", "text": "#define MD2_SUM_SIZE (128 / 8) /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized { HCRYPTPROV hCryptProv; HCRYPTHASH hHash; FILE *pFile = NULL; DWORD hashSize; char *replace; size_t i; pFile = fopen(\"password.txt\", \"r\"); if (pFile == NULL) } for (i = 0; i < MD2_SUM_SIZE; i++) { ULONG val; if (fscanf(pFile, \"%02x\", &val) != 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE328_Reversible_One_Way_Hash/CWE328_Reversible_One_Way_Hash__w32_MD5_07.c", "text": "#define MD5_SUM_SIZE (128 / 8) /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of { HCRYPTPROV hCryptProv; HCRYPTHASH hHash; FILE *pFile = NULL; DWORD hashSize; char *replace; size_t i; pFile = fopen(\"password.txt\", \"r\"); if (pFile == NULL) } for (i = 0; i < MD5_SUM_SIZE; i++) { ULONG val; if (fscanf(pFile, \"%02x\", &val) != 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE328_Reversible_One_Way_Hash/CWE328_Reversible_One_Way_Hash__w32_MD2_07.c", "text": "#define MD2_SUM_SIZE (128 / 8) /* The variable below is not declared \"const\", but is never assigned any other value so a tool should be able to identify that reads of { HCRYPTPROV hCryptProv; HCRYPTHASH hHash; FILE *pFile = NULL; DWORD hashSize; char *replace; size_t i; pFile = fopen(\"password.txt\", \"r\"); if (pFile == NULL) } for (i = 0; i < MD2_SUM_SIZE; i++) { ULONG val; if (fscanf(pFile, \"%02x\", &val) != 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_52c.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, #ifndef OMITGOOD void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_52c_goodG2BSink(wchar_t * password) HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, } void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_52c_goodB2GSink(wchar_t * password) wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b.c", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD char * CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b_badSource(char * password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b.c", "text": "{ *replace = '\\0'; } replace = strchr(password, '\\n'); { closesocket(listenSocket); } if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); WSACleanup(); } } return password; #ifndef OMITGOOD char * CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b_goodG2BSource(char * password) { strcpy(password, \"Password1234!\"); return password; } char * CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b_goodB2GSource(char * password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b.c", "text": "* GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD char * CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b_badSource(char * password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); } recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); WSACleanup(); } } return password; #ifndef OMITGOOD char * CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_61b_goodG2BSource(char * password) { /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } else { strcpy(password, \"Password1234!\"); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(char)] = '\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserA( username, domain, password, char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "} memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(char)] = '\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserA( username, domain, password, use the GoodSink */ static void goodB2G() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { closesocket(connectSocket); { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "* GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12_bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } else { /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "if (LogonUserA( username, domain, password, char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } { break; } memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(char)] = '\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserA( username, domain, password, use the BadSink */ static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; if(globalReturnsTrueOrFalse()) { /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_12.c", "text": "BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } { break; } memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(char)] = '\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserA( username, domain, password, use the BadSink */ static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; if(globalReturnsTrueOrFalse()) { strcpy(password, \"Password1234!\"); } else { /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_51b.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, #ifndef OMITGOOD void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_51b_goodG2BSink(wchar_t * password) HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, } void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_51b_goodB2GSink(wchar_t * password) wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_09.c", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_09_bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_09.c", "text": "} memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(char)] = '\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserA( username, domain, password, static void goodG2B1() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; } else { strcpy(password, \"Password1234!\"); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, static void goodG2B2() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; if(GLOBAL_CONST_TRUE) { /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64b.c", "text": "if (LogonUserA( username, domain, password, { char * * passwordPtr = (char * *)passwordVoidPtr; char * password = (*passwordPtr); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, { char * * passwordPtr = (char * *)passwordVoidPtr; char * password = (*passwordPtr); char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22b.c", "text": "* BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext extern int CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22_badGlobal; void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22_badSink(wchar_t * password) HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, extern int CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22_goodG2BGlobal; void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22_goodB2G1Sink(wchar_t * password) wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22b.c", "text": "break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(wchar_t)] = L'\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserW( username, domain, password, } void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22_goodB2G2Sink(wchar_t * password) wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_43.cpp", "text": "recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); static void goodB2G() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; goodB2GSource(password); char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_43.cpp", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD static void badSource(char * &password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_43.cpp", "text": "#ifndef OMITGOOD static void goodG2BSource(char * &password) { strcpy(password, \"Password1234!\"); static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; goodG2BSource(password); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, } static void goodB2GSource(char * &password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_43.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); } recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); void bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; badSource(password); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, #ifndef OMITGOOD static void goodG2BSource(char * &password) { /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_68b.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_68b_goodG2BSink() { wchar_t * password = CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_68_goodG2BData; HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_68b_goodB2GSink() { wchar_t * password = CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_68_goodB2GData; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_44.c", "text": "{ { HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_44_bad() { wchar_t * password; void (*funcPtr) (wchar_t *) = badSink; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_44.c", "text": "} memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(wchar_t)] = L'\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserW( username, domain, password, static void goodB2G() { wchar_t * password; void (*funcPtr) (wchar_t *) = goodB2GSink; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66a.c", "text": "void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66b_badSink(wchar_t * passwordArray[]); void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66_bad() { wchar_t * password; wchar_t * passwordArray[5]; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66a.c", "text": "#ifndef OMITGOOD void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66b_goodG2BSink(wchar_t * passwordArray[]); static void goodG2B() { wchar_t * password; wchar_t * passwordArray[5]; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; wcscpy(password, L\"Password1234!\"); passwordArray[2] = password; } void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66b_goodB2GSink(wchar_t * passwordArray[]); static void goodB2G() { wchar_t * password; wchar_t * passwordArray[5]; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_goodB2G.cpp", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext namespace CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84 { CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_goodB2G::CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_goodB2G(wchar_t * passwordCopy) { password = passwordCopy; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad.cpp", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext namespace CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84 { CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad::CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad(wchar_t * passwordCopy) { password = passwordCopy; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_62b.cpp", "text": "/* * @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD void badSource(char * &password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_62b.cpp", "text": "password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); { closesocket(listenSocket); } if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); #ifndef OMITGOOD void goodG2BSource(char * &password) { strcpy(password, \"Password1234!\"); } void goodB2GSource(char * &password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_62b.cpp", "text": "* @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: listen_socket Read the password using a listen socket (server side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD void badSource(char * &password) { WSADATA wsaData; int wsaDataInit = 0; int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); } recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &password) { /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82a.cpp", "text": "{ closesocket(listenSocket); } if (acceptSocket != INVALID_SOCKET) { closesocket(acceptSocket); } } CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82_base* baseObject = new CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82_bad; baseObject->action(password); static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82_base* baseObject = new CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82_goodG2B; baseObject->action(password); static void goodB2G() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82a.cpp", "text": "void bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); } recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } } CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82_base* baseObject = new CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82_bad; baseObject->action(password); static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_05.c", "text": "void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_05_bad() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_74a.cpp", "text": "* @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: connect_socket Read the password using a connect socket (client side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #ifndef OMITBAD void badSink(map<int, wchar_t *> passwordMap); void bad() { wchar_t * password; map<int, wchar_t *> passwordMap; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_74a.cpp", "text": "wcscpy(password, L\"Password1234!\"); passwordMap[0] = password; passwordMap[1] = password; passwordMap[2] = password; } void goodB2GSink(map<int, wchar_t *> passwordMap); static void goodB2G() { wchar_t * password; map<int, wchar_t *> passwordMap; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_01.c", "text": "password = passwordBuffer; wcscpy(password, L\"Password1234!\"); { HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, static void goodB2G() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } } badStatic = 1; badSink(password); static int goodG2BStatic = 0; static void goodB2G1Sink(char * password) char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } } goodB2G1Static = 0; goodB2G1Sink(password); } static void goodB2G2Sink(char * password) char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21.c", "text": "static int badStatic = 0; static void badSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21_bad() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21.c", "text": "} memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(char)] = '\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserA( username, domain, password, static void goodB2G1() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_21.c", "text": "break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); } } goodB2G2Static = 1; goodB2G2Sink(password); } static void goodG2BSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, static void goodG2B() { char * password; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_67a.c", "text": "* @description * CWE: 319 Cleartext Transmission of Sensitive Information * BadSource: connect_socket Read the password using a connect socket (client side) * GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext typedef struct _CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_67_structType { wchar_t * structFirst; void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_67_bad() { wchar_t * password; CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_67_structType myStruct; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_67a.c", "text": "static void goodG2B() { wchar_t * password; CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_67_structType myStruct; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; wcscpy(password, L\"Password1234!\"); myStruct.structFirst = password; static void goodB2G() { wchar_t * password; CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_67_structType myStruct; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53d.c", "text": "HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, #ifndef OMITGOOD void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53d_goodG2BSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, } void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53d_goodB2GSink(char * password) char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45.c", "text": "HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, static void goodG2B() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; wcscpy(password, L\"Password1234!\"); CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_goodG2BData = password; static void goodB2GSink() { wchar_t * password = CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_goodB2GData; wchar_t * domain = L\"Domain\"; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45.c", "text": "* GoodSource: Use a hardcoded password (one that was not sent over the network) * Sinks: * GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext * BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext #define HASH_INPUT \"ABCDEFG123456\" static wchar_t * CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_badData; static wchar_t * CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_goodG2BData; static wchar_t * CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_goodB2GData; static void badSink() { wchar_t * password = CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_badData; { HANDLE pHandle; wchar_t * username = L\"User\"; wchar_t * domain = L\"Domain\"; if (LogonUserW( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45_bad() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45.c", "text": "payloadBytes = decodeHexWChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(wchar_t)); { break; } { break; } memcpy(password, payload, payloadBytes); password[payloadBytes / sizeof(wchar_t)] = L'\\0'; { CryptReleaseContext(hCryptProv, 0); } if (LogonUserW( username, domain, password, static void goodB2G() { wchar_t * password; wchar_t passwordBuffer[100] = L\"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t passwordLen = wcslen(password); { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_72a.cpp", "text": "char * password; vector<char *> passwordVector; char passwordBuffer[100] = \"\"; password = passwordBuffer; strcpy(password, \"Password1234!\"); passwordVector.insert(passwordVector.end(), 1, password); passwordVector.insert(passwordVector.end(), 1, password); passwordVector.insert(passwordVector.end(), 1, password); static void goodB2G() { char * password; vector<char *> passwordVector; char passwordBuffer[100] = \"\"; password = passwordBuffer; { WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); break; } wsaDataInit = 1; connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_72a.cpp", "text": "{ WSADATA wsaData; int wsaDataInit = 0; int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t passwordLen = strlen(password); { break; } recvResult = recv(connectSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(char), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } password[passwordLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(password, '\\r'); { *replace = '\\0'; } replace = strchr(password, '\\n'); WSACleanup(); } } passwordVector.insert(passwordVector.end(), 1, password); passwordVector.insert(passwordVector.end(), 1, password); passwordVector.insert(passwordVector.end(), 1, password); static void goodG2B() { char * password; vector<char *> passwordVector; char passwordBuffer[100] = \"\"; password = passwordBuffer; /* FIX: Use a hardcoded password (it was not sent over the network) strcpy(password, \"Password1234!\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE319_Cleartext_Tx_Sensitive_Info/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_66b.c", "text": "HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_66b_goodG2BSink(char * passwordArray[]) { char * password = passwordArray[2]; HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_66b_goodB2GSink(char * passwordArray[]) { char * password = passwordArray[2]; char * domain = \"Domain\"; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), password); SecureZeroMemory(password, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(password, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45.c", "text": "* Sinks: fprintf * GoodSink: fwprintf with \"%s\" as the second argument and data as the third * BadSink : fwprintf with data as the second argument * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_badData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_goodG2BData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_goodB2GData; static void badSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_badData; fwprintf(stdout, data); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45.c", "text": "{ wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_goodG2BData; fwprintf(stdout, data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_goodG2BData = data; static void goodB2GSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_45_goodB2GData; fwprintf(stdout, L\"%s\\n\", data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_73a.cpp", "text": "{ wchar_t * data; list<wchar_t *> dataList; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); } void goodB2GSink(list<wchar_t *> dataList); static void goodB2G() { wchar_t * data; list<wchar_t *> dataList; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_08.c", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(staticReturnsTrue()) { fwprintf(stdout, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_09.c", "text": "data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0'; replace = wcschr(data, L'\\r'); { *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(GLOBAL_CONST_TRUE) { fwprintf(stdout, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_54a.c", "text": "void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_54b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_54_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s05/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_54a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_54b_goodG2BSink(wchar_t * data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_54b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_22a.c", "text": "} } CWE134_Uncontrolled_Format_String__char_file_vfprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_file_vfprintf_22_goodB2G1_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_22_goodB2G2_vasink(char * data, ...); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE134_Uncontrolled_Format_String__char_file_vfprintf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_file_vfprintf_22_goodB2G2_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_22_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_01.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument void CWE134_Uncontrolled_Format_String__char_file_printf_01_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } printf(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_74a.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_42.c", "text": "char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); badVaSink(data, data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcpy(data, \"fixedstringtest\"); return data; } static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = goodG2BSource(data); goodG2BVaSink(data, data); } static char * goodB2GSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_42.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } return data; } static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_environment_vprintf_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); badVaSink(data, data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82a.cpp", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_17.c", "text": "vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_17_bad() { int i,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_17.c", "text": "int i,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } for(j = 0; j < 1; j++) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2GVaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G() { int i,k; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_17.c", "text": "{ { va_list args; va_start(args, data); static void goodB2G() { int i,k; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } for(k = 0; k < 1; k++) { goodB2GVaSinkG(data, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { int h,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_06.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(STATIC_CONST_FIVE==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_06.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); } if(STATIC_CONST_FIVE==5) { goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_73a.cpp", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_73a.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_64a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_printf_64_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_printf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_66a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_vfprintf_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_34.c", "text": "* Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE134_Uncontrolled_Format_String__char_file_printf_34_bad() { char * data; CWE134_Uncontrolled_Format_String__char_file_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; printf(data); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_file_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_68a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_snprintf_68_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_snprintf_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_44.c", "text": "void CWE134_Uncontrolled_Format_String__char_file_vfprintf_44_bad() { char * data; void (*funcPtr) (char *, ...) = badVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54a.c", "text": "void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54a.c", "text": "* Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_08.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(staticReturnsTrue()) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_08.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); } if(staticReturnsTrue()) { goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_02.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(1) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_02.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(1) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(1) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_66a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_fprintf_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_52a.c", "text": "* Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_fprintf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_fprintf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_fprintf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_fprintf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_67a.c", "text": "* Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_67_bad() { char * data; CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_33.cpp", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * data = dataRef; fprintf(stdout, data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char * data = dataRef; fprintf(stdout, data); static void goodB2G() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_fprintf_33.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * data = dataRef; fprintf(stdout, data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_snprintf_52a.c", "text": "* Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_snprintf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_snprintf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_snprintf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_snprintf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_34.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; printf(data); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_environment_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); myUnion.unionFirst = data; { char * data = myUnion.unionSecond; printf(data); static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_environment_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_34.c", "text": "* Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_printf_34_bad() { char * data; CWE134_Uncontrolled_Format_String__char_environment_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; printf(data); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_environment_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_45.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_45_badData = data; #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_45_goodG2BData; goodG2BVaSink(data, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_81a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE134_Uncontrolled_Format_String__char_file_printf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_file_printf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_65a.c", "text": "void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_65b_badVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data, data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_72a.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_31.c", "text": "vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_31.c", "text": "{ char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char * dataCopy = data; char * data = dataCopy; goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_31.c", "text": "va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_33.cpp", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * data = dataRef; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char * data = dataRef; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodB2G() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_33.cpp", "text": "* Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } { char * data = dataRef; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_09.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_TRUE) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_09.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_TRUE) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(GLOBAL_CONST_TRUE) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_74a.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_72a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_10.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_printf_10_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalTrue) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_10.c", "text": "if(globalTrue) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_10.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalTrue) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_printf_10.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(globalTrue) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalTrue) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_13.c", "text": "if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_13.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(GLOBAL_CONST_FIVE==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_06.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(STATIC_CONST_FIVE==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_06.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); } if(STATIC_CONST_FIVE==5) { goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_04.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_04_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_04.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(STATIC_CONST_TRUE) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_04.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } else { goodB2G1VaSinkG(data, data); } } static void goodB2G2VaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_04.c", "text": "{ char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(STATIC_CONST_TRUE) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_04.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); } if(STATIC_CONST_TRUE) { goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_18.c", "text": "vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_18.c", "text": "{ { va_list args; va_start(args, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } goto sink; sink: goodB2GVaSinkG(data, data); } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); } } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12.c", "text": "} if(globalReturnsTrueOrFalse()) { badVaSinkB(data, data); } else { badVaSinkG(data, data); #ifndef OMITGOOD static void goodB2GVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); } } static void goodB2GVaSinkG(char * data, ...) { { va_list args; va_start(args, data); use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12.c", "text": "{ { va_list args; va_start(args, data); vfprintf(stdout, data, args); } } static void goodB2GVaSinkG(char * data, ...) { { va_list args; va_start(args, data); use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12.c", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); } } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { { va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_12.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { { va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"fixedstringtest\"); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_07.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_environment_vprintf_07_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_07.c", "text": "{ { va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(staticFive==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_07.c", "text": "} } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); } if(staticFive==5) { goodG2B1VaSinkB(data, data); } } static void goodG2B2VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_fprintf_84_goodG2B.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE134_Uncontrolled_Format_String__char_file_fprintf_84_goodG2B::CWE134_Uncontrolled_Format_String__char_file_fprintf_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63b_goodG2BSink(&data); } void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_81a.cpp", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } const CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); const CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_goodG2B(); baseObject.action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vprintf_81a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } const CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_environment_vprintf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_08.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE134_Uncontrolled_Format_String__char_environment_snprintf_08_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_08.c", "text": "{ char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_08.c", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_snprintf_08.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_goodG2B.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_goodG2B::CWE134_Uncontrolled_Format_String__char_file_vfprintf_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_06.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: environment Read input from an environment variable * GoodSource: Copy a fixed string into data #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_environment_vfprintf_06_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_vfprintf_06.c", "text": "{ { va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } if(STATIC_CONST_FIVE==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_73a.cpp", "text": "* GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void bad() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_file_printf_52a.c", "text": "* Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_file_printf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_file_printf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_printf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_file_printf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_43.cpp", "text": "vsnprintf(dest, 100-1, data, args); } } static void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_43.cpp", "text": "va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); } } static void goodG2BSource(char * &data) { strcpy(data, \"fixedstringtest\"); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2BSource(data); goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); } } static void goodB2GSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s02/CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_43.cpp", "text": "va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); } } static void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); } } static void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_14.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalFive==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_05.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_05_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_05.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } if(staticTrue) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_05.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } else { goodB2G1VaSinkG(data, data); } } static void goodB2G2VaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_05.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(staticTrue) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_33.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #ifndef OMITBAD static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_33.cpp", "text": "char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char * data = dataRef; goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_33.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * data = dataRef; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_10.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(globalTrue) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_10.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_10.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_10.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalTrue) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_06.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(STATIC_CONST_FIVE==5) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_06.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_06.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(STATIC_CONST_FIVE==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_72a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fwprintf with \"%s\" as the second argument and data as the third * BadSink : fwprintf with data as the second argument * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files #ifndef OMITBAD void badSink(vector<wchar_t *> dataVector); void bad() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_72a.cpp", "text": "wcscpy(data, L\"fixedstringtest\"); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); } void goodB2GSink(vector<wchar_t *> dataVector); static void goodB2G() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_67a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_67_bad() { char * data; CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_66a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_vprintf_66_bad() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_73a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fwprintf with \"%s\" as the second argument and data as the third * BadSink : fwprintf with data as the second argument * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #ifndef OMITBAD void badSink(list<wchar_t *> dataList); void bad() { wchar_t * data; list<wchar_t *> dataList; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_05.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: swprintf * GoodSink: snwprintf with \"%s\" as the third argument and data as the fourth * BadSink : snwprintf with data as the third argument void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_05_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_05.c", "text": "} } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(staticTrue) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_11.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(globalReturnsTrue()) { wprintf(data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_64a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_64b_goodG2BSink(&data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_64a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_15.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; switch(7) { case 7: goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_72a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snwprintf with \"%s\" as the third argument and data as the fourth * BadSink : snwprintf with data as the third argument * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files #ifndef OMITBAD void badSink(vector<wchar_t *> dataVector); void bad() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54a.c", "text": "void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_12.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); else { strcpy(data, \"fixedstringtest\"); if(globalReturnsTrueOrFalse()) { fprintf(stdout, data); else { fprintf(stdout, \"%s\\n\", data); use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_12.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_12.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { fprintf(stdout, \"%s\\n\", data); else { fprintf(stdout, \"%s\\n\", data); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_12.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { fprintf(stdout, \"%s\\n\", data); else { fprintf(stdout, \"%s\\n\", data); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"fixedstringtest\"); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_03.c", "text": "vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_03_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_03.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } if(5==5) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_03.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(5==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_02.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(1) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_13.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(GLOBAL_CONST_FIVE==5) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_13.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(GLOBAL_CONST_FIVE==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_13.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(GLOBAL_CONST_FIVE==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(GLOBAL_CONST_FIVE==5) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_31.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_31.c", "text": "char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char * dataCopy = data; char * data = dataCopy; goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_31.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_41.c", "text": "fprintf(stdout, data); void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_41_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_41.c", "text": "static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); goodG2BSink(data); } static void goodB2GSink(char * data) { fprintf(stdout, \"%s\\n\", data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_41.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { fprintf(stdout, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_01.c", "text": "vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_01_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_01.c", "text": "static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_01.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_34.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) #ifndef OMITBAD static void badVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_34_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_34.c", "text": "data = dataBuffer; strcpy(data, \"fixedstringtest\"); myUnion.unionFirst = data; { char * data = myUnion.unionSecond; goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_34.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_41.c", "text": "* Sinks: fprintf * GoodSink: fwprintf with \"%s\" as the second argument and data as the third * BadSink : fwprintf with data as the second argument * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD static void badSink(wchar_t * data) { fwprintf(stdout, data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_41_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_41.c", "text": "data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); goodG2BSink(data); } static void goodB2GSink(wchar_t * data) { fwprintf(stdout, L\"%s\\n\", data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_43.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); } } static void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_43.cpp", "text": "static void goodG2BSource(char * &data) { strcpy(data, \"fixedstringtest\"); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2BSource(data); goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { { va_list args; va_start(args, data); } } static void goodB2GSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_43.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); } } static void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_64a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_printf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_printf_64b_goodG2BSink(&data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_64a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_printf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_84_goodG2B.cpp", "text": "/* * @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_84_goodG2B::CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_83_goodG2B.cpp", "text": "/* * @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_83_goodG2B::CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_83_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_51a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fwprintf with \"%s\" as the second argument and data as the third * BadSink : fwprintf with data as the second argument * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_51b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_51a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_51b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); } } static void badVaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_12.c", "text": "if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82a.cpp", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82a.cpp", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_54a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snwprintf with \"%s\" as the third argument and data as the fourth * BadSink : snwprintf with data as the third argument * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_54b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_54_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_54a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_54b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_33.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #ifndef OMITBAD static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); void bad() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_33.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * data = dataRef; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82a.cpp", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82a.cpp", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63b_goodG2BSink(&data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_21.c", "text": "static int badStatic = 0; static void badVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_21.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } badStatic = 1; badVaSink(data, data); static int goodG2BStatic = 0; static void goodB2G1_vasink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_21.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } goodB2G1Static = 0; goodB2G1_vasink(data, data); } static void goodB2G2_vasink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_21.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } goodB2G2Static = 1; goodB2G2_vasink(data, data); } static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22a.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_badSink(data); int CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22a.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodB2G1Sink(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodB2G2Sink(data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_22_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_67a.c", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snwprintf with \"%s\" as the third argument and data as the fourth * BadSink : snwprintf with data as the third argument * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files typedef struct _CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_67_structType { wchar_t * structFirst; void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_67_bad() { wchar_t * data; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_67_structType myStruct; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_67a.c", "text": "static void goodG2B() { wchar_t * data; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_67_structType myStruct; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); myStruct.structFirst = data; static void goodB2G() { wchar_t * data; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_67_structType myStruct; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_w32_vsnprintf_03.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(5==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_03.c", "text": "vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_03_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_03.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(5==5) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_12.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); } } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); void CWE134_Uncontrolled_Format_String__char_file_vprintf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_12.c", "text": "if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { { va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_12.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } if(globalReturnsTrueOrFalse()) { goodB2GVaSinkG(data, data); } else { goodB2GVaSinkG(data, data); } static void goodG2BVaSinkG(char * data, ...) { { va_list args; va_start(args, data); } } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"fixedstringtest\"); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); myStruct.structFirst = data; static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67a.c", "text": "char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_14.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(globalFive==5) { fwprintf(stdout, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_32.c", "text": "{ char * data = *dataPtr1; strcpy(data, \"fixedstringtest\"); *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_32.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_42.c", "text": "{ { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; } static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_file_vprintf_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); badVaSink(data, data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_10.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(globalTrue) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_10.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_10.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalTrue) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalTrue) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: wprintf with \"%s\" as the first argument and data as the second * BadSink : wprintf with only data as an argument int CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_badSink(data); int CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_goodB2G1Sink(wchar_t * data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_goodB2G1Sink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_22_goodB2G2Sink(wchar_t * data); static void goodB2G2() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_02.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(1) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_02.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(1) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_02.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(1) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(1) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_03.c", "text": "} } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(5==5) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_31.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD static void badVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_31.c", "text": "char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); { char * dataCopy = data; char * data = dataCopy; goodG2BVaSink(data, data); } static void goodB2GVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_31.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_09.c", "text": "} } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(GLOBAL_CONST_TRUE) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_15.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; case 6: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; switch(7) { case 7: goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_64a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: file Read input from a file * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_file_vprintf_64_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_file_vprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_21.c", "text": "* GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: wprintf with \"%s\" as the first argument and data as the second * BadSink : wprintf with only data as an argument static int badStatic = 0; static void badSink(wchar_t * data) if(badStatic) { wprintf(data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_21_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_21.c", "text": "#endif } badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(wchar_t * data) else { wprintf(L\"%s\\n\", data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_21.c", "text": "#endif } goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(wchar_t * data) if(goodB2G2Static) { wprintf(L\"%s\\n\", data); static void goodB2G2() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_67a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); myStruct.structFirst = data; static void goodB2G() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_67a.c", "text": "char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } myStruct.structFirst = data; static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_18.c", "text": "vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_18.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } goto sink; sink: goodB2GVaSinkG(data, data); } static void goodG2BVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22a.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badVaSink(data, data); int CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodB2G1_vasink(char * data, ...); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22a.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodB2G1_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodB2G2_vasink(char * data, ...); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodB2G2_vasink(data, data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_file_vprintf_01.c", "text": "void CWE134_Uncontrolled_Format_String__char_file_vprintf_01_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_goodG2BSink(&data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s03/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_51a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfwprintf with a format string * BadSink : vfwprintf without a format string * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_51b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_51_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_51a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_51b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_05.c", "text": "#ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { va_list args; va_start(args, data); vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_05_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_05.c", "text": "} if(staticTrue) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_44.c", "text": "#ifndef OMITBAD static void badVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = badVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_44.c", "text": "data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); funcPtr(data); } static void goodB2GVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = goodB2GVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82a.cpp", "text": "#endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82_bad; baseObject->action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_42.c", "text": "{ { va_list args; va_start(args, data); vfwprintf(stdout, data, args); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; data = goodG2BSource(data); goodG2BVaSink(data, data); } static wchar_t * goodB2GSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_33.cpp", "text": "#ifndef OMITBAD static void badVaSink(wchar_t * data, ...) { { va_list args; va_start(args, data); vfwprintf(stdout, data, args); void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_33.cpp", "text": "wcscpy(data, L\"fixedstringtest\"); { wchar_t * data = dataRef; goodG2BVaSink(data, data); } static void goodB2GVaSink(wchar_t * data, ...) { { va_list args; va_start(args, data); static void goodB2G() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_81a.cpp", "text": "#endif } const CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_81_bad(); baseObject.action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); const CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_81_goodG2B(); baseObject.action(data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_72a.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: w32_vsnprintf * GoodSink: _vsnwprintf with a format string * BadSink : _vsnwprintf without a format string * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files #ifndef OMITBAD void badSink(vector<wchar_t *> dataVector); void bad() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22a.c", "text": "int CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_badVaSink(wchar_t * data, ...); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_badVaSink(data, data); int CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_goodB2G1_vasink(wchar_t * data, ...); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #endif } CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_goodB2G1_vasink(data, data); } void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_22_goodB2G2_vasink(wchar_t * data, ...); static void goodB2G2() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s04/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_18.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(wchar_t * data, ...) { { va_list args; va_start(args, data); vwprintf(data, args); void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_18_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument int CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_badGlobal = 0; void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_badGlobal = 1; CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_badSink(data); int CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodG2BGlobal = 0; void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodB2G1Sink(char * data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22a.c", "text": "while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodB2G1Global = 0; CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodB2G1Sink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodB2G2Sink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_22_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_badVaSink(char * data, ...); void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65_bad() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_badVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65a.c", "text": "char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); funcPtr(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_goodB2GVaSink(char * data, ...); static void goodB2G() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_goodB2GVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data, data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_goodG2BVaSink(char * data, ...); static void goodG2B() { char * data; void (*funcPtr) (char *, ...) = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_goodG2BVaSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_72a.cpp", "text": "char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodB2G() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_72a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_11.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_11.c", "text": "} if(globalReturnsTrue()) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(char * data, ...) { { va_list args; va_start(args, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_11.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(globalReturnsTrue()) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_66a.c", "text": "static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); dataArray[2] = data; static void goodB2G() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_66a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_01.c", "text": "* GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument void CWE134_Uncontrolled_Format_String__char_console_snprintf_01_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81a.cpp", "text": "#endif } const CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); const CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_goodG2B(); baseObject.action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } const CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_14.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(globalFive==5) { fprintf(stdout, data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_14.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalFive==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_14.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalFive==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalFive==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_12.c", "text": "else { strcpy(data, \"fixedstringtest\"); if(globalReturnsTrueOrFalse()) { printf(data); else { printf(\"%s\\n\", data); use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_12.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_12.c", "text": "* GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_12.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { printf(\"%s\\n\", data); else { printf(\"%s\\n\", data); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_12.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { printf(\"%s\\n\", data); else { printf(\"%s\\n\", data); use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"fixedstringtest\"); strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_04.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vfprintf_64a.c", "text": "* Sinks: vfprintf * GoodSink: vfprintf with a format string * BadSink : vfprintf without a format string * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_console_vfprintf_64_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_vfprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_13.c", "text": "else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_FIVE==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_13.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(GLOBAL_CONST_FIVE==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(GLOBAL_CONST_FIVE==5) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_goodG2BSink(&data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_badSink(&data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45.c", "text": "{ { va_list args; va_start(args, data); vprintf(data, args); static void badSink() { char * data = CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45_badData; badVaSink(data, data); void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45.c", "text": "} static void goodB2GVaSink(char * data, ...) { { va_list args; va_start(args, data); static void goodB2GSink() { char * data = CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45_goodB2GData; goodB2GVaSink(data, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45.c", "text": "recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45_badData = data; #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2BSink() { char * data = CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_45_goodG2BData; goodG2BVaSink(data, data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_44.c", "text": "* Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_44.c", "text": "data = dataBuffer; strcpy(data, \"fixedstringtest\"); funcPtr(data); } static void goodB2GSink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, \"%s\", data); static void goodB2G() { char * data; void (*funcPtr) (char *) = goodB2GSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_44.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_64a.c", "text": "} #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_64b_goodG2BSink(&data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_64a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_64b_badSink(&data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_21.c", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } goodB2G2Static = 1; goodB2G2Sink(data); } static void goodG2BSink(char * data) if(goodG2BStatic) { printf(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_62b.cpp", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: console Read input from the console * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_83_goodG2B.cpp", "text": "/* * @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: fprintf * GoodSink: fprintf with \"%s\" as the second argument and data as the third * BadSink : fprintf with data as the second argument * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_83_goodG2B::CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_83_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_42.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE134_Uncontrolled_Format_String__char_console_snprintf_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_44.c", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { printf(data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_vprintf_34.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); #ifndef OMITGOOD static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_console_vprintf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82a.cpp", "text": "#endif } CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_11.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(globalReturnsTrue()) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_11.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrue()) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_11.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrue()) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalReturnsTrue()) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_62b.cpp", "text": "* Sinks: w32_vsnprintf * GoodSink: vsnprintf with a format string * BadSink : vsnprintf without a format string * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_54a.c", "text": "void CWE134_Uncontrolled_Format_String__char_console_fprintf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_fprintf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_console_fprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_14.c", "text": "else { printf(\"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_14.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalFive==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(globalFive==5) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_34.c", "text": "char * data; CWE134_Uncontrolled_Format_String__char_console_fprintf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; fprintf(stdout, data); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_console_fprintf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_22a.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE134_Uncontrolled_Format_String__char_console_fprintf_22_goodB2G2Global = 1; CWE134_Uncontrolled_Format_String__char_console_fprintf_22_goodB2G2Sink(data); } void CWE134_Uncontrolled_Format_String__char_console_fprintf_22_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_43.cpp", "text": "#ifndef OMITBAD static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82a.cpp", "text": "#endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_84_goodG2B.cpp", "text": "/* * @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_84_goodG2B::CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_84_goodG2B(char * dataCopy) { data = dataCopy; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_34.c", "text": "char * data; CWE134_Uncontrolled_Format_String__char_console_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; printf(data); static void goodG2B() { char * data; CWE134_Uncontrolled_Format_String__char_console_printf_34_unionType myUnion; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_51a.c", "text": "void CWE134_Uncontrolled_Format_String__char_console_printf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_printf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_console_printf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_07.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); if(staticFive==5) { printf(data); static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_07.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(staticFive==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_07.c", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(staticFive==5) { printf(\"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(staticFive==5) { printf(data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_18.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_18_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_18.c", "text": "} goto sink; sink: badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2GVaSinkG(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_18.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } goto sink; sink: goodB2GVaSinkG(data, data); } static void goodG2BVaSinkB(char * data, ...) { char dest[100] = \"\"; va_list args; va_start(args, data); vsnprintf(dest, 100-1, data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_11.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data #ifndef OMITBAD static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_11.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } if(globalReturnsTrue()) { goodB2G2VaSinkG(data, data); } } static void goodG2B1VaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82a.cpp", "text": "#endif } CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_snprintf_68a.c", "text": "* Sinks: snprintf * GoodSink: snprintf with \"%s\" as the third argument and data as the fourth * BadSink : snprintf with data as the third argument * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE134_Uncontrolled_Format_String__char_console_snprintf_68_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE134_Uncontrolled_Format_String__char_console_snprintf_68_badData = data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data static int badStatic = 0; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } goodB2G2Static = 1; goodB2G2_vasink(data, data); } static void goodG2BVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51a.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Copy a fixed string into data * Sinks: vprintf * GoodSink: vprintf with a format string * BadSink : vprintf without a format string * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51b_badSink(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\"); CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51b_badSink(data); #ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_18.c", "text": "goto sink; sink: printf(data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; goto sink; sink: printf(\"%s\\n\", data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_printf_43.cpp", "text": "* Sinks: printf * GoodSink: printf with \"%s\" as the first argument and data as the second * BadSink : printf with only data as an argument * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); printf(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_43.cpp", "text": "static void goodG2BSource(char * &data) { strcpy(data, \"fixedstringtest\"); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; goodG2BSource(data); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); } static void goodB2GSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_43.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; badSource(data); { char dest[100] = \"\"; SNPRINTF(dest, 100-1, data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_06.c", "text": "else { fprintf(stdout, \"%s\\n\", data); static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s01/CWE134_Uncontrolled_Format_String__char_console_fprintf_06.c", "text": "if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(STATIC_CONST_FIVE==5) { fprintf(stdout, \"%s\\n\", data); static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; else { strcpy(data, \"fixedstringtest\"); if(STATIC_CONST_FIVE==5) { fprintf(stdout, data); static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"fixedstringtest\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65a.c", "text": "void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65b_badVaSink(wchar_t * data, ...); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65_bad() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65b_badVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65b_goodG2BVaSink(wchar_t * data, ...); static void goodG2B() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65b_goodG2BVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); funcPtr(data); } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65b_goodB2GVaSink(wchar_t * data, ...); static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65b_goodB2GVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_17.c", "text": "vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_17_bad() { int i,j; wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_17.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } for(j = 0; j < 1; j++) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2GVaSinkG(wchar_t * data, ...) { { va_list args; va_start(args, data); static void goodB2G() { int i,k; wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_61b.c", "text": "{ CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } return data; #ifndef OMITGOOD wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_61b_goodG2BSource(wchar_t * data) { wcscpy(data, L\"fixedstringtest\"); return data; } wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_61b_goodB2GSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_16.c", "text": "_vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_16_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_16.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } while(1) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2GVaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_82a.cpp", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #endif } CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_82_bad; baseObject->action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_82_goodG2B; baseObject->action(data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_64a.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #endif } CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_64b_badSink(&data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_64b_goodG2BSink(&data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_43.cpp", "text": "data = dataBuffer; badSource(data); wprintf(data); #ifndef OMITGOOD static void goodG2BSource(wchar_t * &data) { wcscpy(data, L\"fixedstringtest\"); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; goodG2BSource(data); wprintf(data); } static void goodB2GSource(wchar_t * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_44.c", "text": "* Sinks: vfprintf * GoodSink: vfwprintf with a format string * BadSink : vfwprintf without a format string * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badVaSink(wchar_t * data, ...) { { va_list args; va_start(args, data); vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = badVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53a.c", "text": "void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53b_badSink(wchar_t * data); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53b_goodG2BSink(wchar_t * data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53b_goodG2BSink(data); } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_04.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data #define LISTEN_BACKLOG 5 vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_04_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_66a.c", "text": "void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_66b_badSink(wchar_t * dataArray[]); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_66_bad() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_66a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_66b_goodG2BSink(wchar_t * dataArray[]); static void goodG2B() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); dataArray[2] = data; } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_66b_goodB2GSink(wchar_t * dataArray[]); static void goodB2G() { wchar_t * data; wchar_t * dataArray[5]; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_44.c", "text": "* Sinks: w32_vsnprintf * GoodSink: _vsnwprintf with a format string * BadSink : _vsnwprintf without a format string * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); _vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = badVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_44.c", "text": "wchar_t * data; void (*funcPtr) (wchar_t *, ...) = goodG2BVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); funcPtr(data); } static void goodB2GVaSink(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *, ...) = goodB2GVaSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_13.c", "text": "_vsnwprintf(dest, 100-1, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_13_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_13.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } if(GLOBAL_CONST_FIVE==5) { badVaSinkB(data, data); #ifndef OMITGOOD static void goodB2G1VaSinkG(wchar_t * data, ...) { { wchar_t dest[100] = L\"\"; va_list args; va_start(args, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_63a.c", "text": "void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_63b_badSink(wchar_t * * dataPtr); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_63_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_63a.c", "text": "#ifndef OMITGOOD void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_63b_goodG2BSink(wchar_t * * data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_63b_goodG2BSink(&data); } void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_63b_goodB2GSink(wchar_t * * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_06.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(STATIC_CONST_FIVE==5) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_33.cpp", "text": "static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); { wchar_t * data = dataRef; { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_06.c", "text": "* @description * CWE: 134 Uncontrolled Format String * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Copy a fixed string into data #define LISTEN_BACKLOG 5 vfwprintf(stdout, data, args); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_06_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45.c", "text": "* Sinks: printf * GoodSink: wprintf with \"%s\" as the first argument and data as the second * BadSink : wprintf with only data as an argument * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_badData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_goodG2BData; static wchar_t * CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_goodB2GData; static void badSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_badData; wprintf(data); void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45.c", "text": "{ wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_goodG2BData; wprintf(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"fixedstringtest\"); CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_goodG2BData = data; static void goodB2GSink() { wchar_t * data = CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_45_goodB2GData; wprintf(L\"%s\\n\", data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE134_Uncontrolled_Format_String/s06/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_08.c", "text": "{ *replace = L'\\0'; } replace = wcschr(data, L'\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); if(staticReturnsTrue()) { { wchar_t dest[100] = L\"\"; SNPRINTF(dest, 100-1, data); static void goodB2G1() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_12.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_12.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails * BadSink : Do not check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_12.c", "text": "* CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails * BadSink : Do not check if fscanf() fails #ifndef OMITBAD void CWE252_Unchecked_Return_Value__char_fscanf_12_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; fscanf(stdin, \"%99s\\0\", data); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF) { printLine(\"fscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (fscanf(stdin, \"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_sscanf_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_sscanf_16.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: sscanf * GoodSink: Check if sscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_sscanf_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_sscanf_16.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: sscanf * GoodSink: Check if sscanf() fails * BadSink : Do not check if sscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_02.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_02.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails * BadSink : Do not check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_sscanf_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_sscanf_08.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: sscanf * GoodSink: Check if sscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_sscanf_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_sscanf_08.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: sscanf * GoodSink: Check if sscanf() fails * BadSink : Do not check if sscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_14.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE252_Unchecked_Return_Value/CWE252_Unchecked_Return_Value__char_fscanf_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE252_Unchecked_Return_Value__char_fscanf_14.c /* * @description * CWE: 252 Unchecked Return Value * Sinks: fscanf * GoodSink: Check if fscanf() fails * BadSink : Do not check if fscanf() fails", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_52c.c", "text": "memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_64b.c", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_64b.c", "text": "*/ char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_char_memcpy_64b_goodG2BSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_68b.cpp", "text": "*/ memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; void goodG2BSink() { char * data = CWE126_Buffer_Overread__new_char_memcpy_68_goodG2BData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_45.c", "text": "#include <wchar.h> static wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_badData; static wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_goodG2BData; static void badSink() { wchar_t * data = CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_badData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); } } void CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_bad() { wchar_t * data; data = NULL; data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE126_Buffer_Overread__malloc_wchar_t_memmove_45_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_33.cpp", "text": "data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_33.cpp", "text": "void bad() { char * data; char * &dataRef = data; data = NULL; data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_wchar_t_memcpy_67b.cpp", "text": "*/ memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; void goodG2BSink(structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_08.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_08.c", "text": "void CWE126_Buffer_Overread__malloc_char_memcpy_08_bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_08.c", "text": "static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_41.cpp", "text": "#include <wchar.h> namespace CWE126_Buffer_Overread__new_char_memcpy_41 #ifndef OMITBAD void badSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; void bad() { char * data; data = NULL; data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53d.c", "text": "memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_53d_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_52c.c", "text": "memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_wchar_t_memmove_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memmove_12.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memmove_12.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); * both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_05.c", "text": "void CWE126_Buffer_Overread__malloc_char_memcpy_05_bad() { char * data; data = NULL; if(staticTrue) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_05.c", "text": "static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B2() { char * data; data = NULL; if(staticTrue) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_68b.c", "text": "*/ memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_68b_goodG2BSink() { wchar_t * data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_68_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_84_bad.cpp", "text": "data = new char[50]; memset(data, 'A', 50-1); data[50-1] = '\\0'; } CWE126_Buffer_Overread__new_char_memcpy_84_bad::~CWE126_Buffer_Overread__new_char_memcpy_84_bad() { { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memmove_32.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memmove_32.c", "text": "if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22a.c", "text": "int CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_badGlobal = 0; wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_badSource(wchar_t * data); void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_bad() { wchar_t * data; data = NULL; CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_badGlobal = 1; data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22a.c", "text": "wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_badSource(wchar_t * data); void CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_bad() { wchar_t * data; data = NULL; CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_badGlobal = 1; data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); #ifndef OMITGOOD int CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Global = 0; int CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B2Global = 0; wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = NULL; CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Global = 0; data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22a.c", "text": "int CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Global = 0; int CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B2Global = 0; wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = NULL; CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Global = 0; data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); } wchar_t * CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B2Source(wchar_t * data); static void goodG2B2() { wchar_t * data; data = NULL; CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B2Global = 1; data = CWE126_Buffer_Overread__malloc_wchar_t_memcpy_22_goodG2B2Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memmove_63b.cpp", "text": "memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; void goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_61a.cpp", "text": "char * badSource(char * data); void bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__new_char_memcpy_61a.cpp", "text": "#include <wchar.h> namespace CWE126_Buffer_Overread__new_char_memcpy_61 #ifndef OMITBAD char * badSource(char * data); void bad() { char * data; data = NULL; data = badSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); delete [] data; #ifndef OMITGOOD char * goodG2BSource(char * data); static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_21.c", "text": "static int badStatic = 0; static wchar_t * badSource(wchar_t * data) if(badStatic) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } return data; } void CWE126_Buffer_Overread__malloc_wchar_t_memmove_21_bad() { wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_21.c", "text": "wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static int goodG2B2Static = 0; static wchar_t * goodG2B1Source(wchar_t * data) else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } return data; static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_21.c", "text": "wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); } static wchar_t * goodG2B2Source(wchar_t * data) if(goodG2B2Static) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } return data; static void goodG2B2() { wchar_t * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_32.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_32.c", "text": "if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_10.c", "text": "void CWE126_Buffer_Overread__malloc_wchar_t_memmove_10_bad() { wchar_t * data; data = NULL; if(globalTrue) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_wchar_t_memmove_10.c", "text": "static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(globalTrue) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_07.c", "text": "void CWE126_Buffer_Overread__malloc_char_memcpy_07_bad() { char * data; data = NULL; if(staticFive==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s02/CWE126_Buffer_Overread__malloc_char_memcpy_07.c", "text": "static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); free(data); static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memmove_09.c", "text": "if(GLOBAL_CONST_TRUE) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memmove_09.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_declare_memmove_09_bad() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataGoodBuffer[100-1] = L'\\0'; if(GLOBAL_CONST_TRUE) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memmove_09.c", "text": "* could be smaller than dest causing buffer overread */ memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataGoodBuffer[100-1] = L'\\0'; if(GLOBAL_CONST_TRUE) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_04.c", "text": "if(STATIC_CONST_TRUE) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_04.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_04_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(STATIC_CONST_TRUE) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_04.c", "text": "* could be smaller than dest causing buffer overread */ memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(STATIC_CONST_TRUE) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memmove_64b.c", "text": "* @description * CWE: 126 Buffer Over-read * BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_declare_memmove_64b_badSink(void * dataVoidPtr) { wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__wchar_t_declare_memmove_64b_goodG2BSink(void * dataVoidPtr) { wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr; wchar_t * data = (*dataPtr); { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_32.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_32.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = NULL; { wchar_t * data = *dataPtr1; data = new wchar_t[100]; wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_09.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_09_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(GLOBAL_CONST_TRUE) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_09.c", "text": "* could be smaller than dest causing buffer overread */ memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(GLOBAL_CONST_TRUE) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_03.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_03_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(5==5) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_03.c", "text": "* could be smaller than dest causing buffer overread */ memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(5==5) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_84_bad.cpp", "text": "data = new wchar_t[50]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } CWE126_Buffer_Overread__new_wchar_t_memmove_84_bad::~CWE126_Buffer_Overread__new_wchar_t_memmove_84_bad() { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_52c.c", "text": "memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_05_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(staticTrue) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_05.c", "text": "* could be smaller than dest causing buffer overread */ memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(staticTrue) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_declare_memcpy_31.c", "text": "{ wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B() { wchar_t * data; wchar_t dataBadBuffer[50]; wchar_t dataGoodBuffer[100]; dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataGoodBuffer; { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_53d.c", "text": "memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_53d_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_45.c", "text": "#include <wchar.h> static wchar_t * CWE126_Buffer_Overread__wchar_t_alloca_memcpy_45_badData; static wchar_t * CWE126_Buffer_Overread__wchar_t_alloca_memcpy_45_goodG2BData; static void badSink() { wchar_t * data = CWE126_Buffer_Overread__wchar_t_alloca_memcpy_45_badData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); } } void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_45_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; CWE126_Buffer_Overread__wchar_t_alloca_memcpy_45_badData = data; static void goodG2BSink() { wchar_t * data = CWE126_Buffer_Overread__wchar_t_alloca_memcpy_45_goodG2BData; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memcpy_41.c", "text": "* GoodSource: Set data pointer to a large buffer * Sink: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_41_badSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); } } void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_41_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBadBuffer[50-1] = L'\\0'; wmemset(dataGoodBuffer, L'A', 100-1); dataGoodBuffer[100-1] = L'\\0'; data = dataBadBuffer; CWE126_Buffer_Overread__wchar_t_alloca_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE126_Buffer_Overread__wchar_t_alloca_memcpy_41_goodG2BSink(wchar_t * data) { { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_06.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_06_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_06.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__wchar_t_alloca_memmove_06_bad() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(STATIC_CONST_FIVE==5) { data = dataBadBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__wchar_t_alloca_memmove_06.c", "text": "* could be smaller than dest causing buffer overread */ memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B1() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); static void goodG2B2() { wchar_t * data; wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t)); wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataGoodBuffer[100-1] = L'\\0'; if(STATIC_CONST_FIVE==5) { data = dataGoodBuffer; } { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s03/CWE126_Buffer_Overread__new_wchar_t_memmove_66b.cpp", "text": "*/ wchar_t * data = dataArray[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t)); dest[100-1] = L'\\0'; printWLine(dest); delete [] data; #ifndef OMITGOOD void goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t dest[100]; wmemset(dest, L'C', 100-1); dest[100-1] = L'\\0'; memmove(dest, data, wcslen(dest)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_11.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_11.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_11.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); dest[99] = '\\0'; printLine(dest); if(globalReturnsTrue()) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_13.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_listen_socket_13_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_32.c", "text": "int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodG2B() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = -1; { int data = *dataPtr1; data = 7; *dataPtr1 = data; } { int data = *dataPtr2; int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodB2G() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = -1; { int data = *dataPtr1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memmove_17.c", "text": "for(i = 0; i < 1; i++) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memmove_17.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE126_Buffer_Overread__char_alloca_memmove_17_bad() { int i; char * data; dataGoodBuffer[100-1] = '\\0'; for(i = 0; i < 1; i++) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { int h; char * data; dataGoodBuffer[100-1] = '\\0'; for(h = 0; h < 1; h++) { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_08.c", "text": "if(staticReturnsTrue()) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_08.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memcpy * BadSink : Copy data to string using memcpy #ifndef OMITBAD void CWE126_Buffer_Overread__char_declare_memcpy_08_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_08.c", "text": "memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataGoodBuffer[100-1] = '\\0'; if(staticReturnsTrue()) { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_44.c", "text": "if (data >= 0) { printIntLine(buffer[data]); } } void CWE126_Buffer_Overread__CWE129_fscanf_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_44.c", "text": "#ifndef OMITGOOD static void goodG2BSink(int data) int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); static void goodG2B() { int data; void (*funcPtr) (int) = goodG2BSink; data = -1; data = 7; funcPtr(data); } static void goodB2GSink(int data) { { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); static void goodB2G() { int data; void (*funcPtr) (int) = goodB2GSink; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_34.c", "text": "void CWE126_Buffer_Overread__char_declare_memcpy_34_bad() { char * data; CWE126_Buffer_Overread__char_declare_memcpy_34_unionType myUnion; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; CWE126_Buffer_Overread__char_declare_memcpy_34_unionType myUnion; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataGoodBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_61b.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD int CWE126_Buffer_Overread__CWE129_listen_socket_61b_badSource(int data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_61b.c", "text": "break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #ifndef OMITGOOD int CWE126_Buffer_Overread__CWE129_listen_socket_61b_goodG2BSource(int data) } int CWE126_Buffer_Overread__CWE129_listen_socket_61b_goodB2GSource(int data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_44.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) } } void CWE126_Buffer_Overread__CWE129_listen_socket_44_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_72a.cpp", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking the upper bound * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE126_Buffer_Overread__CWE129_fscanf_72 void bad() { int data; vector<int> dataVector; data = -1; fscanf(stdin, \"%d\", &data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { int data; vector<int> dataVector; data = -1; data = 7; dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodB2G() { int data; vector<int> dataVector; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_34.c", "text": "memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_34.c", "text": "void CWE126_Buffer_Overread__char_declare_memmove_34_bad() { char * data; CWE126_Buffer_Overread__char_declare_memmove_34_unionType myUnion; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; CWE126_Buffer_Overread__char_declare_memmove_34_unionType myUnion; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataGoodBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memmove_31.c", "text": "memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataBadBuffer; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memmove_31.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__char_alloca_memmove_31_bad() { char * data; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataBadBuffer; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataGoodBuffer; { char * dataCopy = data; char * data = dataCopy; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_45.c", "text": "#include <wchar.h> static char * CWE126_Buffer_Overread__char_declare_memcpy_45_badData; static char * CWE126_Buffer_Overread__char_declare_memcpy_45_goodG2BData; static void badSink() { char * data = CWE126_Buffer_Overread__char_declare_memcpy_45_badData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); } } void CWE126_Buffer_Overread__char_declare_memcpy_45_bad() { char * data; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataBadBuffer; CWE126_Buffer_Overread__char_declare_memcpy_45_badData = data; static void goodG2BSink() { char * data = CWE126_Buffer_Overread__char_declare_memcpy_45_goodG2BData; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memcpy_07.c", "text": "if(staticFive==5) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memcpy_07.c", "text": "#include <wchar.h> if(staticFive==5) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memcpy_07.c", "text": "memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B2() { char * data; dataGoodBuffer[100-1] = '\\0'; if(staticFive==5) { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_connect_socket_82a.cpp", "text": "#include \"std_testcase.h\" #include \"CWE126_Buffer_Overread__CWE129_connect_socket_82.h\" #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE126_Buffer_Overread__CWE129_connect_socket_82 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_connect_socket_82a.cpp", "text": "break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #endif } CWE126_Buffer_Overread__CWE129_connect_socket_82_base* baseObject = new CWE126_Buffer_Overread__CWE129_connect_socket_82_bad; data = 7; CWE126_Buffer_Overread__CWE129_connect_socket_82_base* baseObject = new CWE126_Buffer_Overread__CWE129_connect_socket_82_goodG2B; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_15.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_listen_socket_15_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memcpy_67b.c", "text": "* @description * CWE: 126 Buffer Over-read * BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #include <wchar.h> typedef struct _CWE126_Buffer_Overread__char_declare_memcpy_67_structType { char * structFirst; } CWE126_Buffer_Overread__char_declare_memcpy_67_structType; #ifndef OMITBAD void CWE126_Buffer_Overread__char_declare_memcpy_67b_badSink(CWE126_Buffer_Overread__char_declare_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); #ifndef OMITGOOD void CWE126_Buffer_Overread__char_declare_memcpy_67b_goodG2BSink(CWE126_Buffer_Overread__char_declare_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memcpy(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memmove_34.c", "text": "void CWE126_Buffer_Overread__char_alloca_memmove_34_bad() { char * data; CWE126_Buffer_Overread__char_alloca_memmove_34_unionType myUnion; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataBadBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; CWE126_Buffer_Overread__char_alloca_memmove_34_unionType myUnion; dataBadBuffer[50-1] = '\\0'; memset(dataGoodBuffer, 'A', 100-1); dataGoodBuffer[100-1] = '\\0'; data = dataGoodBuffer; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_memcpy_03.c", "text": "memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char)); dest[99] = '\\0'; printLine(dest); if(5==5) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; memcpy(dest, data, 99*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_05_bad() /* strncpy() does not null terminate if the string in the src buffer is larger than", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_05_bad() if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_05_bad()", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_05_bad() if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_05_bad() dest[99] = '\\0';", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE170_char_strncpy_05.c", "text": "#ifndef OMITBAD void CWE126_Buffer_Overread__CWE170_char_strncpy_05_bad() if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); printLine(dest); else { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99); dest[99] = '\\0'; printLine(dest); if(staticTrue) { { char data[150], dest[100]; memset(data, 'A', 149); data[149] = '\\0'; strncpy(dest, data, 99);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_18.c", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #ifndef OMITBAD void CWE126_Buffer_Overread__CWE129_listen_socket_18_bad() WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memmove_02.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE126_Buffer_Overread__char_alloca_memmove_02_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; if(1) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B1() { char * data; } else { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_listen_socket_43.cpp", "text": "/* * @description * CWE: 126 Buffer Overread #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE126_Buffer_Overread__CWE129_listen_socket_43 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_declare_memmove_17.c", "text": "* BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE126_Buffer_Overread__char_declare_memmove_17_bad() { int i; char * data; dataGoodBuffer[100-1] = '\\0'; for(i = 0; i < 1; i++) { data = dataBadBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { int h; char * data; dataGoodBuffer[100-1] = '\\0'; for(h = 0; h < 1; h++) { data = dataGoodBuffer; } { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__char_alloca_memmove_18.c", "text": "* @description * CWE: 126 Buffer Over-read * BadSource: Set data pointer to a small buffer * GoodSource: Set data pointer to a large buffer * Sink: memmove * BadSink : Copy data to string using memmove #ifndef OMITBAD void CWE126_Buffer_Overread__char_alloca_memmove_18_bad() { char * data; dataGoodBuffer[100-1] = '\\0'; goto source; source: data = dataBadBuffer; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char)); dest[100-1] = '\\0'; printLine(dest); static void goodG2B() { char * data; dataGoodBuffer[100-1] = '\\0'; goto source; source: data = dataGoodBuffer; { char dest[100]; memset(dest, 'C', 100-1); dest[100-1] = '\\0'; memmove(dest, data, strlen(dest)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_61b.c", "text": "fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD int CWE126_Buffer_Overread__CWE129_fscanf_61b_goodG2BSource(int data) } int CWE126_Buffer_Overread__CWE129_fscanf_61b_goodB2GSource(int data)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE126_Buffer_Overread/s01/CWE126_Buffer_Overread__CWE129_fscanf_61b.c", "text": "fscanf(stdin, \"%d\", &data); return data; #ifndef OMITGOOD int CWE126_Buffer_Overread__CWE129_fscanf_61b_goodG2BSource(int data) { data = 7; return data; } int CWE126_Buffer_Overread__CWE129_fscanf_61b_goodB2GSource(int data) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_81_goodG2B.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_81 { void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_81_goodG2B::action(int * data) const { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_34.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: cpy * BadSink : Copy data to string using strcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = new char[100]; memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_08.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_08.cpp", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(staticReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_03.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: cat * BadSink : Copy string to data using strcat void bad() { char * data; data = NULL; if(5==5) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_03.cpp", "text": "strcat(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(5==5) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_13.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: cat * BadSink : Copy string to data using strcat void bad() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_13.cpp", "text": "strcat(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_83_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_83_goodG2B() { { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_82_bad.cpp", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_82 { void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_82_bad::action(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_18.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; goto source; source: memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strcpy(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_10.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: cat * BadSink : Copy string to data using strcat void bad() { char * data; data = NULL; if(globalTrue) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_10.cpp", "text": "strcat(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(globalTrue) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_01_bad() { int * data; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_01.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memcpy * BadSink : Copy array to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_01_bad() { int * data; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; data = NULL; data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_01.cpp", "text": "data = new char[50]; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_01.cpp", "text": "data = new char[50]; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; data = new char[100]; data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_84_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_84_bad() { { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_45.cpp", "text": "strcpy(dest, data); printLine(data); delete [] data; void bad() { char * data; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; badData = data; static void goodG2BSink() { char * data = goodG2BData; { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_31.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_44.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memcpy * BadSink : Copy array to data using memcpy() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_44_bad() { int * data; void (*funcPtr) (int *) = badSink; data = NULL; data = (int *)malloc(10); if (data == NULL) {exit(-1);} funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int * data) { { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_52c.cpp", "text": "strcat(dest, data); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_c(char * data) { { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_63b.cpp", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; void goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_07.cpp", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat #include <wchar.h> memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_07.cpp", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(staticFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_74b.cpp", "text": "char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_31.cpp", "text": "data = new char[50]; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_31.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; data = NULL; data = new char[50]; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; data = new char[100]; data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_44.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: cat * BadSink : Copy string to data using strcat * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; void bad() { char * data; void (*funcPtr) (char *) = badSink; data = NULL; data = new char[50]; data[0] = '\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_12.cpp", "text": "void bad() { char * data; data = new char[100]; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; both branches use the GoodSource */ static void goodG2B() { char * data; data = new char[100]; if(globalReturnsTrueOrFalse()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_10.cpp", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(globalTrue) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_34.cpp", "text": "data = new char[50]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_34.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: cat * BadSink : Copy string to data using strcat * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[50]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = NULL; data = new char[100]; data[0] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_83_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_83_goodG2B() { { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_07.c", "text": "{ data = (int *)malloc(10); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; else { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(staticFive==5) { data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[10] = {0}; memcpy(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_11.cpp", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(globalReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s05/CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cpy_07.cpp", "text": "data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(staticFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53d.cpp", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22a.cpp", "text": "int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = NULL; badGlobal = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22a.cpp", "text": "a C++ namespace, it doesn't need a globally unique name. */ int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = NULL; badGlobal = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22a.cpp", "text": "#ifndef OMITGOOD char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; ; } char * goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; goodG2B2Global = 1; data = goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21.cpp", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { data = new char[50]; data[0] = '\\0'; } return data; void bad() { char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21.cpp", "text": "char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; #ifndef OMITGOOD static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { data = new char[100]; data[0] = '\\0'; } return data; static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21.cpp", "text": "static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; ; } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { data = new char[100]; data[0] = '\\0'; } return data; static void goodG2B2() { char * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_43.cpp", "text": "data = new char[50]; data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_43.cpp", "text": "void badSource(char * &data) { data = new char[50]; data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD static void goodG2BSource(char * &data) { data = new char[100]; data[0] = '\\0'; static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_83_bad.cpp", "text": "data = new char[50]; data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_83_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_83_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_08.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(staticReturnsTrue()) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_08.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(staticReturnsTrue()) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_08.cpp", "text": "data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(staticReturnsTrue()) { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_15.cpp", "text": "void bad() { char * data; data = NULL; switch(6) { case 6: data = new char[50]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_15.cpp", "text": "static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; switch(6) { case 6: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_62a.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: ncat * BadSink : Copy string to data using strncat * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_84_goodG2B.cpp", "text": "data = new char[100]; data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_84_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_63b.cpp", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_44.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_44.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; void bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; data = NULL; data = new wchar_t[10]; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_67b.cpp", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(structType myStruct) { char * data = myStruct.structFirst; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_07.cpp", "text": "#include <wchar.h> data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_07.cpp", "text": "strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_02.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void bad() { char * data; data = NULL; if(1) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_02.cpp", "text": "memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(1) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_62a.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(wchar_t * &data); void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_62a.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(wchar_t * &data); void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSource(wchar_t * &data); static void goodG2B() { wchar_t * data; data = NULL; goodG2BSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_05.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(staticTrue) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_05.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(staticTrue) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_05.cpp", "text": "data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(staticTrue) { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = new wchar_t[10]; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_33.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = new wchar_t[10]; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = new wchar_t[10+1]; { wchar_t * data = dataRef; { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_83_bad.cpp", "text": "data = new char[50]; data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_83_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_83_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_15.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: ncat * BadSink : Copy string to data using strncat void bad() { char * data; data = NULL; switch(6) { case 6: data = new char[50]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_15.cpp", "text": "strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; switch(6) { case 6: data = new char[100]; data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_84_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_84 { CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_84_goodG2B::CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_84_goodG2B(wchar_t * dataCopy) { data = dataCopy; data = new wchar_t[10+1]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_84_goodG2B() { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_02.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(1) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_02.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { wchar_t * data; data = NULL; if(1) { data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_02.cpp", "text": "data = new wchar_t[10]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; else { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(1) { data = new wchar_t[10+1]; } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_05.cpp", "text": "void bad() { char * data; data = NULL; if(staticTrue) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_05.cpp", "text": "void bad() { char * data; data = NULL; if(staticTrue) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_05.cpp", "text": "strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticTrue) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_83_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_83 { CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_83_goodG2B::CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_83_goodG2B(wchar_t * dataCopy) { data = dataCopy; data = new wchar_t[10+1]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_83_goodG2B() { { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_08.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[50]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s02/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_08.cpp", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; } else { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = new char[100]; data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53d.cpp", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_d(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_83_bad.cpp", "text": "data = new int64_t[50]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_83_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_83_bad() { { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_51b.cpp", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_51b.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy TwoIntsClass array to data using memcpy * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void badSink(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; #ifndef OMITGOOD void goodG2BSink(TwoIntsClass * data) { { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_84_bad.cpp", "text": "data = new int[50]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_84_bad() { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_16.cpp", "text": "while(1) { data = new TwoIntsClass[50]; break; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B() { TwoIntsClass * data; data = NULL; while(1) { data = new TwoIntsClass[100]; break; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_18.cpp", "text": "data = new TwoIntsClass[50]; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_18.cpp", "text": "void bad() { TwoIntsClass * data; data = NULL; goto source; source: data = new TwoIntsClass[50]; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B() { TwoIntsClass * data; data = NULL; goto source; source: data = new TwoIntsClass[100]; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_21.cpp", "text": "static int badStatic = 0; static TwoIntsClass * badSource(TwoIntsClass * data) { if(badStatic) { data = new TwoIntsClass[50]; } return data; void bad() { TwoIntsClass * data; data = NULL; badStatic = 1; data = badSource(data); { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_21.cpp", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; #ifndef OMITGOOD static int goodG2B2Static = 0; static TwoIntsClass * goodG2B1Source(TwoIntsClass * data) } else { data = new TwoIntsClass[100]; } return data; static void goodG2B1() { TwoIntsClass * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_21.cpp", "text": "for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; ; } static TwoIntsClass * goodG2B2Source(TwoIntsClass * data) { if(goodG2B2Static) { data = new TwoIntsClass[100]; } return data; static void goodG2B2() { TwoIntsClass * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_41.cpp", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; void bad() { int * data; data = NULL; data = new int[50]; badSink(data); #ifndef OMITGOOD void goodG2BSink(int * data) { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_74b.cpp", "text": "int * data = dataMap[2]; { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; void goodG2BSink(map<int, int *> dataMap) { int * data = dataMap[2]; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_13.cpp", "text": "data = new int[50]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_13.cpp", "text": "if(GLOBAL_CONST_FIVE==5) { data = new int[50]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21.cpp", "text": "static int badStatic = 0; static int64_t * badSource(int64_t * data) { if(badStatic) { data = new int64_t[50]; } return data; void bad() { int64_t * data; data = NULL; badStatic = 1; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21.cpp", "text": "data = new int64_t[50]; } return data; void bad() { int64_t * data; data = NULL; badStatic = 1; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD static int goodG2B2Static = 0; static int64_t * goodG2B1Source(int64_t * data) } else { data = new int64_t[100]; } return data; static void goodG2B1() { int64_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21.cpp", "text": "else { data = new int64_t[100]; } return data; static void goodG2B1() { int64_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; ; } static int64_t * goodG2B2Source(int64_t * data) { if(goodG2B2Static) { data = new int64_t[100]; } return data; static void goodG2B2() { int64_t * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_34.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_34.cpp", "text": "typedef union { wchar_t * unionFirst; wchar_t * unionSecond; void bad() { wchar_t * data; unionType myUnion; data = NULL; data = new wchar_t[50]; data[0] = L'\\0'; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; unionType myUnion; data = NULL; data = new wchar_t[100]; data[0] = L'\\0'; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21.cpp", "text": "static int badStatic = 0; static wchar_t * badSource(wchar_t * data) { if(badStatic) { data = new wchar_t[50]; data[0] = L'\\0'; } return data; void bad() { wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21.cpp", "text": "wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD static int goodG2B2Static = 0; static wchar_t * goodG2B1Source(wchar_t * data) } else { data = new wchar_t[100]; data[0] = L'\\0'; } return data; static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21.cpp", "text": "static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; ; } static wchar_t * goodG2B2Source(wchar_t * data) { if(goodG2B2Static) { data = new wchar_t[100]; data[0] = L'\\0'; } return data; static void goodG2B2() { wchar_t * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_06.cpp", "text": "if(STATIC_CONST_FIVE==5) { data = new int[50]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_10.cpp", "text": "if(globalTrue) { data = new int[50]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(globalTrue) { data = new int[100]; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_83_goodG2B.cpp", "text": "data = new wchar_t[100]; data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_83_goodG2B() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_61a.cpp", "text": "int64_t * badSource(int64_t * data); void bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_61a.cpp", "text": "int64_t * badSource(int64_t * data); void bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD int64_t * goodG2BSource(int64_t * data); static void goodG2B() { int64_t * data; data = NULL; data = goodG2BSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_16.cpp", "text": "data = new int[50]; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B() { int * data; data = NULL; while(1) { data = new int[100]; break; } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_83_bad.cpp", "text": "data = new int64_t[50]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_83_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_83_bad() { { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_67b.cpp", "text": "memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; void goodG2BSink(structType myStruct) { int64_t * data = myStruct.structFirst; { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_18.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_18.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { wchar_t * data; data = NULL; goto source; source: data = new wchar_t[50]; data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; data = NULL; goto source; source: data = new wchar_t[100]; data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_09.cpp", "text": "if(GLOBAL_CONST_TRUE) { data = new int[50]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_32.cpp", "text": "data = new int[50]; *dataPtr1 = data; } { int * data = *dataPtr2; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_32.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int array to data using memcpy void bad() { int * data; int * *dataPtr1 = &data; int * *dataPtr2 = &data; data = NULL; { int * data = *dataPtr1; data = new int[50]; *dataPtr1 = data; } { int * data = *dataPtr2; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B() { int * data; int * *dataPtr1 = &data; int * *dataPtr2 = &data; data = NULL; { int * data = *dataPtr1; data = new int[100]; *dataPtr1 = data; } { int * data = *dataPtr2; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_14.cpp", "text": "if(globalFive==5) { data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B2() { int64_t * data; data = NULL; if(globalFive==5) { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_42.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; return data; void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_42.cpp", "text": "{ data = new wchar_t[50]; data[0] = L'\\0'; return data; void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; #ifndef OMITGOOD static wchar_t * goodG2BSource(wchar_t * data) { data = new wchar_t[100]; data[0] = L'\\0'; return data; static void goodG2B() { wchar_t * data; data = NULL; data = goodG2BSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_16.cpp", "text": "data = new int64_t[50]; break; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B() { int64_t * data; data = NULL; while(1) { data = new int64_t[100]; break; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_18.cpp", "text": "data = new int[50]; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B() { int * data; data = NULL; goto source; source: data = new int[100]; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_12.cpp", "text": "data = new int64_t[50]; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_12.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memmove * BadSink : Copy int64_t array to data using memmove void bad() { int64_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new int64_t[50]; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; both branches use the GoodSource */ static void goodG2B() { int64_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new int64_t[100]; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_84_goodG2B.cpp", "text": "data = new wchar_t[100]; data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_84_goodG2B() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_12.cpp", "text": "data = new int64_t[50]; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_12.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int64_t array to data using memcpy void bad() { int64_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new int64_t[50]; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; both branches use the GoodSource */ static void goodG2B() { int64_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = new int64_t[100]; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_45.cpp", "text": "{ static TwoIntsClass * badData; static TwoIntsClass * goodG2BData; static void badSink() { TwoIntsClass * data = badData; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; void bad() { TwoIntsClass * data; data = NULL; data = new TwoIntsClass[50]; badData = data; static void goodG2BSink() { TwoIntsClass * data = goodG2BData; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_11.cpp", "text": "if(globalReturnsTrue()) { data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B2() { int64_t * data; data = NULL; if(globalReturnsTrue()) { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_05.cpp", "text": "void bad() { int64_t * data; data = NULL; if(staticTrue) { data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_05.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int64_t array to data using memcpy void bad() { int64_t * data; data = NULL; if(staticTrue) { data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_05.cpp", "text": "if(staticTrue) { data = new int64_t[50]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B2() { int64_t * data; data = NULL; if(staticTrue) { data = new int64_t[100]; } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_11.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void bad() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = new wchar_t[50]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; } else { data = new wchar_t[100]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_11.cpp", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = NULL; } else { data = new wchar_t[100]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = new wchar_t[100]; data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_74b.cpp", "text": "int64_t * data = dataMap[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD void goodG2BSink(map<int, int64_t *> dataMap) { int64_t * data = dataMap[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_04.cpp", "text": "if(STATIC_CONST_TRUE) { data = new int64_t[50]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B1() { int64_t * data; data = NULL; } else { data = new int64_t[100]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; static void goodG2B2() { int64_t * data; data = NULL; if(STATIC_CONST_TRUE) { data = new int64_t[100]; } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_14.cpp", "text": "if(globalFive==5) { data = new int[50]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B1() { int * data; data = NULL; } else { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; static void goodG2B2() { int * data; data = NULL; if(globalFive==5) { data = new int[100]; } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_09.cpp", "text": "data = NULL; if(GLOBAL_CONST_TRUE) { data = new TwoIntsClass[50]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_09.cpp", "text": "static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B2() { TwoIntsClass * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45.cpp", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; void bad() { int * data; data = NULL; data = new int[50]; badData = data; static void goodG2BSink() { int * data = goodG2BData; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_07.cpp", "text": "data = NULL; if(staticFive==5) { data = new TwoIntsClass[50]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_07.cpp", "text": "static void goodG2B1() { TwoIntsClass * data; data = NULL; } else { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B2() { TwoIntsClass * data; data = NULL; if(staticFive==5) { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54e.cpp", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; #ifndef OMITGOOD void goodG2BSink_e(int * data) { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_32.cpp", "text": "data = new wchar_t[50]; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_32.cpp", "text": "data = NULL; { wchar_t * data = *dataPtr1; data = new wchar_t[50]; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * *dataPtr1 = &data; wchar_t * *dataPtr2 = &data; data = NULL; { wchar_t * data = *dataPtr1; data = new wchar_t[100]; data[0] = L'\\0'; *dataPtr1 = data; } { wchar_t * data = *dataPtr2; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_74b.cpp", "text": "int * data = dataMap[2]; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; void goodG2BSink(map<int, int *> dataMap) { int * data = dataMap[2]; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_43.cpp", "text": "data = new int[50]; void bad() { int * data; data = NULL; badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_43.cpp", "text": "* BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy int array to data using memcpy * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #ifndef OMITBAD void badSource(int * &data) { data = new int[50]; void bad() { int * data; data = NULL; badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; #ifndef OMITGOOD static void goodG2BSource(int * &data) { data = new int[100]; static void goodG2B() { int * data; data = NULL; goodG2BSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_72b.cpp", "text": "int64_t * data = dataVector[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); delete [] data; #ifndef OMITGOOD void goodG2BSink(vector<int64_t *> dataVector) { int64_t * data = dataVector[2]; { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_42.cpp", "text": "data = new int[50]; return data; void bad() { int * data; data = NULL; data = badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_42.cpp", "text": "* GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int array to data using memcpy * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static int * badSource(int * data) { data = new int[50]; return data; void bad() { int * data; data = NULL; data = badSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; #ifndef OMITGOOD static int * goodG2BSource(int * data) { data = new int[100]; return data; static void goodG2B() { int * data; data = NULL; data = goodG2BSource(data); { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_32.cpp", "text": "data = new TwoIntsClass[50]; *dataPtr1 = data; } { TwoIntsClass * data = *dataPtr2; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_32.cpp", "text": "{ TwoIntsClass * data = *dataPtr2; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B() { TwoIntsClass * data; TwoIntsClass * *dataPtr1 = &data; TwoIntsClass * *dataPtr2 = &data; data = NULL; { TwoIntsClass * data = *dataPtr1; data = new TwoIntsClass[100]; *dataPtr1 = data; } { TwoIntsClass * data = *dataPtr2; { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(TwoIntsClass));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_16.cpp", "text": "while(1) { data = new TwoIntsClass[50]; break; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B() { TwoIntsClass * data; data = NULL; while(1) { data = new TwoIntsClass[100]; break; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_41.cpp", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); delete [] data; void bad() { int * data; data = NULL; data = new int[50]; badSink(data); #ifndef OMITGOOD void goodG2BSink(int * data) { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_17.cpp", "text": "{ int i; TwoIntsClass * data; data = NULL; for(i = 0; i < 1; i++) { data = new TwoIntsClass[50]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass)); printIntLine(data[0].intOne); delete [] data; static void goodG2B() { int h; TwoIntsClass * data; data = NULL; for(h = 0; h < 1; h++) { data = new TwoIntsClass[100]; } { TwoIntsClass source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(TwoIntsClass));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s03/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_18.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using new[] and set data pointer to a small buffer * GoodSource: Allocate using new[] and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void bad() { wchar_t * data; data = NULL; goto source; source: data = new wchar_t[50]; data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; data = NULL; goto source; source: data = new wchar_t[100]; data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_45.cpp", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void bad() { char * data; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; badData = data; static void goodG2BSink() { char * data = goodG2BData; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_63b.cpp", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_04.cpp", "text": "{ char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(STATIC_CONST_TRUE) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_42.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_42.cpp", "text": "#ifndef OMITBAD static char * badSource(char * data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD static char * goodG2BSource(char * data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; return data; static void goodG2B() { char * data; data = new char[100]; data = goodG2BSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_61a.cpp", "text": "char * badSource(char * data); void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_61a.cpp", "text": "char * badSource(char * data); void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD char * goodG2BSource(char * data); static void goodG2B() { char * data; data = new char[100]; data = goodG2BSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_11.cpp", "text": "{ char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(globalReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_84_goodG2B.cpp", "text": "wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_84_goodG2B() { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_16.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncpy * BadSink : Copy data to string using strncpy void bad() { char * data; data = new char[100]; while(1) { memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; while(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_31.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_33.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; char * &dataRef = data; data = new char[100]; memset(data, 'A', 50-1); data[50-1] = '\\0'; { char * data = dataRef; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_84_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_84_goodG2B() { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_51b.cpp", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(char * data) { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_32.cpp", "text": "{ char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = new char[100]; { char * data = *dataPtr1; memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = new char[100]; { char * data = *dataPtr1; memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_64b.cpp", "text": "char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_72b.cpp", "text": "char * data = dataVector[2]; { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_66b.cpp", "text": "char * data = dataArray[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_34.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = new char[100]; memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_73b.cpp", "text": "char * data = dataList.back(); { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_42.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_42.cpp", "text": "#ifndef OMITBAD static char * badSource(char * data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void bad() { char * data; data = new char[100]; data = badSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; #ifndef OMITGOOD static char * goodG2BSource(char * data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; return data; static void goodG2B() { char * data; data = new char[100]; data = goodG2BSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_08.cpp", "text": "{ char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(staticReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_68b.cpp", "text": "memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_68_goodG2BData; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_84_goodG2B.cpp", "text": "wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_84_goodG2B() { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_67b.cpp", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void goodG2BSink(structType myStruct) { char * data = myStruct.structFirst; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_14.cpp", "text": "{ char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(globalFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_09.cpp", "text": "{ char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B1() { char * data; data = new char[100]; } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B2() { char * data; data = new char[100]; if(GLOBAL_CONST_TRUE) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22a.cpp", "text": "int badGlobal = 0; wchar_t * badSource(wchar_t * data); void bad() { wchar_t * data; data = new wchar_t[100]; badGlobal = 1; data = badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22a.cpp", "text": "int badGlobal = 0; wchar_t * badSource(wchar_t * data); void bad() { wchar_t * data; data = new wchar_t[100]; badGlobal = 1; data = badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; int goodG2B2Global = 0; wchar_t * goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = new wchar_t[100]; goodG2B1Global = 0; data = goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22a.cpp", "text": "data = badSource(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; int goodG2B2Global = 0; wchar_t * goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = new wchar_t[100]; goodG2B1Global = 0; data = goodG2B1Source(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; } wchar_t * goodG2B2Source(wchar_t * data); static void goodG2B2() { wchar_t * data; data = new wchar_t[100]; goodG2B2Global = 1; data = goodG2B2Source(data); { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_33.cpp", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t * data = dataRef; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; data = new wchar_t[100]; wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t * data = dataRef; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_32.cpp", "text": "{ char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = new char[100]; { char * data = *dataPtr1; memset(data, 'A', 100-1); data[100-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = new char[100]; { char * data = *dataPtr1; memset(data, 'A', 50-1); data[50-1] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_45.cpp", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; void bad() { char * data; data = new char[100]; memset(data, 'A', 100-1); data[100-1] = '\\0'; badData = data; static void goodG2BSink() { char * data = goodG2BData; { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_08.cpp", "text": "{ wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B1() { wchar_t * data; data = new wchar_t[100]; } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); delete [] data; static void goodG2B2() { wchar_t * data; data = new wchar_t[100]; if(staticReturnsTrue()) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s04/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_18.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); delete [] data; static void goodG2B() { char * data; data = new char[100]; goto source; source: memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_68b.c", "text": "strcat(dest, data); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_68b_goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_68_goodG2BData; { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_02.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: cat * BadSink : Copy string to data using strcat void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_02_bad() { char * data; data = NULL; if(1) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_02.c", "text": "strcat(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_06.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_06_bad() { char * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_06.c", "text": "#include <wchar.h> void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_06_bad() { char * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_06.c", "text": "strcat(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_16.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: cat * BadSink : Copy string to data using strcat void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_16_bad() { char * data; data = NULL; while(1) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); static void goodG2B() { char * data; data = NULL; while(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_66b.c", "text": "char * data = dataArray[2]; { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_68b.c", "text": "source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_68b_goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_44.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sinks: memmove * BadSink : Copy data to string using memmove * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_43.cpp", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_43.cpp", "text": "static void badSource(char * &data) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source); printLine(data); free(data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_04.c", "text": "memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(STATIC_CONST_TRUE) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_83_bad.cpp", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_83_bad::~CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cat_83_bad() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcat(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_01.c", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_52c.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_52c_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_02.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_02_bad() { char * data; data = NULL; if(1) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_02.c", "text": "strcpy(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(1) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_13.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cpy * BadSink : Copy data to string using strcpy void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_13_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_FIVE==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cpy_13.c", "text": "{ char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data); printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_FIVE==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_16.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_16_bad() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} while(1) { wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} while(1) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; break; } { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_08.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: cat * BadSink : Copy data to string using strcat void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_08_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(staticReturnsTrue()) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_08.c", "text": "{ char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(staticReturnsTrue()) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_72b.cpp", "text": "char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_83_bad.cpp", "text": "wmemset(data, L'A', 100-1); data[100-1] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_83_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_83_bad() { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61a.c", "text": "char * CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61b_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data = CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61b_badSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61a.c", "text": "char * CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61b_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data = CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61b_badSource(data); { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); #ifndef OMITGOOD char * CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61b_goodG2BSource(char * data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data = CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_61b_goodG2BSource(data); { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_84_goodG2B.cpp", "text": "wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_84_goodG2B() { { wchar_t dest[50] = L\"\"; memmove(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_src_char_cat_18.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strcat(dest, data); printLine(data); free(data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goto source; source: memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strcat(dest, data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s10/CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_45.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_45_bad() { char * data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_45_badData = data; static void goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_dest_char_cpy_45_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_13.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_FIVE==5) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_13.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_FIVE==5) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_13.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(GLOBAL_CONST_FIVE==5) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); if(GLOBAL_CONST_FIVE==5) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_04.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; } charVoid; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); if(STATIC_CONST_TRUE) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_02.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(1) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_02.c", "text": "#include <wchar.h> #endif #define SRC_STR L\"0123456789abcdef0123456789abcde\" typedef struct _charVoid { wchar_t charFirst[16]; if(1) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); free(structCharVoid); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s11/CWE122_Heap_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_02.c", "text": "typedef struct _charVoid { wchar_t charFirst[16]; if(1) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); free(structCharVoid); else { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\\0'; printWLine((wchar_t *)structCharVoid->charFirst); printWLine((wchar_t *)structCharVoid->voidSecond); free(structCharVoid); if(1) { { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printWLine((wchar_t *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_31.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; data = NULL; data = new char[10]; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_31.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; data = NULL; data = new char[10]; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B() { char * data; data = NULL; data = new char[10+1]; { char * dataCopy = data; char * data = dataCopy; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_67b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void badSink(structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_67b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void badSink(structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void goodG2BSink(structType myStruct) { char * data = myStruct.structFirst; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_32.cpp", "text": "break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; data = atoi(inputBuffer); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_73b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_73b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files void badSink(list<char *> dataList) { char * data = dataList.back(); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_52c.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void badSink_c(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_52c.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void badSink_c(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink_c(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_34.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[10]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_34.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void bad() { char * data; unionType myUnion; data = NULL; data = new char[10]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B() { char * data; unionType myUnion; data = NULL; data = new char[10+1]; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_64b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_64b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() #ifndef OMITBAD static int badStatic = 0; static char * badSource(char * data) if(badStatic) { data = new char[10]; } return data; void bad() { char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21.cpp", "text": "data = new char[10]; } return data; void bad() { char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; #ifndef OMITGOOD static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) else { data = new char[10+1]; } return data; static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21.cpp", "text": "data = new char[10+1]; } return data; static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; ; } static char * goodG2B2Source(char * data) if(goodG2B2Static) { data = new char[10+1]; } return data; static void goodG2B2() { char * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_74b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_74b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void goodG2BSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_51b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_51b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_41.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_41.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void badSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void bad() { char * data; data = NULL; data = new char[10]; badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_16.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_16.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_16.cpp", "text": "data = -1; while(1) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G() { int data; data = -1; while(1) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_63b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_63b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; void goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_81_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_81_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_65b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_65b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_13.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_13.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_13.cpp", "text": "data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_13.cpp", "text": "void bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_84_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_84_bad::CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_84_bad(char * dataCopy) { data = dataCopy; data = new char[10]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_84_bad() { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_09.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void bad() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new char[10]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_09.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void bad() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new char[10]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_09.cpp", "text": "data = new char[10]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(GLOBAL_CONST_TRUE) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_04.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() #define SRC_STRING \"AAAAAAAAAA\" data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_04.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() #define SRC_STRING \"AAAAAAAAAA\" data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_04.cpp", "text": "data = new char[10]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_TRUE) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_07.cpp", "text": "data = new char[10]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54a.cpp", "text": "#include \"std_testcase.h\" namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54 #ifndef OMITBAD void badSink_b(int data); void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(int data); static void goodG2B() { int data; data = -1; data = 7; goodG2BSink_b(data); } void goodB2GSink_b(int data); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_84_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_84_bad::CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_84_bad(char * dataCopy) { data = dataCopy; data = new char[10]; CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_84_bad::~CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_84_bad() { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_18.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; goto sink; sink: { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_18.c", "text": "#include <wchar.h> #endif #define SRC_STR \"0123456789abcdef0123456789abcde\" typedef struct _charVoid { char charFirst[16]; goto sink; sink: { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid)); structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; printLine((char *)structCharVoid->charFirst); printLine((char *)structCharVoid->voidSecond); free(structCharVoid); goto sink; sink: { charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid)); if (structCharVoid == NULL) {exit(-1);} structCharVoid->voidSecond = (void *)SRC_STR; printLine((char *)structCharVoid->voidSecond); memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_15.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void bad() { char * data; data = NULL; { case 6: data = new char[10]; break; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_15.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void bad() { char * data; data = NULL; { case 6: data = new char[10]; break; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; break; default: data = new char[10+1]; break; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_15.cpp", "text": "{ case 6: data = new char[10]; break; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; break; default: data = new char[10+1]; break; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; { case 6: data = new char[10+1]; break; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_62a.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_62a.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_51b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_51b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void badSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; #ifndef OMITGOOD void goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a.cpp", "text": "int badGlobal = 0; void badSink(int data); void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a.cpp", "text": "int badGlobal = 0; void badSink(int data); void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); badGlobal = 1; badSink(data); int goodG2B1Global = 0; void goodB2G1Sink(int data); static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a.cpp", "text": "#include \"std_testcase.h\" namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22 a C++ namespace, it doesn't need a globally unique name. */ int badGlobal = 0; void badSink(int data); void bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); badGlobal = 1; badSink(data); int goodG2B1Global = 0; void goodB2G1Sink(int data); static void goodB2G1() { int data; data = -1; fscanf(stdin, \"%d\", &data); goodB2G1Global = 0; goodB2G1Sink(data); } void goodB2G2Sink(int data); static void goodB2G2() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_17.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_17.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() void bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = new char[10]; } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); delete [] data; static void goodG2B() { int h; char * data; data = NULL; for(h = 0; h < 1; h++) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_14.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; if(globalFive==5) { data = new char[10]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_14.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void bad() { char * data; data = NULL; if(globalFive==5) { data = new char[10]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s01/CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_14.cpp", "text": "data = new char[10]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B1() { char * data; data = NULL; else { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); delete [] data; static void goodG2B2() { char * data; data = NULL; if(globalFive==5) { data = new char[10+1]; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_74b.cpp", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void badSink(map<int, void *> dataMap) { void * data = dataMap[2]; { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy((wchar_t *)dest, (wchar_t *)data); printLine((char *)dest); free(dest); void goodG2BSink(map<int, void *> dataMap) { void * data = dataMap[2]; { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy((char *)dest, (char *)data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_61a.c", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD void * CWE122_Heap_Based_Buffer_Overflow__CWE135_61b_badSource(void * data); void CWE122_Heap_Based_Buffer_Overflow__CWE135_61_bad() { void * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__CWE135_61b_badSource(data); { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printLine((char *)dest); free(dest); #ifndef OMITGOOD void * CWE122_Heap_Based_Buffer_Overflow__CWE135_61b_goodG2BSource(void * data); static void goodG2B() { void * data; data = NULL; data = CWE122_Heap_Based_Buffer_Overflow__CWE135_61b_goodG2BSource(data); { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_13.c", "text": "void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printWLine((wchar_t *)dest); free(dest); static void goodB2G2() { void * data; data = NULL; if (dataBadBuffer == NULL) {exit(-1);} wmemset(dataBadBuffer, L'A', 50-1); dataBadBuffer[50-1] = L'\\0'; data = (void *)dataBadBuffer; { { size_t dataLen = wcslen((wchar_t *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printWLine((wchar_t *)dest); free(dest); static void goodG2B1() { void * data; data = NULL; if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; { { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_13.c", "text": "void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy(dest, data); printWLine((wchar_t *)dest); free(dest); static void goodG2B1() { void * data; data = NULL; if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; { { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data); printLine((char *)dest); free(dest); static void goodG2B2() { void * data; data = NULL; if (dataGoodBuffer == NULL) {exit(-1);} memset(dataGoodBuffer, 'A', 50-1); dataGoodBuffer[50-1] = '\\0'; data = (void *)dataGoodBuffer; { { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy(dest, data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22a.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() #ifndef OMITBAD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badGlobal = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_bad() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badSource(data); { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22a.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: cpy * BadSink : Copy string to data using strcpy() #ifndef OMITBAD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badGlobal = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_bad() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_badSource(data); { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); #ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B2Global = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B1Source(data); { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22a.c", "text": "strcpy(data, source); printLine(data); free(data); #ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B2Global = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B1Source(data); { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); } } char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B2Global = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_22_goodG2B2Source(data); { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_18.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_18_bad() { int * data; data = NULL; goto source; source: data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_18.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_18_bad() { int * data; data = NULL; goto source; source: data = (int *)malloc(10); if (data == NULL) {exit(-1);} { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B() { int * data; data = NULL; goto source; source: data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_42.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static char * badSource(char * data) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_42_bad() { char * data; data = NULL; data = badSource(data); { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_42.c", "text": "#ifndef OMITBAD static char * badSource(char * data) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_42_bad() { char * data; data = NULL; data = badSource(data); { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE135_72b.cpp", "text": "* BadSource: Void pointer to a wchar_t array * GoodSource: Void pointer to a char array * Sinks: * GoodSink: Allocate memory using wcslen() and copy data * BadSink : Allocate memory using strlen() and copy data * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<void *> dataVector) { void * data = dataVector[2]; { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t)); if (dest == NULL) {exit(-1);} (void)wcscpy((wchar_t *)dest, (wchar_t *)data); printLine((char *)dest); free(dest); void goodG2BSink(vector<void *> dataVector) { void * data = dataVector[2]; { size_t dataLen = strlen((char *)data); void * dest = (void *)calloc(dataLen+1, 1); if (dest == NULL) {exit(-1);} (void)strcpy((char *)dest, (char *)data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_bad::CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_bad(char * dataCopy) { data = dataCopy; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_bad() { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68b_badSink() { int * data = CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68_badData; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68b_badSink() { int * data = CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68_badData; { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68b_goodG2BSink() { int * data = CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_68_goodG2BData; { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_10.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_10_bad() { int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodB2G1() { int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data); buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; static void goodB2G2() { int data; data = -1; if(globalTrue) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_15.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_15_bad() { int * data; data = NULL; { case 6: data = (int *)malloc(10); if (data == NULL) {exit(-1);} break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_15.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_15_bad() { int * data; data = NULL; { case 6: data = (int *)malloc(10); if (data == NULL) {exit(-1);} break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; break; default: data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_15.c", "text": "} { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; break; default: data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; { case 6: data = (int *)malloc(10*sizeof(int)); if (data == NULL) {exit(-1);} break; } { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_72b.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); void goodG2BSink(vector<char *> dataVector) { char * data = dataVector[2]; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_07.c", "text": "{ data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(staticFive==5) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_64b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_82_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_82 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_82_bad::action(char * data) { { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_72b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_72b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); static void goodG2B() { int data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34_unionType myUnion; static void goodB2G() { int data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34_unionType myUnion;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; } if (data >= 0) { buffer[data] = 1; static void goodG2B() { int data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34_unionType myUnion; data = -1; data = 7; myUnion.unionFirst = data; { int data = myUnion.unionSecond; } if (data >= 0) { buffer[data] = 1; static void goodB2G() { int data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_34_unionType myUnion; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_01.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); } if (data >= 0) { buffer[data] = 1; static void goodG2B() { int data; data = -1; data = 7; } if (data >= 0) { buffer[data] = 1; static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_53d.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_53d_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_53d.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_53d_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_53d_goodG2BSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_17.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_17_bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_17.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memcpy_17_bad() { int i; char * data; data = NULL; for(i = 0; i < 1; i++) { data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B() { int h; char * data; data = NULL; for(h = 0; h < 1; h++) { data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} } { char source[10+1] = SRC_STRING; memcpy(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_goodG2B::CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_goodG2B(char * dataCopy) { data = dataCopy; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_84_goodG2B() { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_73a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_73a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_73a.cpp", "text": "* Sinks: * GoodSink: Ensure the array index is valid * BadSink : Improperly check the array index by not checking the upper bound * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files using namespace std; namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_73 void bad() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data); dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { int data; list<int> dataList; data = -1; data = 7; dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodB2G() { int data; list<int> dataList; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_52c.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_52c_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_52c.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sink: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_52c_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_52c_goodG2BSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_83_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_83_bad::CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_83_bad(char * dataCopy) { data = dataCopy; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_83_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_83_bad() { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_12.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fscanf_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); { data = 7; } if (data >= 0) { buffer[data] = 1; buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; use the GoodSink */ static void goodB2G() { int data; data = -1; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); } else { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_65b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_65b_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_65b.c", "text": "* BadSource: Allocate memory without using sizeof(int) * GoodSource: Allocate memory using sizeof(int) * Sinks: memmove * BadSink : Copy array to data using memmove() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_65b_badSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_65b_goodG2BSink(int * data) { { int source[10] = {0}; memmove(data, source, 10*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45_badData; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45_badData; { char source[10+1] = SRC_STRING; strcpy(data, source); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45_badData = data; static void goodG2BSink() { char * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_45_goodG2BData; { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_82_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_82 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_82_bad::action(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s06/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_82_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: cpy * BadSink : Copy string to data using strcpy() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_82 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_82_goodG2B::action(char * data) { { char source[10+1] = SRC_STRING; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_45.c", "text": "memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_45_bad() { int * data; data = NULL; data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_45_badData = data; static void goodG2BSink() { int * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_45_goodG2BData; { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_83_goodG2B.cpp", "text": "data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_83_goodG2B() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_41.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_41_bad() { int * data; data = NULL; data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_41_badSink(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_41_goodG2BSink(int * data) { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_01.c", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_01.c", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B() { wchar_t * data; data = NULL; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_41.c", "text": "memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_41_bad() { int64_t * data; data = NULL; data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_41_badSink(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_41_goodG2BSink(int64_t * data) { { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_06.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_06.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy int array to data using memcpy #include \"std_testcase.h\" void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_06.c", "text": "if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_33.cpp", "text": "data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_33.cpp", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; data = NULL; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_53d.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy twoIntsStruct array to data using memmove * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_53d_badSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_53d_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_12.c", "text": "data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} } else { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_12.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_12_bad() { int64_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} } else { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); * both branches use the GoodSource */ static void goodG2B() { int64_t * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } else { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_74b.cpp", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memmove * BadSink : Copy twoIntsStruct array to data using memmove * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files #ifndef OMITBAD void badSink(map<int, twoIntsStruct *> dataMap) { twoIntsStruct * data = dataMap[2]; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD void goodG2BSink(map<int, twoIntsStruct *> dataMap) { twoIntsStruct * data = dataMap[2]; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_06.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_06.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy int array to data using memmove #include \"std_testcase.h\" void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_06_bad() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(50*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_06.c", "text": "if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(STATIC_CONST_FIVE==5) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_68b.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_68b_goodG2BSink() { int * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_68_goodG2BData; { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_03.c", "text": "if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); static void goodG2B1() { int64_t * data; data = NULL; } else { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); static void goodG2B2() { int64_t * data; data = NULL; if(5==5) { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_42.c", "text": "data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_42_bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_42.c", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy int64_t array to data using memmove * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static int64_t * badSource(int64_t * data) { data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_42_bad() { int64_t * data; data = NULL; data = badSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); #ifndef OMITGOOD static int64_t * goodG2BSource(int64_t * data) { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} return data; static void goodG2B() { int64_t * data; data = NULL; data = goodG2BSource(data); { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_18.c", "text": "data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_18.c", "text": "data = (int64_t *)malloc(50*sizeof(int64_t)); if (data == NULL) {exit(-1);} { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); static void goodG2B() { int64_t * data; data = NULL; goto source; source: data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_52c.c", "text": "memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_52c_goodG2BSink(int64_t * data) { { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_01.c", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_01.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy twoIntsStruct array to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_01_bad() { twoIntsStruct * data; data = NULL; data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); static void goodG2B() { twoIntsStruct * data; data = NULL; data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_51b.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_51b_badSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_51b_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_68b.c", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy twoIntsStruct array to data using memmove * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" extern twoIntsStruct * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_68_badData; extern twoIntsStruct * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_68_goodG2BData; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_68b_badSink() { twoIntsStruct * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_68_badData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_68b_goodG2BSink() { twoIntsStruct * data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memmove_68_goodG2BData; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memmove(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_54e.c", "text": "memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_54e_goodG2BSink(int * data) { { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_51b.c", "text": "memmove(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_51b_goodG2BSink(int64_t * data) { { int64_t source[100] = {0}; memmove(data, source, 100*sizeof(int64_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memcpy_08.c", "text": "if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); static void goodG2B1() { int64_t * data; data = NULL; } else { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t)); printLongLongLine(data[0]); free(data); static void goodG2B2() { int64_t * data; data = NULL; if(staticReturnsTrue()) { data = (int64_t *)malloc(100*sizeof(int64_t)); if (data == NULL) {exit(-1);} } { int64_t source[100] = {0}; memcpy(data, source, 100*sizeof(int64_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_03.c", "text": "else { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); static void goodG2B2() { twoIntsStruct * data; data = NULL; if(5==5) { data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} } { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_10.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_10_bad() { wchar_t * data; data = NULL; if(globalTrue) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_10.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(globalTrue) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memmove_14.c", "text": "if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B1() { int * data; data = NULL; } else { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int)); printIntLine(data[0]); free(data); static void goodG2B2() { int * data; data = NULL; if(globalFive==5) { data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} } { int source[100] = {0}; memmove(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_53d.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy twoIntsStruct array to data using memcpy * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_53d_badSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_53d_goodG2BSink(twoIntsStruct * data) { { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_32.c", "text": "data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} *dataPtr1 = data; } { twoIntsStruct * data = *dataPtr2; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_32.c", "text": "{ twoIntsStruct * data = *dataPtr2; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct)); printStructLine(&data[0]); free(data); static void goodG2B() { twoIntsStruct * data; twoIntsStruct * *dataPtr1 = &data; twoIntsStruct * *dataPtr2 = &data; data = NULL; { twoIntsStruct * data = *dataPtr1; data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct)); if (data == NULL) {exit(-1);} *dataPtr1 = data; } { twoIntsStruct * data = *dataPtr2; { twoIntsStruct source[100]; for (i = 0; i < 100; i++) { source[i].intOne = 0; source[i].intTwo = 0; } } memcpy(data, source, 100*sizeof(twoIntsStruct));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_83_goodG2B.cpp", "text": "data = (int *)malloc(100*sizeof(int)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_memcpy_83_goodG2B() { { int source[100] = {0}; memcpy(data, source, 100*sizeof(int));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_21.c", "text": "static int badStatic = 0; static wchar_t * badSource(wchar_t * data) { if(badStatic) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_21_bad() { wchar_t * data; data = NULL; badStatic = 1; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_21.c", "text": "badStatic = 1; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD static int goodG2B2Static = 0; static wchar_t * goodG2B1Source(wchar_t * data) } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } return data; static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s08/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memcpy_21.c", "text": "static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); } } static wchar_t * goodG2B2Source(wchar_t * data) { if(goodG2B2Static) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } return data; static void goodG2B2() { wchar_t * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_14.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncpy * BadSink : Copy data to string using strncpy void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_14_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(globalFive==5) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_14.c", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(globalFive==5) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_34.c", "text": "* GoodSource: Initialize data as a small string * Sinks: memcpy * BadSink : Copy data to string using memcpy * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_34_bad() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 100-1); data[100-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_01.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} memset(data, 'A', 50-1); data[50-1] = '\\0'; { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_84_goodG2B.cpp", "text": "data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_84_goodG2B() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_84_goodG2B.cpp", "text": "wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_84_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_84_goodG2B() { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_62a.cpp", "text": "void badSource(char * &data); void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} badSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} goodG2BSource(data); { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_42.c", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_42_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data = badSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_42.c", "text": "static char * badSource(char * data) { memset(data, 'A', 100-1); data[100-1] = '\\0'; return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_42_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data = badSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { memset(data, 'A', 50-1); data[50-1] = '\\0'; return data; static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data = goodG2BSource(data); { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_04.c", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(STATIC_CONST_TRUE) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_67b.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_67b_goodG2BSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_15.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_15_bad() { wchar_t * data; data = NULL; switch(6) { case 6: data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_15.c", "text": "static void goodG2B1() { wchar_t * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; switch(6) { case 6: data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_09.c", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: ncat * BadSink : Copy data to string using strncat void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_09_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_TRUE) { memset(data, 'A', 100-1); data[100-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncat_09.c", "text": "strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} } else { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} if(GLOBAL_CONST_TRUE) { memset(data, 'A', 50-1); data[50-1] = '\\0'; } { char dest[50] = \"\"; strncat(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_83_bad.cpp", "text": "memset(data, 'A', 100-1); data[100-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_83_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_83_bad() { { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_54e.c", "text": "strncpy(dest, data, strlen(data)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_ncpy_54e_goodG2BSink(char * data) { { char dest[50] = \"\"; strncpy(dest, data, strlen(data));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_52c.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_52c_goodG2BSink(wchar_t * data) { { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_16.c", "text": "* BadSource: Initialize data as a large string * GoodSource: Initialize data as a small string * Sink: memmove * BadSink : Copy data to string using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_16_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} while(1) { memset(data, 'A', 100-1); data[100-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} while(1) { memset(data, 'A', 50-1); data[50-1] = '\\0'; break; } { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_03.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_03_bad() { wchar_t * data; data = NULL; if(5==5) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_03.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(5==5) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_52c.c", "text": "memmove(dest, data, strlen(data)*sizeof(char)); dest[50-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memmove_52c_goodG2BSink(char * data) { { char dest[50] = \"\"; memmove(dest, data, strlen(data)*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_13.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_13_bad() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (wchar_t *)malloc(50*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_13.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; } else { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(GLOBAL_CONST_FIVE==5) { data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} data[0] = L'\\0'; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_04.c", "text": "memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } else { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = (wchar_t *)malloc(100*sizeof(wchar_t)); if (data == NULL) {exit(-1);} if(STATIC_CONST_TRUE) { wmemset(data, L'A', 50-1); data[50-1] = L'\\0'; } { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_83_goodG2B.cpp", "text": "memset(data, 'A', 50-1); data[50-1] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE806_char_memcpy_83_goodG2B() { { char dest[50] = \"\"; memcpy(dest, data, strlen(data)*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s09/CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memcpy_74b.cpp", "text": "wchar_t * data = dataMap[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t)); dest[50-1] = L'\\0'; printWLine(data); free(data); #ifndef OMITGOOD void goodG2BSink(map<int, wchar_t *> dataMap) { wchar_t * data = dataMap[2]; { wchar_t dest[50] = L\"\"; memcpy(dest, data, wcslen(data)*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_31.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_31.c", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 31 Data flow using a copy of data within the same function void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_31_bad() { char * data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_51b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_51b_badSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_51b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_51b_badSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_51b_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_33.cpp", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_33.cpp", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: ncpy * BadSink : Copy string to data using strncpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_81_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 81 Data flow: data passed in a parameter to an virtual method called via a reference namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_81 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_81_goodG2B::action(char * data) const { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_82.h", "text": "/* * @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * BadSink : Copy string to data using strncpy()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_67b.c", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_67b_goodG2BSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_67_structType myStruct) { char * data = myStruct.structFirst; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_08.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_08.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: ncat * BadSink : Copy string to data using strncat void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_08_bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_08.c", "text": "strncat(data, source, 100); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_21.c", "text": "static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } return data; void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_21_bad() { char * data; data = NULL; badStatic = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_21.c", "text": "badStatic = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } return data; static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_21.c", "text": "static void goodG2B1() { char * data; data = NULL; goodG2B1Static = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); } } static char * goodG2B2Source(char * data) { if(goodG2B2Static) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } return data; static void goodG2B2() { char * data; data = NULL; goodG2B2Static = 1; data = goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_16.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_16_bad() { wchar_t * data; data = NULL; while(1) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} break; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_16.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_16_bad() { wchar_t * data; data = NULL; while(1) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} break; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B() { wchar_t * data; data = NULL; while(1) { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} break; } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_33.cpp", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_33.cpp", "text": "* GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char * data = dataRef; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_51b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_51b_badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_51b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_51b_badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_51b_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_52c.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_52c_badSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_52c.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_52c_badSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_52c_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54e.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54e_badSink(char * data) { { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54e.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54e_badSink(char * data) { { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_54e_goodG2BSink(char * data) { { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_10.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_10_bad() { char * data; data = NULL; if(globalTrue) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_10.c", "text": "memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(globalTrue) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_83_goodG2B.cpp", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_83_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_11.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_11_bad() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_11.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_11_bad() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_11.c", "text": "{ wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(globalReturnsTrue()) { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_01.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_01_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_01.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_01_bad() { char * data; data = NULL; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_54e.c", "text": "source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_54e_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_32.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_32.c", "text": "char * data = *dataPtr1; data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_83_goodG2B.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_83 { CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_83_goodG2B::CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_83_goodG2B(wchar_t * dataCopy) { data = dataCopy; data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_83_goodG2B() { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_15.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_15_bad() { char * data; data = NULL; { case 6: data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_15.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_15_bad() { char * data; data = NULL; { case 6: data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; break; default: data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_15.c", "text": "memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; break; default: data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; { case 6: data = (char *)malloc((10+1)*sizeof(char)); if (data == NULL) {exit(-1);} break; } { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_41.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_41_badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_41.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_41_badSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_41_bad() { wchar_t * data; data = NULL; data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_41_goodG2BSink(wchar_t * data) { { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_04.c", "text": "strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(STATIC_CONST_TRUE) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22a.c", "text": "int CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badGlobal = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_bad() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22a.c", "text": "int CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badGlobal = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_bad() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B2Global = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22a.c", "text": "#ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B2Global = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); } } char * CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B2Global = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_22_goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_bad.cpp", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_bad::CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_bad(char * dataCopy) { data = dataCopy; data = (char *)malloc(10*sizeof(char)); if (data == NULL) {exit(-1);} CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_bad::~CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_84_bad() { { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_15.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_15.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_15_bad() { char * data; data = NULL; switch(6) { case 6: data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_15.c", "text": "static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; switch(6) { case 6: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_08.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_08_bad() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_08.c", "text": "memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(staticReturnsTrue()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_07.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() #define SRC_STRING L\"AAAAAAAAAA\" data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_07.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memmove * BadSink : Copy string to data using memmove() #define SRC_STRING L\"AAAAAAAAAA\" data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_07.c", "text": "{ wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B1() { wchar_t * data; data = NULL; else { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B2() { wchar_t * data; data = NULL; if(staticFive==5) { data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} } { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_63b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_63b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: ncpy * BadSink : Copy string to data using strncpy() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_83_goodG2B.cpp", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_83_goodG2B::~CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_83_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_18.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_18.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_18_bad() { char * data; data = NULL; goto source; source: data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = NULL; goto source; source: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncpy_73b.cpp", "text": "char * data = dataList.back(); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); free(data); void goodG2BSink(list<char *> dataList) { char * data = dataList.back(); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22a.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: memcpy * BadSink : Copy string to data using memcpy() #ifndef OMITBAD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badGlobal = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badSource(wchar_t * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_bad() { wchar_t * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22a.c", "text": "#ifndef OMITBAD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badGlobal = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badSource(wchar_t * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_bad() { wchar_t * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_badSource(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); #ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B2Global = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B1Source(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22a.c", "text": "memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); #ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B2Global = 0; wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B1Source(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); } } wchar_t * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B2Source(wchar_t * data); static void goodG2B2() { wchar_t * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B2Global = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memcpy_22_goodG2B2Source(data); { wchar_t source[10+1] = SRC_STRING; memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_62a.cpp", "text": "* @description * CWE: 122 Heap Based Buffer Overflow * BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); #ifndef OMITGOOD void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_12.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memmove_12.c", "text": "else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); * both branches use the GoodSource */ static void goodG2B() { char * data; data = NULL; if(globalReturnsTrueOrFalse()) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_14.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: ncat * BadSink : Copy string to data using strncat void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_14_bad() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_14.c", "text": "strncat(data, source, 100); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_63b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_63b.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char)); printLine(data); free(data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_memmove_63b_goodG2BSink(char * * dataPtr) { char * data = *dataPtr; { char source[10+1] = SRC_STRING; memmove(data, source, (strlen(source) + 1) * sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_15.c", "text": "void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_15_bad() { char * data; data = NULL; switch(6) { case 6: data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_15.c", "text": "static void goodG2B1() { char * data; data = NULL; printLine(\"Benign, fixed string\"); break; default: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; switch(6) { case 6: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22a.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sink: ncpy * BadSink : Copy string to data using strncpy() #ifndef OMITBAD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badGlobal = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_bad() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badSource(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22a.c", "text": "#ifndef OMITBAD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badGlobal = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badSource(char * data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_bad() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badGlobal = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_badSource(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); #ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B2Global = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B1Source(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22a.c", "text": "strncpy(data, source, strlen(source) + 1); printLine(data); free(data); #ifndef OMITGOOD int CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B2Global = 0; char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B1Global = 0; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B1Source(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1); printLine(data); free(data); } } char * CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B2Global = 1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_ncpy_22_goodG2B2Source(data); { char source[10+1] = SRC_STRING; strncpy(data, source, strlen(source) + 1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_03.c", "text": "* BadSource: Allocate using malloc() and set data pointer to a small buffer * GoodSource: Allocate using malloc() and set data pointer to a large buffer * Sink: ncat * BadSink : Copy string to data using strncat void CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_03_bad() { char * data; data = NULL; if(5==5) { data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_ncat_03.c", "text": "strncat(data, source, 100); printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100); printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(5==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncat(data, source, 100);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_01.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_31.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_31_bad() { wchar_t * data; data = NULL; data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_31.c", "text": "* BadSource: Allocate memory for a string, but do not allocate space for NULL terminator * GoodSource: Allocate enough memory for a string and the NULL terminator * Sinks: memmove * BadSink : Copy string to data using memmove() * Flow Variant: 31 Data flow using a copy of data within the same function void CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_memmove_31_bad() { wchar_t * data; data = NULL; data = (wchar_t *)malloc(10*sizeof(wchar_t)); if (data == NULL) {exit(-1);} { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t)); printWLine(data); free(data); static void goodG2B() { wchar_t * data; data = NULL; data = (wchar_t *)malloc((10+1)*sizeof(wchar_t)); if (data == NULL) {exit(-1);} { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[10+1] = SRC_STRING; memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_05.c", "text": "data = (char *)malloc(50*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE122_Heap_Based_Buffer_Overflow/s07/CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_05.c", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B1() { char * data; data = NULL; } else { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); free(data); static void goodG2B2() { char * data; data = NULL; if(staticTrue) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\\0'; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_82_goodB2G.cpp", "text": "if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_15.c", "text": "data = (char *)malloc(20*sizeof(char)); { case 6: strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); break; default: if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_15.c", "text": "* BadSource: malloc Allocate data using malloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_malloc_15_bad() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); { case 6: strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); break; default: if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); { case 6: if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_10.c", "text": "data = (char *)realloc(data, 20*sizeof(char)); if(globalTrue) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_realloc_10.c", "text": "* BadSource: realloc Allocate data using realloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_realloc_10_bad() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); if(globalTrue) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)realloc(data, 20*sizeof(char)); if(globalTrue) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_22b.c", "text": "extern int CWE690_NULL_Deref_From_Return__char_calloc_22_badGlobal; void CWE690_NULL_Deref_From_Return__char_calloc_22_badSink(char * data) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_22b.c", "text": "extern int CWE690_NULL_Deref_From_Return__char_calloc_22_badGlobal; void CWE690_NULL_Deref_From_Return__char_calloc_22_badSink(char * data) if(CWE690_NULL_Deref_From_Return__char_calloc_22_badGlobal) { strcpy(data, \"Initialize\"); printLine(data); free(data); extern int CWE690_NULL_Deref_From_Return__char_calloc_22_goodB2G2Global; void CWE690_NULL_Deref_From_Return__char_calloc_22_goodB2G1Sink(char * data) else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_22b.c", "text": "extern int CWE690_NULL_Deref_From_Return__char_calloc_22_badGlobal; void CWE690_NULL_Deref_From_Return__char_calloc_22_badSink(char * data) if(CWE690_NULL_Deref_From_Return__char_calloc_22_badGlobal) { strcpy(data, \"Initialize\"); printLine(data); free(data); extern int CWE690_NULL_Deref_From_Return__char_calloc_22_goodB2G2Global; void CWE690_NULL_Deref_From_Return__char_calloc_22_goodB2G1Sink(char * data) else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); } void CWE690_NULL_Deref_From_Return__char_calloc_22_goodB2G2Sink(char * data) if(CWE690_NULL_Deref_From_Return__char_calloc_22_goodB2G2Global) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_51b.c", "text": "/* * @description * CWE: 690 Unchecked Return Value To NULL Pointer * BadSource: calloc Allocate data using calloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE690_NULL_Deref_From_Return__char_calloc_51b_badSink(char * data) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_51b.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); #ifndef OMITGOOD void CWE690_NULL_Deref_From_Return__char_calloc_51b_goodB2GSink(char * data) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_18.c", "text": "data = (char *)calloc(20, sizeof(char)); goto sink; sink: strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); goto sink; sink: if (data != NULL) strcpy(data, \"Initialize\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_21.c", "text": "static int badStatic = 0; static void badSink(char * data) if(badStatic) { strcpy(data, \"Initialize\"); printLine(data); free(data); void CWE690_NULL_Deref_From_Return__char_malloc_21_bad() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); badStatic = 1; badSink(data); static int goodB2G2Static = 0; static void goodB2G1Sink(char * data) else { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_malloc_21.c", "text": "strcpy(data, \"Initialize\"); printLine(data); free(data); void CWE690_NULL_Deref_From_Return__char_malloc_21_bad() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); badStatic = 1; badSink(data); static int goodB2G2Static = 0; static void goodB2G1Sink(char * data) else { if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)malloc(20*sizeof(char)); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(char * data) if(goodB2G2Static) { if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_15.c", "text": "data = (char *)calloc(20, sizeof(char)); { case 6: strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); break; default: if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE690_NULL_Deref_From_Return/s01/CWE690_NULL_Deref_From_Return__char_calloc_15.c", "text": "* BadSource: calloc Allocate data using calloc() * Sinks: * GoodSink: Check to see if the data allocation failed and if not, use data * BadSink : Don't check for NULL and use data void CWE690_NULL_Deref_From_Return__char_calloc_15_bad() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); { case 6: strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G1() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); break; default: if (data != NULL) { strcpy(data, \"Initialize\"); printLine(data); free(data); static void goodB2G2() { char * data; data = NULL; data = (char *)calloc(20, sizeof(char)); { case 6: if (data != NULL) strcpy(data, \"Initialize\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_08.c", "text": "{ break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_08.c", "text": "{ char * data; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_08.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B2() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_12.c", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_console_12_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_12.c", "text": "{ char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_12.c", "text": "{ size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"Doe, XXXXX\"); strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_42.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void CWE90_LDAP_Injection__w32_char_listen_socket_42_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; data = badSource(data); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_12.c", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_file_12_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_12.c", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_file_12_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_12.c", "text": "void CWE90_LDAP_Injection__w32_char_file_12_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); * both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcat(data, \"Doe, XXXXX\"); strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_connect_socket_21.c", "text": "static int badStatic = 0; static wchar_t * badSource(wchar_t * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_08.c", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_file_08_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_06.c", "text": "#pragma comment(lib, \"wldap32\") void CWE90_LDAP_Injection__w32_char_console_06_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_06.c", "text": "if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B2() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_74a.cpp", "text": "void bad() { char * data; map<int, char *> dataMap; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_52a.c", "text": "* GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE90_LDAP_Injection__w32_char_file_52b_badSink(char * data); void CWE90_LDAP_Injection__w32_char_file_52_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE90_LDAP_Injection__w32_char_file_52b_badSink(data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_file_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_84_goodG2B.cpp", "text": "/* * @description * CWE: 90 LDAP Injection * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE90_LDAP_Injection__w32_char_connect_socket_84_goodG2B::CWE90_LDAP_Injection__w32_char_connect_socket_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_52a.c", "text": "void CWE90_LDAP_Injection__w32_char_listen_socket_52b_badSink(char * data); void CWE90_LDAP_Injection__w32_char_listen_socket_52_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE90_LDAP_Injection__w32_char_listen_socket_52b_badSink(data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_listen_socket_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_82a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE90_LDAP_Injection__w32_char_file_82_base* baseObject = new CWE90_LDAP_Injection__w32_char_file_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_41.c", "text": "_snprintf(filter, 256-1, \"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_char_listen_socket_41_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_41.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE90_LDAP_Injection__w32_char_listen_socket_41_badSink(data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_listen_socket_41_goodG2BSink(char * data) ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_05.c", "text": "size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_83_goodG2B.cpp", "text": "/* * @description * CWE: 90 LDAP Injection * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE90_LDAP_Injection__w32_char_listen_socket_83_goodG2B::CWE90_LDAP_Injection__w32_char_listen_socket_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_01.c", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_console_01_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_31.c", "text": "* GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 31 Data flow using a copy of data within the same function void CWE90_LDAP_Injection__w32_char_file_31_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_10.c", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_console_10_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_10.c", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_file_10_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_45.c", "text": "* GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = CWE90_LDAP_Injection__w32_char_connect_socket_45_badData; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_char_connect_socket_45_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_45.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE90_LDAP_Injection__w32_char_connect_socket_45_badData = data; static void goodG2BSink() { char * data = CWE90_LDAP_Injection__w32_char_connect_socket_45_goodG2BData; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_09.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE90_LDAP_Injection__w32_char_environment_09_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_environment_09.c", "text": "{ char * data; char dataBuffer[256] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 256-dataLen-1); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; else { strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B2() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_62b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_65a.c", "text": "void CWE90_LDAP_Injection__w32_char_listen_socket_65b_badSink(char * data); void CWE90_LDAP_Injection__w32_char_listen_socket_65_bad() { char * data; void (*funcPtr) (char *) = CWE90_LDAP_Injection__w32_char_listen_socket_65b_badSink; char dataBuffer[256] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_listen_socket_65a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (256 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_listen_socket_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE90_LDAP_Injection__w32_char_listen_socket_65b_goodG2BSink; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_44.c", "text": "{ size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_65a.c", "text": "#ifndef OMITBAD void CWE90_LDAP_Injection__w32_char_file_65b_badSink(char * data); void CWE90_LDAP_Injection__w32_char_file_65_bad() { char * data; void (*funcPtr) (char *) = CWE90_LDAP_Injection__w32_char_file_65b_badSink; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_file_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE90_LDAP_Injection__w32_char_file_65b_goodG2BSink; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_connect_socket_15.c", "text": "{ *replace = '\\0'; } replace = strchr(data, '\\n'); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; break; default: strcat(data, \"Doe, XXXXX\"); ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B2() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_17.c", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_file_17_bad() { int i; char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B() { int h; char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_67a.c", "text": "* GoodSource: Use a fixed string * Sinks: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE90_LDAP_Injection__w32_char_console_67_bad() { char * data; CWE90_LDAP_Injection__w32_char_console_67_structType myStruct; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE90_LDAP_Injection__w32_char_console_67_structType myStruct; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_52a.c", "text": "void CWE90_LDAP_Injection__w32_char_console_52_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE90_LDAP_Injection__w32_char_console_52b_badSink(data); #ifndef OMITGOOD void CWE90_LDAP_Injection__w32_char_console_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_wchar_t_connect_socket_41.c", "text": "* GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE90_LDAP_Injection__w32_wchar_t_connect_socket_41_badSink(wchar_t * data) ULONG connectSuccess = 0L; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; wchar_t filter[256]; _snwprintf(filter, 256-1, L\"(cn=%s)\", data); void CWE90_LDAP_Injection__w32_wchar_t_connect_socket_41_bad() { wchar_t * data; wchar_t dataBuffer[256] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (256 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_file_09.c", "text": "* BadSource: file Read input from a file * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_file_09_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(256-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE90_LDAP_Injection/CWE90_LDAP_Injection__w32_char_console_09.c", "text": "* BadSource: console Read input from the console * GoodSource: Use a fixed string * Sink: * BadSink : data concatenated into LDAP search, which could result in LDAP Injection void CWE90_LDAP_Injection__w32_char_console_09_bad() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (256-dataLen > 1) { if (fgets(data+dataLen, (int)(256-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; ULONG searchSuccess = 0L; LDAPMessage *pMessage = NULL; char filter[256]; _snprintf(filter, 256-1, \"(cn=%s)\", data); static void goodG2B1() { char * data; char dataBuffer[256] = \"\"; data = dataBuffer; strcat(data, \"Doe, XXXXX\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE244_Heap_Inspection/CWE244_Heap_Inspection__w32_char_realloc_17.c", "text": "* CWE: 244 Failure to Clear Heap Before Release (Heap Inspection) * Sinks: realloc * GoodSink: Clear the password buffer before reallocating it * BadSink : Reallocate buffer containing password without first clearing the buffer for(j = 0; j < 1; j++) { { char * password = (char *)malloc(100*sizeof(char)); if (password == NULL) {exit(-1);} HANDLE hUser; char * username = \"User\"; char * domain = \"Domain\"; password[0] = '\\0'; if (fgets(password, 100, stdin) == NULL) { printLine(\"fgets() failed\"); password[0] = '\\0'; } passwordLen = strlen(password); if (passwordLen > 0) { password[passwordLen-1] = '\\0'; } if (LogonUserA( username, domain, password, { printLine(\"Unable to login.\"); } password = realloc(password, 200 * sizeof(char)); if (password == NULL) {exit(-1);} SecureZeroMemory(password, 200 * sizeof(char)); strcpy(password, \"Nothing to see here\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE244_Heap_Inspection/CWE244_Heap_Inspection__w32_char_realloc_17.c", "text": "SecureZeroMemory(password, 200 * sizeof(char)); strcpy(password, \"Nothing to see here\"); printLine(password); free(password); for(k = 0; k < 1; k++) { { char * password = (char *)malloc(100*sizeof(char)); if (password == NULL) {exit(-1);} HANDLE hUser; char * username = \"User\"; char * domain = \"Domain\"; password[0] = '\\0'; if (fgets(password, 100, stdin) == NULL) { printLine(\"fgets() failed\"); password[0] = '\\0'; } passwordLen = strlen(password); if (passwordLen > 0) { password[passwordLen-1] = '\\0'; } if (LogonUserA( username, domain, password, { printLine(\"Unable to login.\"); } SecureZeroMemory(password, 100 * sizeof(char)); password = realloc(password, 200 * sizeof(char)); if (password == NULL) {exit(-1);} strcpy(password, \"Nothing to see here\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE244_Heap_Inspection/CWE244_Heap_Inspection__w32_char_realloc_14.c", "text": "* CWE: 244 Failure to Clear Heap Before Release (Heap Inspection) * Sinks: realloc * GoodSink: Clear the password buffer before reallocating it * BadSink : Reallocate buffer containing password without first clearing the buffer if(globalFive==5) { { char * password = (char *)malloc(100*sizeof(char)); if (password == NULL) {exit(-1);} HANDLE hUser; char * username = \"User\"; char * domain = \"Domain\"; password[0] = '\\0'; if (fgets(password, 100, stdin) == NULL) { printLine(\"fgets() failed\"); password[0] = '\\0'; } passwordLen = strlen(password); if (passwordLen > 0) { password[passwordLen-1] = '\\0'; } if (LogonUserA( username, domain, password, { printLine(\"Unable to login.\"); } password = realloc(password, 200 * sizeof(char)); if (password == NULL) {exit(-1);} SecureZeroMemory(password, 200 * sizeof(char)); strcpy(password, \"Nothing to see here\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE244_Heap_Inspection/CWE244_Heap_Inspection__w32_char_realloc_14.c", "text": "if (password == NULL) {exit(-1);} strcpy(password, \"Nothing to see here\"); printLine(password); free(password); if(globalFive==5) { { char * password = (char *)malloc(100*sizeof(char)); if (password == NULL) {exit(-1);} HANDLE hUser; char * username = \"User\"; char * domain = \"Domain\"; password[0] = '\\0'; if (fgets(password, 100, stdin) == NULL) { printLine(\"fgets() failed\"); password[0] = '\\0'; } passwordLen = strlen(password); if (passwordLen > 0) { password[passwordLen-1] = '\\0'; } if (LogonUserA( username, domain, password, { printLine(\"Unable to login.\"); } SecureZeroMemory(password, 100 * sizeof(char)); password = realloc(password, 200 * sizeof(char)); if (password == NULL) {exit(-1);} strcpy(password, \"Nothing to see here\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_72a.cpp", "text": "} dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_63a.c", "text": "data[0] = L'\\0'; } } CWE256_Plaintext_Storage_of_Password__w32_wchar_t_63b_badSink(&data); #ifndef OMITGOOD void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_63b_goodG2BSink(wchar_t * * data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_72a.cpp", "text": "} dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_66a.c", "text": "data[0] = '\\0'; } } dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; char dataBuffer[100] = \"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_81a.cpp", "text": "} else { data[0] = L'\\0'; } } const CWE256_Plaintext_Storage_of_Password__w32_wchar_t_81_base& baseObject = CWE256_Plaintext_Storage_of_Password__w32_wchar_t_81_bad(); baseObject.action(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_53a.c", "text": "data[0] = '\\0'; } } CWE256_Plaintext_Storage_of_Password__w32_char_53b_badSink(data); #ifndef OMITGOOD void CWE256_Plaintext_Storage_of_Password__w32_char_53b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_01.c", "text": "} else { data[0] = '\\0'; if (LogonUserA( username, domain, data, static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_01.c", "text": "} memcpy(data, payload, payloadBytes); data[payloadBytes / sizeof(char)] = '\\0'; if (LogonUserA( username, domain, data, static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_54a.c", "text": "data[0] = '\\0'; } } CWE256_Plaintext_Storage_of_Password__w32_char_54b_badSink(data); #ifndef OMITGOOD void CWE256_Plaintext_Storage_of_Password__w32_char_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_01.c", "text": "} else { data[0] = L'\\0'; if (LogonUserW( username, domain, data, static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_01.c", "text": "} memcpy(data, payload, payloadBytes); data[payloadBytes / sizeof(wchar_t)] = L'\\0'; if (LogonUserW( username, domain, data, static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_82_goodB2G.cpp", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserA() * BadSink : Authenticate the user using LogonUserA() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE256_Plaintext_Storage_of_Password__w32_char_82 { void CWE256_Plaintext_Storage_of_Password__w32_char_82_goodB2G::action(char * data) HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_65a.c", "text": "} } funcPtr(data); #ifndef OMITGOOD void CWE256_Plaintext_Storage_of_Password__w32_char_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE256_Plaintext_Storage_of_Password__w32_char_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_52c.c", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserW() * BadSink : Authenticate the user using LogonUserW() * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_52c_badSink(wchar_t * data) if (LogonUserW( username, domain, data, #ifndef OMITGOOD void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_52c_goodG2BSink(wchar_t * data) if (LogonUserW( username, domain, data, } void CWE256_Plaintext_Storage_of_Password__w32_wchar_t_52c_goodB2GSink(wchar_t * data) HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_char_84_goodG2B.cpp", "text": "* Sinks: * GoodSink: Decrypt the password then authenticate the user using LogonUserA() * BadSink : Authenticate the user using LogonUserA() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE256_Plaintext_Storage_of_Password__w32_char_84_goodG2B::CWE256_Plaintext_Storage_of_Password__w32_char_84_goodG2B(char * dataCopy) { data = dataCopy; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgets(data, 100, pFile) == NULL) { data[0] = '\\0'; } else { data[0] = '\\0'; } do { BYTE payload[(100 - 1) * sizeof(char)]; DWORD payloadBytes; payloadBytes = decodeHexChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(char)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_33.cpp", "text": "} } { wchar_t * data = dataRef; if (LogonUserW( username, domain, data, static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; pFile = fopen(\"passwords.txt\", \"r\"); if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_33.cpp", "text": "if (LogonUserW( username, domain, data, static void goodB2G() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; if (pFile != NULL) { if (fgetws(data, 100, pFile) == NULL) { data[0] = L'\\0'; } else { data[0] = L'\\0'; } } { wchar_t * data = dataRef; HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE256_Plaintext_Storage_of_Password/CWE256_Plaintext_Storage_of_Password__w32_wchar_t_61a.c", "text": "static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; data = CWE256_Plaintext_Storage_of_Password__w32_wchar_t_61b_goodG2BSource(data); if (LogonUserW( username, domain, data, } wchar_t * CWE256_Plaintext_Storage_of_Password__w32_wchar_t_61b_goodB2GSource(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; data = CWE256_Plaintext_Storage_of_Password__w32_wchar_t_61b_goodB2GSource(data); HCRYPTKEY hKey = 0; do { BYTE payload[(100 - 1) * sizeof(wchar_t)]; DWORD payloadBytes; payloadBytes = decodeHexWChars(payload, sizeof(payload), data); SecureZeroMemory(data, 100 * sizeof(wchar_t)); { break; } if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes)) { break; } memcpy(data, payload, payloadBytes);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "static int badStatic = 0; static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "static int badStatic = 0; static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); badStatic = 1; badSink(data); static int goodG2bStatic = 0; static void goodB2G1Sink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "static int goodG2bStatic = 0; static void goodB2G1Sink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; static void goodB2G2() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t data; data = 0; fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t data; data = 0; fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t data; data = 0; fscanf(stdin, \"%zu\", &data); if(goodB2G2Static) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_21.cpp", "text": "myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t data; data = 0; fscanf(stdin, \"%zu\", &data); if(goodB2G2Static) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t data; data = 0; fscanf(stdin, \"%zu\", &data); if(goodG2bStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05 void bad() { size_t data; data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05 data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05 void bad() { size_t data; data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp", "text": "static int staticTrue = 1; static int staticFalse = 0; namespace CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05 data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_05.cpp", "text": "if(staticTrue) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING) && data < 100) { myString = new wchar_t[data]; static void goodB2G2() { size_t data; data = 0; if(staticTrue) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; static void goodB2G2() { size_t data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "fscanf(stdin, \"%zu\", &data); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" return 0; } namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08 data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "return 0; } namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08 data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_08.cpp", "text": "if(staticReturnsTrue()) { fscanf(stdin, \"%zu\", &data); if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_53d.cpp", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_53 { #ifndef OMITBAD void badSink_d(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_53d.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink_d(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_53d.cpp", "text": "{ printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void goodG2BSink_d(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_53d.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink_d(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodG2BSink_d(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_53d.cpp", "text": "printLine(myString); delete [] myString; } else { printLine(\"Input is less than the length of the source string\"); } } } void goodB2GSink_d(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_53d.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink_d(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodG2BSink_d(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodB2GSink_d(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_51b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_51b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "static const int STATIC_CONST_FIVE = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "static const int STATIC_CONST_FIVE = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "static const int STATIC_CONST_FIVE = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "{ char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "static const int STATIC_CONST_FIVE = 5; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06 { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "{ char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "{ myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_06.cpp", "text": "} else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "void bad() { size_t data; data = 0; if(globalFive==5) { data = rand(); } if(globalFive==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "data = 0; if(globalFive==5) { data = rand(); } if(globalFive!=5) { printLine(\"Benign, fixed string\"); } else { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "static void goodB2G2() { size_t data; data = 0; if(globalFive==5) { data = rand(); } if(globalFive==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "data = 0; if(globalFive!=5) { printLine(\"Benign, fixed string\"); } else { data = 20; } if(globalFive==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "static void goodG2B2() { size_t data; data = 0; if(globalFive==5) { data = 20; } if(globalFive==5) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_14.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_02.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_02.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_02.cpp", "text": "data = 0; if(1) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_02.cpp", "text": "data = 0; if(1) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(1) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_02.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(1) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_02.cpp", "text": "if(1) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G1() { size_t data; data = 0; if(1) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING) && data < 100) { myString = new wchar_t[data]; static void goodB2G2() { size_t data; data = 0; if(1) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_33.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_33.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_33.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_62a.cpp", "text": "if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_62a.cpp", "text": "#define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_62 data = 0; badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74b.cpp", "text": "using namespace std; namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_74 size_t data = dataMap[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = dataMap[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; { size_t data = dataMap[2]; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54d.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_54d.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_84_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_84_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_bad.cpp", "text": "* */ #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82 { void CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_bad::action(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_bad.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__new_char_rand_82_bad::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_63b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_63b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_goodG2B.cpp", "text": "* */ #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82 { void CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_goodG2B::action(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_goodG2B.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_goodG2B::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_42.cpp", "text": "static size_t badSource(size_t data) { data = rand(); return data; } void bad() { size_t data; data = 0; data = badSource(data); { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_42.cpp", "text": "static size_t goodG2BSource(size_t data) { data = 20; return data; } static void goodG2B() { size_t data; data = 0; data = goodG2BSource(data); { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_rand_42.cpp", "text": "static size_t goodB2GSource(size_t data) { data = rand(); return data; } static void goodB2G() { size_t data; data = 0; data = goodB2GSource(data); { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_41.cpp", "text": "#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fgets_41 static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); static void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_bad.cpp", "text": "* */ #ifndef OMITBAD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82 { void CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_bad::action(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_bad.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_bad::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_43.cpp", "text": "size_t data; data = 0; badSource(data); { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; #ifndef OMITGOOD static void goodG2BSource(size_t &data) { data = 20; static void goodG2B() { size_t data; data = 0; goodG2BSource(data); { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; } static void goodB2GSource(size_t &data) { fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_31.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_31.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_31.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); { size_t dataCopy = data; size_t data = dataCopy; { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodG2B() { size_t data; data = 0; data = 20; { size_t dataCopy = data; size_t data = dataCopy; { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01.cpp", "text": "#define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01 void bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodG2B() { size_t data; data = 0; data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01.cpp", "text": "data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_01.cpp", "text": "fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; size_t data; data = 0; fscanf(stdin, \"%zu\", &data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "if(5==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; static void goodB2G1() { size_t data; data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; static void goodB2G2() { size_t data; data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "fscanf(stdin, \"%zu\", &data); if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03 data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); if(5==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); if(5==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(5==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_fscanf_03.cpp", "text": "if(5==5) { fscanf(stdin, \"%zu\", &data); if(5==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_32.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_32.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_wchar_t_fscanf_32.cpp", "text": "if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodG2B() { size_t data; size_t *dataPtr1 = &data; size_t *dataPtr2 = &data; data = 0; { size_t data = *dataPtr1; data = 20; *dataPtr1 = data; } { size_t data = *dataPtr2; { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = new wchar_t[data]; static void goodB2G() { size_t data; size_t *dataPtr1 = &data; size_t *dataPtr2 = &data; data = 0; { size_t data = *dataPtr1; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_04.cpp", "text": "#define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" /* The two variables below are declared \"const\", so a tool should be able to identify that reads of these will always return their WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_04.cpp", "text": "#define HELLO_STRING \"hello\" recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_04.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_04.cpp", "text": "break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_04.cpp", "text": "break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_04.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_04.cpp", "text": "break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_13.cpp", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_13.cpp", "text": "break; } inputBuffer[recvResult] = '\\0'; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_13.cpp", "text": "break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_13.cpp", "text": "strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s02/CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_13.cpp", "text": "break; } inputBuffer[recvResult] = '\\0'; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(GLOBAL_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_62a.cpp", "text": "if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_62a.cpp", "text": "data = 0; badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; goodG2BSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; goodB2GSource(data); { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_32.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_32.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_32.c", "text": "{ size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; { size_t data = *dataPtr2; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrueOrFalse()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12_bad() { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrueOrFalse()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12.c", "text": "if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrueOrFalse()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12_bad() { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); * for the strcpy() function to not cause a buffer overflow */", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12.c", "text": "} else { printLine(\"fgets() failed.\"); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(globalReturnsTrueOrFalse()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12.c", "text": "if(globalReturnsTrueOrFalse()) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(globalReturnsTrueOrFalse()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_12.c", "text": "else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(globalReturnsTrueOrFalse()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e.c", "text": "#define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_badSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e.c", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e.c", "text": "{ printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_goodG2BSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e.c", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e.c", "text": "printLine(myString); free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_goodB2GSink(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_goodG2B.cpp", "text": "* */ #ifndef OMITGOOD #include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82.h\" #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82 { void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_goodG2B::action(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_goodG2B.cpp", "text": "#include \"std_testcase.h\" #include \"CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82.h\" #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_goodG2B::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_83_goodB2G.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_83_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_83_goodB2G() * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_83_goodB2G.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_83_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_83_goodB2G() { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c", "text": "#endif #define HELLO_STRING \"hello\" #ifndef OMITBAD static int badStatic = 0; static void badSink(size_t data) { if(badStatic) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(badStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c", "text": "static int goodB2G2Static = 0; static int goodG2BStatic = 0; static void goodB2G1Sink(size_t data) { if(goodB2G1Static) { printLine(\"Benign, fixed string\"); } else { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" if(badStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c", "text": "if(badStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(goodB2G2Static) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c", "text": "data = 0; data = rand(); goodB2G2Static = 1; goodB2G2Sink(data); } static void goodG2BSink(size_t data) { if(goodG2BStatic) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c", "text": "else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(goodB2G2Static) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(goodG2BStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_06.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_06.c", "text": "} else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_06.c", "text": "} else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_06.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_06.c", "text": "if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_FIVE==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_44.c", "text": "#define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" #ifndef OMITBAD static void badSink(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_44.c", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_44.c", "text": "static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; static void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_44.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; static void goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); static void goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_04.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_04.cpp", "text": "if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_04.cpp", "text": "else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_04.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e_goodG2BSink(size_t data) * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e.c", "text": "if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e_goodG2BSink(size_t data) } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e_goodB2GSink(size_t data) * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e.c", "text": "{ myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_54e_goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_33.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_33.cpp", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_33.cpp", "text": "{ size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = dataRef; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_04.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_04.c", "text": "if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_04.c", "text": "else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_04.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(STATIC_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c", "text": "int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c", "text": "int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c", "text": "int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_bad() size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 1; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G2Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodG2BGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink(size_t data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c", "text": "int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 1; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G2Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodG2BGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink(size_t data); static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c", "text": "int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_bad() size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 1; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G2Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodG2BGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink(size_t data); size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Global = 0; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink(data); } void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G2Sink(size_t data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22a.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badGlobal = 1; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_badSink(data); #ifndef OMITGOOD int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G2Global = 0; int CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodG2BGlobal = 0; void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink(size_t data); static void goodB2G1() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Global = 0; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink(data); } void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G2Sink(size_t data); static void goodB2G2() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_01.c", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; #endif } { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_01.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; #endif } { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_01.c", "text": "data = 20; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; #endif } { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b.c", "text": "#include \"std_testcase.h\" #ifndef _WIN32 #include <wchar.h> #endif #define HELLO_STRING \"hello\" #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_badSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b.c", "text": "{ printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_goodG2BSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b.c", "text": "printLine(myString); free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_goodB2GSink(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_51b_goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G1() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G1() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); static void goodB2G2() { size_t data; data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "#ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07_bad() data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_07.c", "text": "data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); data = 0; if(staticFive==5) { fscanf(stdin, \"%zu\", &data); * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d.c", "text": "#define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_badSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d.c", "text": "{ printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_goodG2BSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d.c", "text": "printLine(myString); free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_goodB2GSink(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b.c", "text": "#endif #define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b_badSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b.c", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b.c", "text": "printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b_goodG2BSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b.c", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b.c", "text": "free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b_goodB2GSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_52c.cpp", "text": "#define TCP_PORT 27015 #define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" namespace CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_52 { #ifndef OMITBAD void badSink_c(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_52c.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink_c(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_52c.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink_c(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodG2BSink_c(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__new_char_connect_socket_52c.cpp", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void badSink_c(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodG2BSink_c(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = new char[data]; strcpy(myString, HELLO_STRING); printLine(myString); delete [] myString; void goodB2GSink_c(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = new char[data]; strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b_goodG2BSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodG2BData; * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b.c", "text": "#define HELLO_STRING \"hello\" extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_badData; extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodG2BData; extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodB2GData; #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b_badSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_badData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b_goodG2BSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodG2BData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b_goodG2BSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodG2BData; } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b_goodB2GSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodB2GData; * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b.c", "text": "if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b_goodG2BSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodG2BData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68b_goodB2GSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_68_goodB2GData; { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51a.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51a.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51a.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51_bad() size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_badSink(data); #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_goodG2BSink(size_t data); data = 0; data = 20; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_goodG2BSink(data); } void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_goodB2GSink(size_t data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51a.c", "text": "* Sinks: * GoodSink: Allocate memory with malloc() and check the size of the memory to be allocated * BadSink : Allocate memory with malloc(), but incorrectly check the size of the memory to be allocated * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_badSink(size_t data); void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51_bad() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data); CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_badSink(data); #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_goodG2BSink(size_t data); static void goodG2B() { size_t data; data = 0; data = 20; CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_goodG2BSink(data); } void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_51b_goodB2GSink(size_t data); static void goodB2G() { size_t data; data = 0; fscanf(stdin, \"%zu\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_goodB2G.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_goodB2G() * for the strcpy() function to not cause a buffer overflow */", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_goodB2G.cpp", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); } } CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_84_goodB2G() { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c.c", "text": "#define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_badSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c.c", "text": "{ printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_goodG2BSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c.c", "text": "#define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c.c", "text": "printLine(myString); free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_goodB2GSink(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_52c_goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_02.c", "text": "#define IP_ADDRESS \"127.0.0.1\" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING \"hello\" WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_02.c", "text": "if(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_02.c", "text": "else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(1) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_02.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } inputBuffer[recvResult] = '\\0'; if(1) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { case 7: { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" { case 7: { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); break; default: { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15.c", "text": "{ case 7: { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); break; default: { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { case 7: { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15.c", "text": "break; default: { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { case 7: { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { case 7: { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d.c", "text": "#include \"std_testcase.h\" #ifndef _WIN32 #include <wchar.h> #endif #define HELLO_STRING \"hello\" #ifndef OMITBAD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_badSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d.c", "text": "{ printLine(\"Input is less than the length of the source string\"); } } } #endif #ifndef OMITGOOD void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_goodG2BSink(size_t data) { { char * myString;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d.c", "text": "#include <wchar.h> #endif #define HELLO_STRING \"hello\" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d.c", "text": "printLine(myString); free(myString); } else { printLine(\"Input is less than the length of the source string\"); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_goodB2GSink(size_t data) { { char * myString;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d.c", "text": "void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_goodG2BSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_goodB2GSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_17.c", "text": "data = 0; for(i = 0; i < 1; i++) { fscanf(stdin, \"%zu\", &data); { { wchar_t * myString; if (data > wcslen(HELLO_STRING)) { myString = (wchar_t *)malloc(data*sizeof(wchar_t)); static void goodB2G() { int i,k; size_t data; data = 0; for(i = 0; i < 1; i++) { fscanf(stdin, \"%zu\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_07.c", "text": "if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_07.c", "text": "} else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_07.c", "text": "} else { printLine(\"fgets() failed.\"); else { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE789_Uncontrolled_Mem_Alloc/s01/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_07.c", "text": "strcpy(myString, HELLO_STRING); printLine(myString); free(myString); { { char inputBuffer[CHAR_ARRAY_SIZE] = \"\"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) } else { printLine(\"fgets() failed.\"); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING) && data < 100) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c", "text": "/* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c", "text": "char dataBuffer[100] = \"\"; char * data = dataBuffer; /* FLAW: sscanf() might fail, in which case the return value will be EOF (-1), but if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c", "text": "char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c", "text": "* @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed #include <wchar.h> #endif #define SRC_STRING \"string\" #ifndef OMITBAD void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12.c", "text": "#ifndef OMITBAD void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_12_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_16.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_16.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10.c", "text": "* @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed #include <wchar.h> #endif #define SRC_STRING \"string\" #ifndef OMITBAD void CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_10_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == 0) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF) { printLine(\"sscanf failed!\"); { { char dataBuffer[100] = \"\"; char * data = dataBuffer; if (sscanf(SRC_STRING, \"%99s\\0\", data) == EOF)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_04.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_04.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_sscanf_04.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: sscanf * GoodSink: Correctly check if sscanf() failed * BadSink : Incorrectly check if sscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_03.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: fscanf * GoodSink: Correctly check if fscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE253_Incorrect_Check_of_Function_Return_Value/CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE253_Incorrect_Check_of_Function_Return_Value__char_fscanf_03.c /* * @description * CWE: 253 Incorrect Check of Return Value * Sinks: fscanf * GoodSink: Correctly check if fscanf() failed * BadSink : Incorrectly check if fscanf() failed", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s05/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_w32CreateFile_41.cpp", "text": "hFile = CreateFileW(data, void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s05/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_w32CreateFile_72a.cpp", "text": "void badSink(vector<wchar_t *> dataVector); void bad() { wchar_t * data; vector<wchar_t *> dataVector; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_53a.cpp", "text": "* GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_45.cpp", "text": "{ ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_45.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badData = data; static void goodG2BSink() { char * data = goodG2BData; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_63a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(&data); #ifndef OMITGOOD void goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_63a.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(&data); #ifndef OMITGOOD void goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_18.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_18.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_72a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_72a.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_74a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_74a.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_72a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_72a.cpp", "text": "* GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_08.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_08.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_08.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_41.cpp", "text": "{ ofstream outputFile; outputFile.open((char *)data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_41.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_73a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_73a.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_54a.cpp", "text": "* GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_63a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); #ifndef OMITGOOD void goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_63a.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); #ifndef OMITGOOD void goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_31.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_31.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 31 Data flow using a copy of data within the same function void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_03.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_03.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_03.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_03.cpp", "text": "{ { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_14.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_14.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_14.cpp", "text": "size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_14.cpp", "text": "pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_16.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_16.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_15.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; default: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_15.cpp", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; default: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_15.cpp", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; default: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; case 6: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_72a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_72a.cpp", "text": "* GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files void bad() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_32.cpp", "text": "char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ofstream_32.cpp", "text": "char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_53a.cpp", "text": "* GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); #ifndef OMITGOOD void goodG2BSink_b(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_17.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_17.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_33.cpp", "text": "* GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_open_33.cpp", "text": "* GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_16.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_16.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: ofstream * BadSink : Open the file named in data using ofstream::open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_68a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE36_Absolute_Path_Traversal__char_file_ifstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_68a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } CWE36_Absolute_Path_Traversal__char_file_ifstream_68_badData = data; static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_18.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_18.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_10.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_10.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_10.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_12.cpp", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_12.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_12.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_12.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_12.cpp", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_32.cpp", "text": "char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_32.cpp", "text": "char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } *dataPtr1 = data; } { char * data = *dataPtr2; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_64a.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_33.cpp", "text": "* GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_w32CreateFile_33.cpp", "text": "* GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_13.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_13.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_13.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_31.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 31 Data flow using a copy of data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_31.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 31 Data flow using a copy of data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_51a.cpp", "text": "* GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_32.cpp", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_32.cpp", "text": "{ char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { char * data = *dataPtr1; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_51a.cpp", "text": "void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_51a.cpp", "text": "* GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_51a.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_18.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_w32CreateFile_18.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_21.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() static int badStatic = 0; static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_ifstream_21.cpp", "text": "static int badStatic = 0; static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_31.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_31.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_84_goodG2B.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_file_fopen_84_goodG2B::CWE36_Absolute_Path_Traversal__char_file_fopen_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_file_fopen_84_goodG2B.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_file_fopen_84_goodG2B::CWE36_Absolute_Path_Traversal__char_file_fopen_84_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_31.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_31.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_82a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } CWE36_Absolute_Path_Traversal__char_environment_open_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_environment_open_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_82a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } CWE36_Absolute_Path_Traversal__char_environment_open_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_environment_open_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_open_61b.cpp", "text": "* GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD char * badSource(char * data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_43.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_43.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_17.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_open_17.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_43.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s02/CWE36_Absolute_Path_Traversal__char_environment_ofstream_43.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_17.cpp", "text": "int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_17.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_45.cpp", "text": "{ static wchar_t * badData; static wchar_t * goodG2BData; static void badSink() { wchar_t * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { wchar_t * data; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_21.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_21.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_fopen_34.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) typedef union { wchar_t * unionFirst; wchar_t * unionSecond; void bad() { wchar_t * data; unionType myUnion; wchar_t dataBuffer[FILENAME_MAX] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_42.cpp", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s03/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_42.cpp", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_03.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: w32CreateFile * BadSink : Open the file named in data using CreateFile() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_03.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_03.cpp", "text": "{ dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_03.cpp", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { HANDLE hFile; hFile = CreateFileA(data, static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_41.cpp", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_41.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_21.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_21.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_81a.cpp", "text": "* GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE36_Absolute_Path_Traversal__char_console_ofstream_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_console_ofstream_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_81a.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE36_Absolute_Path_Traversal__char_console_ofstream_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_console_ofstream_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_73a.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_73a.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 73 Data flow: data passed in a list from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_42.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_42.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { HANDLE hFile; hFile = CreateFileA(data, #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_16.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_16.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_33.cpp", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_84_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_console_ofstream_84_goodG2B::CWE36_Absolute_Path_Traversal__char_console_ofstream_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_84_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_console_ofstream_84_goodG2B::CWE36_Absolute_Path_Traversal__char_console_ofstream_84_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_42.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_42.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_16.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_16.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_82a.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_17.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_17.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { int h; char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_18.cpp", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_18.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; source: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_33.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * data = dataRef; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_33.cpp", "text": "#define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * data = dataRef; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_14.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_14.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sink: fopen * BadSink : Open the file named in data using fopen() #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_14.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_65a.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_65a.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_65a.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_15.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; default: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_15.cpp", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; default: #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B2() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_12.cpp", "text": "* BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Full path and file name * Sink: open * BadSink : Open the file named in data using open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_12.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_12.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_12.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_12.cpp", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); both branches use the GoodSource */ static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); #else strcat(data, \"/tmp/file.txt\"); { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_33.cpp", "text": "char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_33.cpp", "text": "data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } { char * data = dataRef; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; char * &dataRef = data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_16.cpp", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_84_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_environment_fopen_84_goodG2B::CWE36_Absolute_Path_Traversal__char_environment_fopen_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_84_goodG2B.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_environment_fopen_84_goodG2B::CWE36_Absolute_Path_Traversal__char_environment_fopen_84_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_42.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_42.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_44.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_44.cpp", "text": "if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { FILE *pFile = NULL; pFile = FOPEN(data, \"wb+\"); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_open_05.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B1() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_64a.cpp", "text": "* GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } badSink(&data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_21.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_21.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); static int goodG2B2Static = 0; static char * goodG2B1Source(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_62b.cpp", "text": "* GoodSource: Full path and file name * Sinks: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_61b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_fopen_61b.cpp", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 61 Data flow: data returned from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; #ifndef OMITGOOD char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_environment_ifstream_51a.cpp", "text": "* GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); #ifndef OMITGOOD void goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_84_goodG2B.cpp", "text": "/* * @description * CWE: 36 Absolute Path Traversal * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_84_goodG2B::CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_84_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_34.cpp", "text": "char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_34.cpp", "text": "{ size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); static void goodG2B() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_83_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_console_ofstream_83_goodG2B::CWE36_Absolute_Path_Traversal__char_console_ofstream_83_goodG2B(char * dataCopy) { data = dataCopy; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ofstream_83_goodG2B.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sinks: ofstream * BadSink : Open the file named in data using ofstream::open() * Flow Variant: 83 Data flow: data passed to class constructor and destructor by declaring the class object on the stack { CWE36_Absolute_Path_Traversal__char_console_ofstream_83_goodG2B::CWE36_Absolute_Path_Traversal__char_console_ofstream_83_goodG2B(char * dataCopy) { data = dataCopy; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_16.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Full path and file name * Sink: ifstream * BadSink : Open the file named in data using ifstream::open() void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_ifstream_16.cpp", "text": "{ char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { ifstream inputFile; inputFile.open((char *)data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_81a.cpp", "text": "* GoodSource: Full path and file name * Sinks: w32CreateFile * BadSink : Open the file named in data using CreateFile() * Flow Variant: 81 Data flow: data passed in a parameter to a virtual method called via a reference void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_81a.cpp", "text": "void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } const CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_console_w32CreateFile_81_bad(); baseObject.action(data); static void goodG2B() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_console_fopen_67a.cpp", "text": "* GoodSource: Full path and file name * Sinks: fopen * BadSink : Open the file named in data using fopen() * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void bad() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; structType myStruct; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_42.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); #ifndef OMITGOOD static char * goodG2BSource(char * data) strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_42.cpp", "text": "break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } return data; void bad() { char * data; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); #ifndef OMITGOOD static char * goodG2BSource(char * data) { #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_44.cpp", "text": "* GoodSource: Full path and file name * Sinks: open * BadSink : Open the file named in data using open() * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_44.cpp", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; strcat(data, \"c:\\\\temp\\\\file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE36_Absolute_Path_Traversal/s01/CWE36_Absolute_Path_Traversal__char_connect_socket_open_44.cpp", "text": "{ break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[FILENAME_MAX] = \"\"; data = dataBuffer; #ifdef _WIN32 strcat(data, \"c:\\\\temp\\\\file.txt\"); strcat(data, \"/tmp/file.txt\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_72b.cpp", "text": "wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void goodG2BSink(vector<wchar_t *> dataVector) { wchar_t * data = dataVector[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_09.c", "text": "data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_09.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE124_Buffer_Underwrite__malloc_char_ncpy_09_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_09.c", "text": "data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_65b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__malloc_char_memcpy_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_05.c", "text": "data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_05.c", "text": "if(staticTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_05.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(staticTrue) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_18.c", "text": "data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_18.c", "text": "goto source; source: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; goto source; source: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_84_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__malloc_char_memmove_84_goodG2B::~CWE124_Buffer_Underwrite__malloc_char_memmove_84_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_42.c", "text": "data = dataBuffer - 8; } return data; void CWE124_Buffer_Underwrite__malloc_char_cpy_42_bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_42.c", "text": "data = dataBuffer - 8; } return data; void CWE124_Buffer_Underwrite__malloc_char_cpy_42_bad() { char * data; data = NULL; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); data = dataBuffer; } return data; static void goodG2B() { char * data; data = NULL; data = goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_34.c", "text": "data = dataBuffer - 8; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_34.c", "text": "wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_34_unionType myUnion; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_05.c", "text": "data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_02.c", "text": "data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_02.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE124_Buffer_Underwrite__malloc_char_cpy_02_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_08.c", "text": "if(staticReturnsTrue()) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_08.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(staticReturnsTrue()) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_34.c", "text": "data = dataBuffer - 8; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_34.c", "text": "wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_34_unionType myUnion; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_53d.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__malloc_char_memcpy_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_01.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__malloc_char_memcpy_01_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_15.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE124_Buffer_Underwrite__malloc_char_cpy_15_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_15.c", "text": "strcpy(data, source); printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_41.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE124_Buffer_Underwrite__malloc_char_cpy_41_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); data = dataBuffer - 8; } CWE124_Buffer_Underwrite__malloc_char_cpy_41_badSink(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__malloc_char_cpy_41_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_62a.cpp", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data); void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); void goodG2BSource(char * &data); static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_01.c", "text": "void CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_01_bad() { wchar_t * data; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_02.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__malloc_char_memmove_02_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_18.c", "text": "goto source; source: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; goto source; source: { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_43.cpp", "text": "data = dataBuffer - 8; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_43.cpp", "text": "memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; void bad() { char * data; data = NULL; badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2BSource(char * &data) if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; static void goodG2B() { char * data; data = NULL; goodG2BSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_cpy_65b.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); void CWE124_Buffer_Underwrite__malloc_char_cpy_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_14.c", "text": "if(globalFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_14.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(globalFive==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memcpy_10.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__malloc_char_memcpy_10_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_15.c", "text": "data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_15.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: ncpy * BadSink : Copy string to data using strncpy void CWE124_Buffer_Underwrite__malloc_char_ncpy_15_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_15.c", "text": "data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_73b.cpp", "text": "wchar_t * data = dataList.back(); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void goodG2BSink(list<wchar_t *> dataList) { wchar_t * data = dataList.back(); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_34.c", "text": "data = dataBuffer - 8; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_ncpy_34.c", "text": "{ char * data; CWE124_Buffer_Underwrite__malloc_char_ncpy_34_unionType myUnion; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; CWE124_Buffer_Underwrite__malloc_char_ncpy_34_unionType myUnion; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_44.c", "text": "#ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void (*funcPtr) (wchar_t *) = badSink; data = NULL; { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_31.c", "text": "data = dataBuffer - 8; } { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_char_memmove_31.c", "text": "void CWE124_Buffer_Underwrite__malloc_char_memmove_31_bad() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; data = NULL; if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_65b.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_65b_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_09.c", "text": "if(GLOBAL_CONST_TRUE) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_09.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(GLOBAL_CONST_TRUE) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_03.c", "text": "if(5==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memmove_03.c", "text": "else { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(5==5) { { wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t)); if (dataBuffer == NULL) {exit(-1);} wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_68b.c", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_68b_goodG2BSink() { wchar_t * data = CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_68_goodG2BData; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s02/CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_83_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_83_goodG2B::~CWE124_Buffer_Underwrite__malloc_wchar_t_memcpy_83_goodG2B() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_45.cpp", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 45 Data flow: data passed as a static global variable from one function to another in the same source file static void badSink() { char * data = badData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); data = dataBuffer - 8; } badData = data; static void goodG2BSink() { char * data = goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_04.cpp", "text": "#include <wchar.h> data = dataBuffer - 8; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memcpy_03.cpp", "text": "if(5==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memcpy_03.cpp", "text": "else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(5==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_12.cpp", "text": "data = dataBuffer - 8; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_12.cpp", "text": "memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_84_bad.cpp", "text": "data = dataBuffer - 8; CWE124_Buffer_Underwrite__new_wchar_t_memmove_84_bad::~CWE124_Buffer_Underwrite__new_wchar_t_memmove_84_bad() { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_31.cpp", "text": "wchar_t * data; data = NULL; { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_68b.cpp", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void goodG2BSink() { char * data = CWE124_Buffer_Underwrite__new_char_memcpy_68_goodG2BData; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_42.cpp", "text": "data = dataBuffer - 8; } return data; void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_42.cpp", "text": "void bad() { wchar_t * data; data = NULL; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); data = dataBuffer; } return data; static void goodG2B() { wchar_t * data; data = NULL; data = goodG2BSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_ncpy_34.cpp", "text": "{ char * data; unionType myUnion; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; unionType myUnion; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_54e.cpp", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void goodG2BSink_e(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_18.cpp", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy void bad() { char * data; data = NULL; goto source; source: char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; data = NULL; goto source; source: char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_ncpy_51b.cpp", "text": "source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); void goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_44.cpp", "text": "#ifndef OMITBAD static void badSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void (*funcPtr) (wchar_t *) = badSink; data = NULL; { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_ncpy_18.cpp", "text": "void bad() { char * data; data = NULL; goto source; source: char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; data = NULL; goto source; source: char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B::~CWE124_Buffer_Underwrite__new_char_memcpy_84_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_22a.cpp", "text": "#ifndef OMITBAD int badGlobal = 0; char * badSource(char * data); void bad() { char * data; data = NULL; badGlobal = 1; data = badSource(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_cpy_22a.cpp", "text": "#ifndef OMITGOOD char * goodG2B1Source(char * data); static void goodG2B1() { char * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); char * goodG2B2Source(char * data); static void goodG2B2() { char * data; data = NULL; goodG2B2Global = 1; data = goodG2B2Source(data); { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_83_goodG2B.cpp", "text": "data = dataBuffer; CWE124_Buffer_Underwrite__new_char_memcpy_83_goodG2B::~CWE124_Buffer_Underwrite__new_char_memcpy_83_goodG2B() { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memcpy_43.cpp", "text": "wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; void bad() { wchar_t * data; data = NULL; badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2BSource(wchar_t * &data) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; static void goodG2B() { wchar_t * data; data = NULL; goodG2BSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memcpy_22a.cpp", "text": "a C++ namespace, it doesn't need a globally unique name. */ int badGlobal = 0; wchar_t * badSource(wchar_t * data); void bad() { wchar_t * data; data = NULL; badGlobal = 1; data = badSource(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); wchar_t * goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memcpy_22a.cpp", "text": "#ifndef OMITGOOD wchar_t * goodG2B1Source(wchar_t * data); static void goodG2B1() { wchar_t * data; data = NULL; goodG2B1Global = 0; data = goodG2B1Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); wchar_t * goodG2B2Source(wchar_t * data); static void goodG2B2() { wchar_t * data; data = NULL; goodG2B2Global = 1; data = goodG2B2Source(data); { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memcpy_31.cpp", "text": "wchar_t * data; data = NULL; { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } { wchar_t * dataCopy = data; wchar_t * data = dataCopy; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_14.cpp", "text": "if(globalFive==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_14.cpp", "text": "else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(globalFive==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_17.cpp", "text": "for(i = 0; i < 1; i++) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_16.cpp", "text": "while(1) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; data = NULL; while(1) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_31.cpp", "text": "void bad() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; } { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; data = NULL; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memmove_53d.cpp", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void goodG2BSink_d(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_07.cpp", "text": "if(staticFive==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; data = NULL; else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_wchar_t_memmove_07.cpp", "text": "else { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; data = NULL; if(staticFive==5) { { wchar_t * dataBuffer = new wchar_t[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; } } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s03/CWE124_Buffer_Underwrite__new_char_memcpy_32.cpp", "text": "data = dataBuffer - 8; } *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; char * dataBuffer = new char[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; } *dataPtr1 = data; } { char * data = *dataPtr2; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_04.c", "text": "#include <wchar.h> data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_04.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(STATIC_CONST_TRUE) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_11.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_11_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(globalReturnsTrue()) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_11.c", "text": "memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(globalReturnsTrue()) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_67b.c", "text": "source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_67b_goodG2BSink(CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_67_structType myStruct) { wchar_t * data = myStruct.structFirst; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memmove_15.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__wchar_t_declare_memmove_15_bad() { wchar_t * data; wchar_t dataBuffer[100]; switch(6) { case 6: data = dataBuffer - 8; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memmove_15.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; switch(6) { case 6: data = dataBuffer; break; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_01.c", "text": "data = dataBuffer - 8; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_01.c", "text": "data = dataBuffer - 8; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_66b.c", "text": "wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_66b_goodG2BSink(wchar_t * dataArray[]) { wchar_t * data = dataArray[2]; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memmove_34.c", "text": "data = dataBuffer - 8; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memmove_34.c", "text": "void CWE124_Buffer_Underwrite__wchar_t_declare_memmove_34_bad() { wchar_t * data; CWE124_Buffer_Underwrite__wchar_t_declare_memmove_34_unionType myUnion; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; CWE124_Buffer_Underwrite__wchar_t_declare_memmove_34_unionType myUnion; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_41.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_41_badSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); void CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_41_bad() { wchar_t * data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_41_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_65b.c", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_65b_goodG2BSink(wchar_t * data) { { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_17.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_17_bad() { int i; wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; for(i = 0; i < 1; i++) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { int h; wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; for(h = 0; h < 1; h++) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_17.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_17_bad() { int i; wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; for(i = 0; i < 1; i++) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { int h; wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; for(h = 0; h < 1; h++) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_02.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_02_bad() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(1) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_02.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(1) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_12.c", "text": "if(globalReturnsTrueOrFalse()) { data = dataBuffer - 8; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); * both branches use the GoodSource */ static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalReturnsTrueOrFalse()) { data = dataBuffer; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memmove_12.c", "text": "if(globalReturnsTrueOrFalse()) { data = dataBuffer - 8; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); * both branches use the GoodSource */ static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); dataBuffer[100-1] = L'\\0'; if(globalReturnsTrueOrFalse()) { data = dataBuffer; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_alloca_memcpy_01.c", "text": "data = dataBuffer - 8; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t)); wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_33.cpp", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer - 8; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B() { wchar_t * data; wchar_t * &dataRef = data; wchar_t dataBuffer[100]; wmemset(dataBuffer, L'A', 100-1); dataBuffer[100-1] = L'\\0'; data = dataBuffer; { wchar_t * data = dataRef; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_63b.c", "text": "source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__wchar_t_declare_memcpy_63b_goodG2BSink(wchar_t * * dataPtr) { wchar_t * data = *dataPtr; { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memcpy(data, source, 100*sizeof(wchar_t));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memmove_10.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__wchar_t_declare_memmove_10_bad() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(globalTrue) { data = dataBuffer - 8; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s04/CWE124_Buffer_Underwrite__wchar_t_declare_memmove_10.c", "text": "memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B1() { wchar_t * data; wchar_t dataBuffer[100]; } else { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t)); data[100-1] = L'\\0'; printWLine(data); static void goodG2B2() { wchar_t * data; wchar_t dataBuffer[100]; dataBuffer[100-1] = L'\\0'; if(globalTrue) { data = dataBuffer; } { wchar_t source[100]; wmemset(source, L'C', 100-1); source[100-1] = L'\\0'; memmove(data, source, 100*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_18.c", "text": "data = -1; goto source; source: fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; static void goodB2G() { int data; data = -1; goto source; source: fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memcpy_15.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__char_alloca_memcpy_15_bad() { char * data; switch(6) { case 6: data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memcpy_15.c", "text": "memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; switch(6) { case 6: data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_ncpy_12.c", "text": "data = dataBuffer - 8; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_ncpy_12.c", "text": "dataBuffer[100-1] = '\\0'; if(globalReturnsTrueOrFalse()) { data = dataBuffer - 8; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrueOrFalse()) { data = dataBuffer; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_01.c", "text": "data = dataBuffer - 8; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_01.c", "text": "data = dataBuffer - 8; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_ncpy_01.c", "text": "data = dataBuffer - 8; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strncpy(data, source, 100-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_53d.c", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_alloca_memmove_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_15.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy void CWE124_Buffer_Underwrite__char_declare_cpy_15_bad() { char * data; switch(6) { case 6: data = dataBuffer - 8; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_15.c", "text": "char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; printLine(\"Benign, fixed string\"); break; default: data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; switch(6) { case 6: data = dataBuffer; break; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_cpy_31.c", "text": "data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_cpy_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: cpy * BadSink : Copy string to data using strcpy * Flow Variant: 31 Data flow using a copy of data within the same function void CWE124_Buffer_Underwrite__char_alloca_cpy_31_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_06.c", "text": "void CWE124_Buffer_Underwrite__char_declare_cpy_06_bad() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_06.c", "text": "* BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: cpy * BadSink : Copy string to data using strcpy #include <wchar.h> void CWE124_Buffer_Underwrite__char_declare_cpy_06_bad() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_cpy_06.c", "text": "} { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source); printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(STATIC_CONST_FIVE==5) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_41.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD void CWE124_Buffer_Underwrite__char_declare_memcpy_41_badSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__char_declare_memcpy_41_bad() { char * data; char dataBuffer[100]; memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE124_Buffer_Underwrite__char_declare_memcpy_41_badSink(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_declare_memcpy_41_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_67b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__char_declare_memcpy_67b_goodG2BSink(CWE124_Buffer_Underwrite__char_declare_memcpy_67_structType myStruct) { char * data = myStruct.structFirst; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_68a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_badSink(); void CWE124_Buffer_Underwrite__CWE839_fscanf_68_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_68a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_badSink(); void CWE124_Buffer_Underwrite__CWE839_fscanf_68_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_68a.c", "text": "void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_badSink(); void CWE124_Buffer_Underwrite__CWE839_fscanf_68_bad() int data; data = -1; fscanf(stdin, \"%d\", &data); CWE124_Buffer_Underwrite__CWE839_fscanf_68_badData = data; CWE124_Buffer_Underwrite__CWE839_fscanf_68b_badSink(); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_goodG2BSink(); void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_goodB2GSink(); data = 7; CWE124_Buffer_Underwrite__CWE839_fscanf_68_goodG2BData = data; CWE124_Buffer_Underwrite__CWE839_fscanf_68b_goodG2BSink();", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_68a.c", "text": "int CWE124_Buffer_Underwrite__CWE839_fscanf_68_badData; int CWE124_Buffer_Underwrite__CWE839_fscanf_68_goodG2BData; int CWE124_Buffer_Underwrite__CWE839_fscanf_68_goodB2GData; #ifndef OMITBAD void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_badSink(); void CWE124_Buffer_Underwrite__CWE839_fscanf_68_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data); CWE124_Buffer_Underwrite__CWE839_fscanf_68_badData = data; CWE124_Buffer_Underwrite__CWE839_fscanf_68b_badSink(); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_goodG2BSink(); void CWE124_Buffer_Underwrite__CWE839_fscanf_68b_goodB2GSink(); static void goodG2B() { int data; data = -1; data = 7; CWE124_Buffer_Underwrite__CWE839_fscanf_68_goodG2BData = data; CWE124_Buffer_Underwrite__CWE839_fscanf_68b_goodG2BSink(); static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_31.c", "text": "* GoodSource: Set data pointer to the allocated memory buffer * Sinks: memmove * BadSink : Copy string to data using memmove * Flow Variant: 31 Data flow using a copy of data within the same function void CWE124_Buffer_Underwrite__char_alloca_memmove_31_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer; { char * dataCopy = data; char * data = dataCopy; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_66b.c", "text": "char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); void CWE124_Buffer_Underwrite__char_declare_memcpy_66b_goodG2BSink(char * dataArray[]) { char * data = dataArray[2]; { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_01.c", "text": "data = -1; fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; static void goodG2B() { int data; data = -1; data = 7; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; static void goodB2G() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memmove_51b.c", "text": "source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_declare_memmove_51b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_65b.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_declare_memcpy_65b_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memmove_11.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memmove * BadSink : Copy string to data using memmove void CWE124_Buffer_Underwrite__char_declare_memmove_11_bad() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memmove_11.c", "text": "memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B2() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrue()) { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_cpy_41.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); void CWE124_Buffer_Underwrite__char_alloca_cpy_41_bad() { char * data; char * dataBuffer = (char *)ALLOCA(100*sizeof(char)); memset(dataBuffer, 'A', 100-1); dataBuffer[100-1] = '\\0'; data = dataBuffer - 8; CWE124_Buffer_Underwrite__char_alloca_cpy_41_badSink(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_alloca_cpy_41_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_53d.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_declare_memcpy_53d_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_12.c", "text": "data = dataBuffer - 8; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_memmove_12.c", "text": "dataBuffer[100-1] = '\\0'; if(globalReturnsTrueOrFalse()) { data = dataBuffer - 8; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); * both branches use the GoodSource */ static void goodG2B() { char * data; dataBuffer[100-1] = '\\0'; if(globalReturnsTrueOrFalse()) { data = dataBuffer; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memmove(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_17.c", "text": "data = -1; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data); int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; static void goodB2G() { int i,k; int data; data = -1; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_13.c", "text": "* @description * CWE: 124 Buffer Underwrite * BadSource: Set data pointer to before the allocated memory buffer * GoodSource: Set data pointer to the allocated memory buffer * Sink: memcpy * BadSink : Copy string to data using memcpy void CWE124_Buffer_Underwrite__char_declare_memcpy_13_bad() { char * data; dataBuffer[100-1] = '\\0'; if(GLOBAL_CONST_FIVE==5) { data = dataBuffer - 8; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); static void goodG2B1() { char * data; } else { data = dataBuffer; } { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_declare_memcpy_54e.c", "text": "source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char)); data[100-1] = '\\0'; printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_declare_memcpy_54e_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; memcpy(data, source, 100*sizeof(char));", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__char_alloca_cpy_52c.c", "text": "source[100-1] = '\\0'; strcpy(data, source); printLine(data); #ifndef OMITGOOD void CWE124_Buffer_Underwrite__char_alloca_cpy_52c_goodG2BSink(char * data) { { char source[100]; memset(source, 'C', 100-1); source[100-1] = '\\0'; strcpy(data, source);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE124_Buffer_Underwrite/s01/CWE124_Buffer_Underwrite__CWE839_fscanf_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE124_Buffer_Underwrite__CWE839_fscanf_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_83_goodG2B.cpp", "text": "data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_44.c", "text": "* @description * CWE: 401 Memory Leak * BadSource: Allocate data using strdup() * GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) void CWE401_Memory_Leak__strdup_char_44_bad() { char * data; void (*funcPtr) (char *) = badSink; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_34.c", "text": "data = strdup(myString); printLine(data); } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; static void goodG2B() { char * data; CWE401_Memory_Leak__strdup_char_34_unionType myUnion; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s02/CWE401_Memory_Leak__strdup_char_22a.c", "text": "static void goodB2G1() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); } CWE401_Memory_Leak__strdup_char_22_goodB2G1Global = 0; CWE401_Memory_Leak__strdup_char_22_goodB2G1Sink(data); } void CWE401_Memory_Leak__strdup_char_22_goodB2G2Sink(char * data); static void goodB2G2() { char * data; data = NULL; { char myString[] = \"myString\"; data = strdup(myString); printLine(data); } CWE401_Memory_Leak__strdup_char_22_goodB2G2Global = 1; CWE401_Memory_Leak__strdup_char_22_goodB2G2Sink(data); } void CWE401_Memory_Leak__strdup_char_22_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"a string\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_01.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() void CWE401_Memory_Leak__malloc_realloc_char_01_bad() { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_01.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() void CWE401_Memory_Leak__malloc_realloc_char_01_bad() { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_01.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() void CWE401_Memory_Leak__malloc_realloc_char_01_bad() { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); static void good1() { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_01.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() void CWE401_Memory_Leak__malloc_realloc_char_01_bad() { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); static void good1() { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_32.cpp", "text": "data = new char[100]; strcpy(data, \"A String\"); printLine(data); *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; char dataGoodBuffer[100]; data = dataGoodBuffer; strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_32.cpp", "text": "data = new char[100]; strcpy(data, \"A String\"); printLine(data); *dataPtr1 = data; } { char * data = *dataPtr2; static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; char dataGoodBuffer[100]; data = dataGoodBuffer; strcpy(data, \"A String\"); printLine(data); *dataPtr1 = data; } { char * data = *dataPtr2; static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; data = NULL; { char * data = *dataPtr1; data = new char[100]; strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_10.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_10.c", "text": "void CWE401_Memory_Leak__char_realloc_10_bad() { char * data; data = NULL; if(globalTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_10.c", "text": "static void goodB2G1() { char * data; data = NULL; if(globalTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalTrue) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_10.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalTrue) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(globalTrue) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_62b.cpp", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); #ifndef OMITGOOD void goodG2BSource(char * &data) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_62b.cpp", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); #ifndef OMITGOOD void goodG2BSource(char * &data) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); } void goodB2GSource(char * &data) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_03.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(5==5) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_03.c", "text": "void CWE401_Memory_Leak__char_realloc_03_bad() { char * data; data = NULL; if(5==5) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(5==5) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(5==5) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_03.c", "text": "static void goodB2G1() { char * data; data = NULL; if(5==5) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(5==5) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(5==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_03.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(5==5) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(5==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(5==5) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_16.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() while(1) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_16.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() while(1) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_16.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() while(1) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); while(1) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_16.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() while(1) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); while(1) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_44.cpp", "text": "void (*funcPtr) (char *) = badSink; data = NULL; data = new char[100]; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_44.cpp", "text": "* @description * CWE: 401 Memory Leak * BadSource: Allocate data using new[] * GoodSource: Point data to a stack buffer * Sinks: * GoodSink: call delete[] on data * BadSink : no deallocation of data * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) void bad() { char * data; void (*funcPtr) (char *) = badSink; data = NULL; data = new char[100]; strcpy(data, \"A String\"); printLine(data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; data = NULL; char dataGoodBuffer[100]; data = dataGoodBuffer; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_44.cpp", "text": "data = new char[100]; strcpy(data, \"A String\"); printLine(data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; data = NULL; char dataGoodBuffer[100]; data = dataGoodBuffer; strcpy(data, \"A String\"); printLine(data); funcPtr(data); } static void goodB2GSink(char * data) { delete[] data; static void goodB2G() { char * data; void (*funcPtr) (char *) = goodB2GSink; data = NULL; data = new char[100]; strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_33.cpp", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); { char * data = dataRef; static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_33.cpp", "text": "* Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function void bad() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); { char * data = dataRef; static void goodG2B() { char * data; char * &dataRef = data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); { char * data = dataRef; static void goodB2G() { char * data; char * &dataRef = data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_18.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G() { char * data; data = NULL; goto source; source: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_18.c", "text": "void CWE401_Memory_Leak__char_malloc_18_bad() { char * data; data = NULL; goto source; source: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G() { char * data; data = NULL; goto source; source: data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); goto sink; sink: free(data); static void goodG2B() { char * data; data = NULL; goto source; source: data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_03.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(5==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_03.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(5==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_03.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(5==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_03.c", "text": "* @description * CWE: 401 Memory Leak * Sinks: * GoodSink: Ensure the memory block pointed to by data is always freed * BadSink : malloc() and use then realloc() and use data before free() if(5==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_03.c", "text": "char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); data = (char *)realloc(data, (130000)*sizeof(char)); if (data != NULL) { strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\"); printLine(data); } free(data); if(5==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__malloc_realloc_char_03.c", "text": "strcpy(data, \"New String\"); printLine(data); free(data); else { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\"); printLine(data); } free(data); if(5==5) { { char * data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} char * tmpData; strcpy(data, \"A String\"); printLine(data); tmpData = (char *)realloc(data, (130000)*sizeof(char)); if (tmpData != NULL) { data = tmpData; strcpy(data, \"New String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__destructor_01_bad.cpp", "text": "class BadClass { public: BadClass(const char * name) { if (name) { this->name = new char[strlen(name) + 1]; strcpy(this->name, name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__destructor_01_bad.cpp", "text": "class BadClass { public: BadClass(const char * name) { if (name) { this->name = new char[strlen(name) + 1]; strcpy(this->name, name); } else { this->name = new char[1]; *(this->name) = '\\0'; } BadClass(BadClass &badClassObject) { this->name = new char[strlen(badClassObject.name) + 1]; strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__destructor_01_bad.cpp", "text": "class BadClass { public: BadClass(const char * name) { if (name) { this->name = new char[strlen(name) + 1]; strcpy(this->name, name); } else { this->name = new char[1]; *(this->name) = '\\0'; } BadClass(BadClass &badClassObject) { this->name = new char[strlen(badClassObject.name) + 1]; strcpy(this->name, badClassObject.name); } BadClass& operator=(const BadClass &badClassObject) { if (&badClassObject != this) { this->name = new char[strlen(badClassObject.name) + 1]; strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_68a.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_68_badData = data; static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_68a.c", "text": "* @description * CWE: 401 Memory Leak * BadSource: realloc Allocate data using realloc() * GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files void CWE401_Memory_Leak__char_realloc_68_bad() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_68_badData = data; static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_68_goodG2BData = data; static void goodB2G() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_66a.cpp", "text": "data = new char[100]; strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; data = NULL; char dataGoodBuffer[100]; data = dataGoodBuffer; strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__new_array_char_66a.cpp", "text": "* GoodSource: Point data to a stack buffer * Sinks: * GoodSink: call delete[] on data * BadSink : no deallocation of data * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void bad() { char * data; char * dataArray[5]; data = NULL; data = new char[100]; strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; data = NULL; char dataGoodBuffer[100]; data = dataGoodBuffer; strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodB2G() { char * data; char * dataArray[5]; data = NULL; data = new char[100]; strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_45.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_45_badData = data; static void goodG2BSink() { char * data = CWE401_Memory_Leak__char_realloc_45_goodG2BData; static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_45.c", "text": "void CWE401_Memory_Leak__char_realloc_45_bad() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_45_badData = data; static void goodG2BSink() { char * data = CWE401_Memory_Leak__char_realloc_45_goodG2BData; static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_realloc_45_goodG2BData = data; static void goodB2GSink() { char * data = CWE401_Memory_Leak__char_realloc_45_goodB2GData; free(data); static void goodB2G() { char * data; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_65a.c", "text": "void CWE401_Memory_Leak__char_calloc_65b_badSink(char * data); void CWE401_Memory_Leak__char_calloc_65_bad() { char * data; void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_badSink; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_65a.c", "text": "* @description * CWE: 401 Memory Leak * BadSource: calloc Allocate data using calloc() * GoodSource: Allocate data on the stack * Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE401_Memory_Leak__char_calloc_65b_badSink(char * data); void CWE401_Memory_Leak__char_calloc_65_bad() { char * data; void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_badSink; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); funcPtr(data); #ifndef OMITGOOD void CWE401_Memory_Leak__char_calloc_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_goodG2BSink; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_65a.c", "text": "void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_badSink; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); funcPtr(data); #ifndef OMITGOOD void CWE401_Memory_Leak__char_calloc_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_goodG2BSink; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); funcPtr(data); } void CWE401_Memory_Leak__char_calloc_65b_goodB2GSink(char * data); static void goodB2G() { char * data; void (*funcPtr) (char *) = CWE401_Memory_Leak__char_calloc_65b_goodB2GSink; data = NULL; data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_05.c", "text": "void CWE401_Memory_Leak__char_realloc_05_bad() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_05.c", "text": "void CWE401_Memory_Leak__char_realloc_05_bad() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_05.c", "text": "void CWE401_Memory_Leak__char_realloc_05_bad() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_05.c", "text": "static void goodB2G1() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(staticTrue) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_05.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(staticTrue) { data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(staticTrue) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(staticTrue) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_14.c", "text": "data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_14.c", "text": "void CWE401_Memory_Leak__char_malloc_14_bad() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_14.c", "text": "static void goodB2G1() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_14.c", "text": "else { free(data); static void goodB2G2() { char * data; data = NULL; if(globalFive==5) { data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); if(globalFive==5) { free(data); static void goodG2B1() { char * data; data = NULL; else { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; if(globalFive==5) { data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_53a.c", "text": "void CWE401_Memory_Leak__char_malloc_53b_badSink(char * data); void CWE401_Memory_Leak__char_malloc_53_bad() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_53a.c", "text": "void CWE401_Memory_Leak__char_malloc_53b_badSink(char * data); void CWE401_Memory_Leak__char_malloc_53_bad() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_malloc_53b_badSink(data); #ifndef OMITGOOD void CWE401_Memory_Leak__char_malloc_53b_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_malloc_53a.c", "text": "void CWE401_Memory_Leak__char_malloc_53_bad() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_malloc_53b_badSink(data); #ifndef OMITGOOD void CWE401_Memory_Leak__char_malloc_53b_goodG2BSink(char * data); static void goodG2B() { char * data; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); CWE401_Memory_Leak__char_malloc_53b_goodG2BSink(data); } void CWE401_Memory_Leak__char_malloc_53b_goodB2GSink(char * data); static void goodB2G() { char * data; data = NULL; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_66a.c", "text": "data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_realloc_66a.c", "text": "* Sinks: * GoodSink: call free() on data * BadSink : no deallocation of data * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files void CWE401_Memory_Leak__char_realloc_66_bad() { char * data; char * dataArray[5]; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodG2B() { char * data; char * dataArray[5]; data = NULL; data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); dataArray[2] = data; static void goodB2G() { char * data; char * dataArray[5]; data = NULL; data = (char *)realloc(data, 100*sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_15.c", "text": "data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; { case 6: data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_15.c", "text": "void CWE401_Memory_Leak__char_calloc_15_bad() { char * data; data = NULL; { case 6: data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); static void goodB2G1() { char * data; data = NULL; { case 6: data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); break; default: free(data); static void goodB2G2() { char * data; data = NULL; { case 6: data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_15.c", "text": "static void goodB2G1() { char * data; data = NULL; { case 6: data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); break; default: free(data); static void goodB2G2() { char * data; data = NULL; { case 6: data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); { case 7: free(data); static void goodG2B1() { char * data; data = NULL; break; default: data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE401_Memory_Leak/s01/CWE401_Memory_Leak__char_calloc_15.c", "text": "break; default: free(data); static void goodB2G2() { char * data; data = NULL; { case 6: data = (char *)calloc(100, sizeof(char)); if (data == NULL) {exit(-1);} strcpy(data, \"A String\"); printLine(data); { case 7: free(data); static void goodG2B1() { char * data; data = NULL; break; default: data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\"); printLine(data); static void goodG2B2() { char * data; data = NULL; { case 6: data = (char *)ALLOCA(100*sizeof(char)); strcpy(data, \"A String\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_11.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_console_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_11.c", "text": "int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_11.c", "text": "if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_11.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_11.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { strcpy(data, \"15\"); if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_11.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_11.c", "text": "dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_67a.c", "text": "char * data; CWE606_Unchecked_Loop_Condition__char_environment_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE606_Unchecked_Loop_Condition__char_environment_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); myStruct.structFirst = data; static void goodB2G() { char * data; CWE606_Unchecked_Loop_Condition__char_environment_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_67a.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE606_Unchecked_Loop_Condition__char_environment_67_bad() { char * data; CWE606_Unchecked_Loop_Condition__char_environment_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE606_Unchecked_Loop_Condition__char_environment_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE606_Unchecked_Loop_Condition__char_environment_09_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(GLOBAL_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(GLOBAL_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(GLOBAL_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(GLOBAL_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(GLOBAL_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(GLOBAL_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcpy(data, \"15\"); if(GLOBAL_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE606_Unchecked_Loop_Condition__char_environment_09_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "{ { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_09.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_63a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE606_Unchecked_Loop_Condition__char_environment_63b_badSink(&data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_environment_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); CWE606_Unchecked_Loop_Condition__char_environment_63b_goodG2BSink(&data); } void CWE606_Unchecked_Loop_Condition__char_environment_63b_goodB2GSink(char * * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_63a.c", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE606_Unchecked_Loop_Condition__char_environment_63_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE606_Unchecked_Loop_Condition__char_environment_63b_badSink(&data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_environment_63b_goodG2BSink(char * * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_54a.c", "text": "void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_54b_badSink(wchar_t * data); void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_54_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_54a.c", "text": "{ wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_54b_goodG2BSink(data); } void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_54b_goodB2GSink(wchar_t * data); static void goodB2G() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_52a.c", "text": "void CWE606_Unchecked_Loop_Condition__char_listen_socket_52b_badSink(char * data); void CWE606_Unchecked_Loop_Condition__char_listen_socket_52_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_52a.c", "text": "#ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_listen_socket_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); CWE606_Unchecked_Loop_Condition__char_listen_socket_52b_goodG2BSink(data); } void CWE606_Unchecked_Loop_Condition__char_listen_socket_52b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_52a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE606_Unchecked_Loop_Condition__char_listen_socket_52b_badSink(data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_listen_socket_52b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_31.c", "text": "void CWE606_Unchecked_Loop_Condition__char_listen_socket_31_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_31.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); { char * dataCopy = data; char * data = dataCopy; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_31.c", "text": "static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_31.c", "text": "char * data = dataCopy; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); { char * dataCopy = data; char * data = dataCopy; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_31.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } { char * dataCopy = data; char * data = dataCopy; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_65a.c", "text": "void (*funcPtr) (char *) = CWE606_Unchecked_Loop_Condition__char_console_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_console_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE606_Unchecked_Loop_Condition__char_console_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_32.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE606_Unchecked_Loop_Condition__char_environment_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_32.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"15\"); *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_32.c", "text": "*dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_32.c", "text": "char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"15\"); *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_32.c", "text": "#ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv void CWE606_Unchecked_Loop_Condition__char_environment_32_bad() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } *dataPtr1 = data; } { char * data = *dataPtr2; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char * *dataPtr1 = &data; char * *dataPtr2 = &data; char dataBuffer[100] = \"\"; data = dataBuffer; { char * data = *dataPtr1; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_44.c", "text": "/* * @description * CWE: 606 Unchecked Input For Loop Condition * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_44.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_44.c", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) void CWE606_Unchecked_Loop_Condition__char_connect_socket_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_44.c", "text": "data = dataBuffer; strcpy(data, \"15\"); funcPtr(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; void (*funcPtr) (char *) = goodB2GSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_44.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_62b.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_04.c", "text": "void CWE606_Unchecked_Loop_Condition__char_connect_socket_04_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(STATIC_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_04.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(STATIC_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_04.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(STATIC_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(STATIC_CONST_TRUE) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_04.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_TRUE) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_44.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_44.c", "text": "#ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_environment_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_44.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); funcPtr(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_44.c", "text": "void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_44.c", "text": "#ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); funcPtr(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; void (*funcPtr) (char *) = goodB2GSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_44.c", "text": "{ { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) void CWE606_Unchecked_Loop_Condition__char_environment_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_73a.cpp", "text": "char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataList.push_back(data); dataList.push_back(data); dataList.push_back(data); static void goodG2B() { char * data; list<char *> dataList; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_42.c", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE606_Unchecked_Loop_Condition__char_file_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_42.c", "text": "{ printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE606_Unchecked_Loop_Condition__char_file_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcpy(data, \"15\"); return data; static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = goodG2BSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_42.c", "text": "int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { } static char * goodB2GSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = goodB2GSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_42.c", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } return data; void CWE606_Unchecked_Loop_Condition__char_file_42_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; data = badSource(data); { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) #ifndef OMITGOOD static char * goodG2BSource(char * data) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_05.c", "text": "void CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_05_bad() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_82_bad.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer namespace CWE606_Unchecked_Loop_Condition__char_console_82 { void CWE606_Unchecked_Loop_Condition__char_console_82_bad::action(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_13.c", "text": "void CWE606_Unchecked_Loop_Condition__char_connect_socket_13_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(GLOBAL_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_13.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(GLOBAL_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_13.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(GLOBAL_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(GLOBAL_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_13.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_03.c", "text": "void CWE606_Unchecked_Loop_Condition__char_connect_socket_03_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(5==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_03.c", "text": "static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(5==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_03.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(5==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(5==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_03.c", "text": "* less char than is in the recv_buf in order to append a terminator */ recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(5==5) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_84_bad.cpp", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE606_Unchecked_Loop_Condition__char_listen_socket_84_bad::CWE606_Unchecked_Loop_Condition__char_listen_socket_84_bad(char * dataCopy) { data = dataCopy; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); CWE606_Unchecked_Loop_Condition__char_listen_socket_84_bad::~CWE606_Unchecked_Loop_Condition__char_listen_socket_84_bad() { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_72a.cpp", "text": "char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { char * data; vector<char *> dataVector; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_34.c", "text": "static void goodG2B() { wchar_t * data; CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_34_unionType myUnion; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); myUnion.unionFirst = data; { wchar_t * data = myUnion.unionSecond; { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) static void goodB2G() { wchar_t * data; CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_34_unionType myUnion; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_67b.c", "text": "/* * @description * CWE: 606 Unchecked Input For Loop Condition * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files void CWE606_Unchecked_Loop_Condition__char_connect_socket_67b_badSink(CWE606_Unchecked_Loop_Condition__char_connect_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_67b.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_connect_socket_67b_goodG2BSink(CWE606_Unchecked_Loop_Condition__char_connect_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_67b.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_connect_socket_67b_goodG2BSink(CWE606_Unchecked_Loop_Condition__char_connect_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_connect_socket_67b_goodB2GSink(CWE606_Unchecked_Loop_Condition__char_connect_socket_67_structType myStruct) { char * data = myStruct.structFirst; { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_44.c", "text": "* BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(wchar_t * data) { { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) void CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_44_bad() { wchar_t * data; void (*funcPtr) (wchar_t *) = badSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_44.c", "text": "wchar_t * data; void (*funcPtr) (wchar_t *) = goodG2BSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; wcscpy(data, L\"15\"); funcPtr(data); } static void goodB2GSink(wchar_t * data) { { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) static void goodB2G() { wchar_t * data; void (*funcPtr) (wchar_t *) = goodB2GSink; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_17.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_console_17_bad() { int i,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; for(j = 0; j < 1; j++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_17.c", "text": "int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G() { int i,k; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; for(k = 0; k < 1; k++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_17.c", "text": "{ dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; for(k = 0; k < 1; k++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { int h,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(h = 0; h < 1; h++) { strcpy(data, \"15\"); for(j = 0; j < 1; j++) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_17.c", "text": "static void goodB2G() { int i,k; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { int h,j; char * data; char dataBuffer[100] = \"\"; data = dataBuffer; for(h = 0; h < 1; h++) { strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcpy(data, \"15\"); if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcpy(data, \"15\"); if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrueOrFalse()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "} if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) use the GoodSink */ static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_listen_socket_12_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } else { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c", "text": "} wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) use the BadSink */ static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { strcpy(data, \"15\"); } else { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_82a.cpp", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 82 Data flow: data passed in a parameter to an virtual method called via a pointer void bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } CWE606_Unchecked_Loop_Condition__char_console_82_base* baseObject = new CWE606_Unchecked_Loop_Condition__char_console_82_bad; baseObject->action(data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_65a.c", "text": "void CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_badSink(char * data); void CWE606_Unchecked_Loop_Condition__char_listen_socket_65_bad() { char * data; void (*funcPtr) (char *) = CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_badSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_65a.c", "text": "#ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); funcPtr(data); } void CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_goodB2GSink(char * data); static void goodB2G() { char * data; void (*funcPtr) (char *) = CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_goodB2GSink; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_65a.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #endif } funcPtr(data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_goodG2BSink(char * data); static void goodG2B() { char * data; void (*funcPtr) (char *) = CWE606_Unchecked_Loop_Condition__char_listen_socket_65b_goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_43.cpp", "text": "badSource(data); { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) #ifndef OMITGOOD static void goodG2BSource(wchar_t * &data) { wcscpy(data, L\"15\"); static void goodG2B() { wchar_t * data; wchar_t dataBuffer[100] = L\"\"; data = dataBuffer; goodG2BSource(data); { int i, n, intVariable; if (swscanf(data, L\"%d\", &n) == 1) } static void goodB2GSource(wchar_t * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; wchar_t *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = wcslen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_41.c", "text": "/* * @description * CWE: 606 Unchecked Input For Loop Condition * BadSource: listen_socket Read data using a listen socket (server side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_41.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_41.c", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); goodG2BSink(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_41.c", "text": "static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); goodG2BSink(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_41.c", "text": "char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "* BadSource: environment Read input from an environment variable * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(STATIC_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(STATIC_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(STATIC_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); if(STATIC_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(STATIC_CONST_FIVE==5) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "#endif size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "{ { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_06.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_21.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size static int badStatic = 0; static void badSink(char * data) if(badStatic) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_21.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { void CWE606_Unchecked_Loop_Condition__char_console_21_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } badStatic = 1; badSink(data); static int goodG2BStatic = 0; static void goodB2G1Sink(char * data) else { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_21.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } goodB2G1Static = 0; goodB2G1Sink(data); } static void goodB2G2Sink(char * data) if(goodB2G2Static) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_21.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } goodB2G2Static = 1; goodB2G2Sink(data); } static void goodG2BSink(char * data) if(goodG2BStatic) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_21.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } goodB2G2Static = 1; goodB2G2Sink(data); } static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_62b.cpp", "text": "* BadSource: file Read input from a file * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; #ifndef OMITGOOD void goodG2BSource(char * &data) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_51a.c", "text": "void CWE606_Unchecked_Loop_Condition__char_connect_socket_51b_badSink(char * data); void CWE606_Unchecked_Loop_Condition__char_connect_socket_51_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_51a.c", "text": "{ char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); CWE606_Unchecked_Loop_Condition__char_connect_socket_51b_goodG2BSink(data); } void CWE606_Unchecked_Loop_Condition__char_connect_socket_51b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_51a.c", "text": "struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } CWE606_Unchecked_Loop_Condition__char_connect_socket_51b_badSink(data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_connect_socket_51b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_84_bad.cpp", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 84 Data flow: data passed to class constructor and destructor by declaring the class object on the heap and deleting it after use { CWE606_Unchecked_Loop_Condition__char_console_84_bad::CWE606_Unchecked_Loop_Condition__char_console_84_bad(char * dataCopy) { data = dataCopy; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; CWE606_Unchecked_Loop_Condition__char_console_84_bad::~CWE606_Unchecked_Loop_Condition__char_console_84_bad() { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_41.c", "text": "/* * @description * CWE: 606 Unchecked Input For Loop Condition * BadSource: connect_socket Read data using a connect socket (client side) * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_41.c", "text": "WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_41.c", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 41 Data flow: data passed as an argument from one function to another in the same source file #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) void CWE606_Unchecked_Loop_Condition__char_connect_socket_41_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_41.c", "text": "data = dataBuffer; strcpy(data, \"15\"); goodG2BSink(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_connect_socket_41.c", "text": "} wsaDataInit = 1; #endif { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); } #endif } badSink(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_54a.c", "text": "void CWE606_Unchecked_Loop_Condition__char_environment_54b_badSink(char * data); void CWE606_Unchecked_Loop_Condition__char_environment_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_54a.c", "text": "size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE606_Unchecked_Loop_Condition__char_environment_54b_badSink(data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_environment_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); CWE606_Unchecked_Loop_Condition__char_environment_54b_goodG2BSink(data); } void CWE606_Unchecked_Loop_Condition__char_environment_54b_goodB2GSink(char * data); static void goodB2G() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_environment_54a.c", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #define ENV_VARIABLE \"ADD\" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #ifndef OMITBAD void CWE606_Unchecked_Loop_Condition__char_environment_54b_badSink(char * data); void CWE606_Unchecked_Loop_Condition__char_environment_54_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, 100-dataLen-1); } } CWE606_Unchecked_Loop_Condition__char_environment_54b_badSink(data); #ifndef OMITGOOD void CWE606_Unchecked_Loop_Condition__char_environment_54b_goodG2BSink(char * data); static void goodG2B() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_11.c", "text": "* GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size void CWE606_Unchecked_Loop_Condition__char_listen_socket_11_bad() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_11.c", "text": "intVariable = 0; for (i = 0; i < n; i++) { static void goodB2G2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_11.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { if (n < MAX_LOOP) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); if(globalReturnsTrue()) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_11.c", "text": "} recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B1() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; } else { strcpy(data, \"15\"); { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B2() { char * data; char dataBuffer[100] = \"\"; data = dataBuffer; if(globalReturnsTrue()) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_67a.c", "text": "void CWE606_Unchecked_Loop_Condition__char_console_67_bad() { char * data; CWE606_Unchecked_Loop_Condition__char_console_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } myStruct.structFirst = data; static void goodG2B() { char * data; CWE606_Unchecked_Loop_Condition__char_console_67_structType myStruct; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_file_74a.cpp", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files void bad() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; pFile = fopen(FILENAME, \"r\"); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } } dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { char * data; map<int, char *> dataMap; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_44.c", "text": "* BadSource: console Read input from the console * GoodSource: Input a number less than MAX_LOOP * Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer #ifndef OMITBAD static void badSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_44.c", "text": "void CWE606_Unchecked_Loop_Condition__char_console_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = \"\"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 1}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_44.c", "text": "else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\"); funcPtr(data); } static void goodB2GSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1)", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_console_44.c", "text": "{ size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\\n') { data[dataLen-1] = '\\0'; } else { printLine(\"fgets() failed\"); data[dataLen] = '\\0'; } } funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(char * data) { { int i, n, intVariable; if (sscanf(data, \"%d\", &n) == 1) static void goodG2B() { char * data; void (*funcPtr) (char *) = goodG2BSink; char dataBuffer[100] = \"\"; data = dataBuffer; strcpy(data, \"15\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_62b.cpp", "text": "data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); #ifndef OMITGOOD void goodG2BSource(char * &data) { strcpy(data, \"15\"); } void goodB2GSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE606_Unchecked_Loop_Condition/CWE606_Unchecked_Loop_Condition__char_listen_socket_62b.cpp", "text": "* Sinks: * GoodSink: Use data as the for loop variant after checking to see if it is less than MAX_LOOP * BadSink : Use data as the for loop variant without checking its size * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #ifndef OMITBAD void badSource(char * &data) WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); } wsaDataInit = 1; #endif break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) break; } data[dataLen + recvResult / sizeof(char)] = '\\0'; replace = strchr(data, '\\r'); { *replace = '\\0'; } replace = strchr(data, '\\n'); #ifndef OMITGOOD void goodG2BSource(char * &data) { strcpy(data, \"15\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_14.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_predec_14_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_14.c", "text": "fscanf (stdin, \"%c\", &data); if(globalFive==5) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_14.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_14_bad() { char data; data = ' '; if(globalFive==5) { fscanf (stdin, \"%c\", &data); if(globalFive==5) { { --data; char result = data; static void goodB2G1() { char data; data = ' '; if(globalFive==5) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { --data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_52a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_52b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_predec_52_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_52a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_predec_52b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_predec_52_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_predec_52b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_predec_52b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_predec_52b_goodG2BSink(data); } void CWE191_Integer_Underflow__char_fscanf_predec_52b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_34.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); static void goodG2B() { int data; CWE191_Integer_Underflow__int_fscanf_predec_34_unionType myUnion; static void goodB2G() { int data; CWE191_Integer_Underflow__int_fscanf_predec_34_unionType myUnion;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_34.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_34_bad() { int data; CWE191_Integer_Underflow__int_fscanf_predec_34_unionType myUnion; data = 0; fscanf(stdin, \"%d\", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { --data; int result = data; static void goodG2B() { int data; CWE191_Integer_Underflow__int_fscanf_predec_34_unionType myUnion; data = 0; data = -2; myUnion.unionFirst = data; { int data = myUnion.unionSecond; { --data; int result = data; static void goodB2G() { int data; CWE191_Integer_Underflow__int_fscanf_predec_34_unionType myUnion; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_53a.c", "text": "void CWE191_Integer_Underflow__short_fscanf_predec_53b_badSink(short data); void CWE191_Integer_Underflow__short_fscanf_predec_53_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_53a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_53b_badSink(short data); void CWE191_Integer_Underflow__short_fscanf_predec_53_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE191_Integer_Underflow__short_fscanf_predec_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__short_fscanf_predec_53b_goodG2BSink(short data); static void goodG2B() { short data; data = 0; data = -2; CWE191_Integer_Underflow__short_fscanf_predec_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__short_fscanf_predec_53b_goodB2GSink(short data); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_06.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #include \"std_testcase.h\" /* The variable below is declared \"const\", so a tool should be able to identify that reads of this will always give its initialized #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_06_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_06.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(STATIC_CONST_FIVE==5) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_06.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_predec_06_bad() { int64_t data; data = 0LL; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); if(STATIC_CONST_FIVE==5) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; if(STATIC_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { --data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_45.c", "text": "--data; int result = data; } } void CWE191_Integer_Underflow__int_fscanf_predec_45_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_45.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_predec_45_badData = data; static void goodG2BSink() { int data = CWE191_Integer_Underflow__int_fscanf_predec_45_goodG2BData; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_predec_45_goodG2BData = data; static void goodB2GSink() { int data = CWE191_Integer_Underflow__int_fscanf_predec_45_goodB2GData;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_45.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_predec_45_badData = data; static void goodG2BSink() { int data = CWE191_Integer_Underflow__int_fscanf_predec_45_goodG2BData; { --data; int result = data; static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_predec_45_goodG2BData = data; static void goodB2GSink() { int data = CWE191_Integer_Underflow__int_fscanf_predec_45_goodB2GData; if (data > INT_MIN) { --data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_42.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static int64_t badSource(int64_t data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_42.c", "text": "#ifndef OMITBAD static int64_t badSource(int64_t data) { fscanf (stdin, \"%\" SCNd64, &data); return data; } void CWE191_Integer_Underflow__int64_t_fscanf_predec_42_bad() { int64_t data; data = 0LL; data = badSource(data); { --data; int64_t result = data; #ifndef OMITGOOD static int64_t goodG2BSource(int64_t data) { data = -2; return data; static void goodG2B() { int64_t data; data = 0LL; data = goodG2BSource(data); { --data; int64_t result = data; } static int64_t goodB2GSource(int64_t data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_53a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_53b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_predec_53_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_53a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_predec_53b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_predec_53_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_predec_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_predec_53b_goodG2BSink(char data); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_predec_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__char_fscanf_predec_53b_goodB2GSink(char data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_02.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_02_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_02.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(1) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_02.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_predec_02_bad() { int64_t data; data = 0LL; if(1) { fscanf (stdin, \"%\" SCNd64, &data); if(1) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; if(1) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { --data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_11.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_11.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_11.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_11_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_11.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(globalReturnsTrue()) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_11.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_predec_11_bad() { int64_t data; data = 0LL; if(globalReturnsTrue()) { fscanf (stdin, \"%\" SCNd64, &data); if(globalReturnsTrue()) { { --data; int64_t result = data; static void goodB2G1() { int64_t data; data = 0LL; if(globalReturnsTrue()) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { --data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_66b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_66b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_02.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_02_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_02.c", "text": "fscanf (stdin, \"%hd\", &data); if(1) { { --data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_02.c", "text": "void CWE191_Integer_Underflow__short_fscanf_predec_02_bad() { short data; data = 0; if(1) { fscanf (stdin, \"%hd\", &data); if(1) { { --data; short result = data; static void goodB2G1() { short data; data = 0; if(1) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { --data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_18.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_18.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_18.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_18_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_18.c", "text": "fscanf (stdin, \"%hd\", &data); goto sink; sink: { --data; short result = data; static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_22b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_22b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_54e.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_54e.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_41.c", "text": "--data; int64_t result = data; } } void CWE191_Integer_Underflow__int64_t_fscanf_predec_41_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_41.c", "text": "data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(int64_t data) { { --data; int64_t result = data; static void goodG2B() { int64_t data; data = 0LL; data = -2; goodG2BSink(data); } static void goodB2GSink(int64_t data) { if (data > LLONG_MIN) { --data; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badGlobal = 1; CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badSink(data); #ifndef OMITGOOD int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G1Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G2Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodG2BGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G1Sink(int64_t data); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badGlobal = 1; CWE191_Integer_Underflow__int64_t_fscanf_predec_22_badSink(data); #ifndef OMITGOOD int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G1Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G2Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodG2BGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G1Sink(int64_t data); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G1Global = 0; CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G1Sink(data); } void CWE191_Integer_Underflow__int64_t_fscanf_predec_22_goodB2G2Sink(int64_t data); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12.c", "text": "* GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12_bad() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { --data; unsigned int result = data; else { if (data > 0) { --data; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_12_bad() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { --data; unsigned int result = data; else { if (data > 0) { --data; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_06.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_06.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_06.c", "text": "data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_FIVE==5) { { --data; int result = data; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_06.c", "text": "if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); if(STATIC_CONST_FIVE==5) { { --data; int result = data; static void goodB2G1() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data); else { if (data > INT_MIN) { --data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_68a.c", "text": "void CWE191_Integer_Underflow__short_fscanf_predec_68b_badSink(); void CWE191_Integer_Underflow__short_fscanf_predec_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_68a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" short CWE191_Integer_Underflow__short_fscanf_predec_68_badData; short CWE191_Integer_Underflow__short_fscanf_predec_68_goodG2BData; short CWE191_Integer_Underflow__short_fscanf_predec_68_goodB2GData; #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_68b_badSink(); void CWE191_Integer_Underflow__short_fscanf_predec_68_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); CWE191_Integer_Underflow__short_fscanf_predec_68_badData = data; CWE191_Integer_Underflow__short_fscanf_predec_68b_badSink(); #ifndef OMITGOOD void CWE191_Integer_Underflow__short_fscanf_predec_68b_goodG2BSink(); void CWE191_Integer_Underflow__short_fscanf_predec_68b_goodB2GSink(); static void goodG2B() { short data; data = 0; data = -2; CWE191_Integer_Underflow__short_fscanf_predec_68_goodG2BData = data; CWE191_Integer_Underflow__short_fscanf_predec_68b_goodG2BSink(); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_54a.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_predec_54b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_54_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_54a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_54b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_54_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_predec_54b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int64_t_fscanf_predec_54b_goodG2BSink(int64_t data); static void goodG2B() { int64_t data; data = 0LL; data = -2; CWE191_Integer_Underflow__int64_t_fscanf_predec_54b_goodG2BSink(data); } void CWE191_Integer_Underflow__int64_t_fscanf_predec_54b_goodB2GSink(int64_t data); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_32.c", "text": "int data = *dataPtr1; fscanf(stdin, \"%d\", &data); *dataPtr1 = data; } { int data = *dataPtr2; { --data; int result = data; static void goodG2B() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = 0; { int data = *dataPtr1; data = -2; *dataPtr1 = data; } { int data = *dataPtr2; { --data; int result = data; static void goodB2G() { int data; int *dataPtr1 = &data; int *dataPtr2 = &data; data = 0; { int data = *dataPtr1; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_09.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_09.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_09.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_09_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_09.c", "text": "fscanf (stdin, \"%hd\", &data); if(GLOBAL_CONST_TRUE) { { --data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_09.c", "text": "void CWE191_Integer_Underflow__short_fscanf_predec_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); if(GLOBAL_CONST_TRUE) { { --data; short result = data; static void goodB2G1() { short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { --data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_63a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * dataPtr); void CWE191_Integer_Underflow__int_fscanf_predec_63_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_63a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * dataPtr); void CWE191_Integer_Underflow__int_fscanf_predec_63_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_63a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * dataPtr); void CWE191_Integer_Underflow__int_fscanf_predec_63_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_63b_goodG2BSink(int * data); data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_predec_63b_goodG2BSink(&data); } void CWE191_Integer_Underflow__int_fscanf_predec_63b_goodB2GSink(int * data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_63a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * dataPtr); void CWE191_Integer_Underflow__int_fscanf_predec_63_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_63b_goodG2BSink(int * data); static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_predec_63b_goodG2BSink(&data); } void CWE191_Integer_Underflow__int_fscanf_predec_63b_goodB2GSink(int * data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_65a.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_65_bad() { int64_t data; void (*funcPtr) (int64_t) = CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_badSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_65a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_predec_65_bad() { int64_t data; void (*funcPtr) (int64_t) = CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_badSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); funcPtr(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_goodG2BSink(int64_t data); static void goodG2B() { int64_t data; void (*funcPtr) (int64_t) = CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_goodG2BSink; data = 0LL; data = -2; funcPtr(data); } void CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_goodB2GSink(int64_t data); static void goodB2G() { int64_t data; void (*funcPtr) (int64_t) = CWE191_Integer_Underflow__int64_t_fscanf_predec_65b_goodB2GSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66a.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66b_badSink(unsigned int dataArray[]); void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66_bad() { unsigned int data; unsigned int dataArray[5]; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66b_badSink(unsigned int dataArray[]); void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66_bad() { unsigned int data; unsigned int dataArray[5]; data = 0; fscanf (stdin, \"%u\", &data); dataArray[2] = data; CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66b_badSink(dataArray); #ifndef OMITGOOD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66b_goodG2BSink(unsigned int dataArray[]); static void goodG2B() { unsigned int data; unsigned int dataArray[5]; data = 0; data = -2; dataArray[2] = data; CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66b_goodG2BSink(dataArray); } void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_66b_goodB2GSink(unsigned int dataArray[]); static void goodB2G() { unsigned int data; unsigned int dataArray[5]; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13.c", "text": "fscanf (stdin, \"%u\", &data); if(GLOBAL_CONST_FIVE==5) { { --data; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_13_bad() { unsigned int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%u\", &data); if(GLOBAL_CONST_FIVE==5) { { --data; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { --data; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_66a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_66b_badSink(int dataArray[]); void CWE191_Integer_Underflow__int_fscanf_predec_66_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_66a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_66b_badSink(int dataArray[]); void CWE191_Integer_Underflow__int_fscanf_predec_66_bad() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_66a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_66b_badSink(int dataArray[]); void CWE191_Integer_Underflow__int_fscanf_predec_66_bad() int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE191_Integer_Underflow__int_fscanf_predec_66b_badSink(dataArray); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_66b_goodG2BSink(int dataArray[]); data = -2; dataArray[2] = data; CWE191_Integer_Underflow__int_fscanf_predec_66b_goodG2BSink(dataArray); } void CWE191_Integer_Underflow__int_fscanf_predec_66b_goodB2GSink(int dataArray[]);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_66a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_predec_66b_badSink(int dataArray[]); void CWE191_Integer_Underflow__int_fscanf_predec_66_bad() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data); dataArray[2] = data; CWE191_Integer_Underflow__int_fscanf_predec_66b_badSink(dataArray); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_predec_66b_goodG2BSink(int dataArray[]); static void goodG2B() { int data; int dataArray[5]; data = 0; data = -2; dataArray[2] = data; CWE191_Integer_Underflow__int_fscanf_predec_66b_goodG2BSink(dataArray); } void CWE191_Integer_Underflow__int_fscanf_predec_66b_goodB2GSink(int dataArray[]); static void goodB2G() { int data; int dataArray[5]; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_14.c", "text": "data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data); if(globalFive==5) { { --data; int result = data; static void goodB2G1() { int data; data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_14.c", "text": "if(globalFive==5) { fscanf(stdin, \"%d\", &data); if(globalFive==5) { { --data; int result = data; static void goodB2G1() { int data; data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data); else { if (data > INT_MIN) { --data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { int data; data = 0; if(globalFive==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_64a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__char_fscanf_predec_64_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_64a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_predec_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__char_fscanf_predec_64_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_predec_64b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_predec_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_predec_64b_goodG2BSink(&data); } void CWE191_Integer_Underflow__char_fscanf_predec_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_32.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_predec_32_bad() { int64_t data; int64_t *dataPtr1 = &data; int64_t *dataPtr2 = &data; data = 0LL; { int64_t data = *dataPtr1; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_32.c", "text": "{ int64_t data = *dataPtr1; fscanf (stdin, \"%\" SCNd64, &data); *dataPtr1 = data; } { int64_t data = *dataPtr2; { --data; int64_t result = data; static void goodG2B() { int64_t data; int64_t *dataPtr1 = &data; int64_t *dataPtr2 = &data; data = 0LL; { int64_t data = *dataPtr1; data = -2; *dataPtr1 = data; } { int64_t data = *dataPtr2; { --data; int64_t result = data; static void goodB2G() { int64_t data; int64_t *dataPtr1 = &data; int64_t *dataPtr2 = &data; data = 0LL; { int64_t data = *dataPtr1; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_45.c", "text": "--data; char result = data; } } void CWE191_Integer_Underflow__char_fscanf_predec_45_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_45.c", "text": "void CWE191_Integer_Underflow__char_fscanf_predec_45_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_predec_45_badData = data; static void goodG2BSink() { char data = CWE191_Integer_Underflow__char_fscanf_predec_45_goodG2BData; { --data; char result = data; static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_predec_45_goodG2BData = data; static void goodB2GSink() { char data = CWE191_Integer_Underflow__char_fscanf_predec_45_goodB2GData; if (data > CHAR_MIN) { --data; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int64_t_fscanf_predec_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_predec_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_predec_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_44.c", "text": "--data; int result = data; } } void CWE191_Integer_Underflow__int_fscanf_predec_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__int_fscanf_predec_44.c", "text": "#ifndef OMITGOOD static void goodG2BSink(int data) { { --data; int result = data; static void goodG2B() { int data; void (*funcPtr) (int) = goodG2BSink; data = 0; data = -2; funcPtr(data); } static void goodB2GSink(int data) { if (data > INT_MIN) { --data; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int data; void (*funcPtr) (int) = goodB2GSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__char_fscanf_predec_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_predec_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_predec_14.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_predec_14_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_14.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { --data; short result = data; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s05/CWE191_Integer_Underflow__short_fscanf_predec_14.c", "text": "void CWE191_Integer_Underflow__short_fscanf_predec_14_bad() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); if(globalFive==5) { { --data; short result = data; static void goodB2G1() { short data; data = 0; if(globalFive==5) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { --data; short result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodG2BSink; } void CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodB2GSink;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_65a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_65_bad() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_badSink; data = 0; fscanf(stdin, \"%d\", &data); funcPtr(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodG2BSink(int data); static void goodG2B() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodG2BSink; data = 0; data = -2; funcPtr(data); } void CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodB2GSink(int data); static void goodB2G() { int data; void (*funcPtr) (int) = CWE191_Integer_Underflow__int_fscanf_multiply_65b_goodB2GSink; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_08.c", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(staticReturnsTrue()) { { int result = data - 1; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_08.c", "text": "{ int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); if(staticReturnsTrue()) { { int result = data - 1; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); else { if (data > INT_MIN) { int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_54a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_54a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_54a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_multiply_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_54_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_54a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_multiply_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_54a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_multiply_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_54_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_multiply_54b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_multiply_54b_goodG2BSink(int data); data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_multiply_54b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_multiply_54b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_54a.c", "text": "* Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 54 Data flow: data passed as an argument from one function through three others to a fifth; all five functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int_fscanf_multiply_54b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_multiply_54_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_multiply_54b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_multiply_54b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_multiply_54b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_multiply_54b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_74b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_74b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_62b.cpp", "text": "fscanf(stdin, \"%d\", &data); #ifndef OMITGOOD void goodG2BSource(int &data) { data = -2; } void goodB2GSource(int &data) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_45.c", "text": "int result = data - 1; } } void CWE191_Integer_Underflow__int_fscanf_sub_45_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_45.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data; static void goodG2BSink() { int data = CWE191_Integer_Underflow__int_fscanf_sub_45_goodG2BData; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_sub_45_goodG2BData = data; static void goodB2GSink() { int data = CWE191_Integer_Underflow__int_fscanf_sub_45_goodB2GData;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_45.c", "text": "data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data; static void goodG2BSink() { int data = CWE191_Integer_Underflow__int_fscanf_sub_45_goodG2BData; { int result = data - 1; static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_sub_45_goodG2BData = data; static void goodB2GSink() { int data = CWE191_Integer_Underflow__int_fscanf_sub_45_goodB2GData; if (data > INT_MIN) { int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_17.c", "text": "data = 0; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data); } for(j = 0; j < 1; j++) { if(data < 0) { int result = data * 2; static void goodB2G() { int i,k; int data; data = 0; for(i = 0; i < 1; i++) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_43.cpp", "text": "#ifndef OMITBAD static void badSource(int &data) { fscanf(stdin, \"%d\", &data); void bad() { int data; data = 0; badSource(data); { int result = data - 1; #ifndef OMITGOOD static void goodG2BSource(int &data) { data = -2; static void goodG2B() { int data; data = 0; goodG2BSource(data); { int result = data - 1; } static void goodB2GSource(int &data) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_03.c", "text": "data = 0; if(5==5) { fscanf(stdin, \"%d\", &data); } if(5==5) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(5==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_03.c", "text": "if(5==5) { fscanf(stdin, \"%d\", &data); } if(5==5) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(5==5) { fscanf(stdin, \"%d\", &data); } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { int data; data = 0; if(5==5) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_12.c", "text": "{ int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = -2; } if(globalReturnsTrueOrFalse()) { if(data < 0) { int result = data * 2; } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_12.c", "text": "if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = -2; } if(globalReturnsTrueOrFalse()) { if(data < 0) { int result = data * 2; } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); } else { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_51a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_51a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_51a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_sub_51b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_51_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_51a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_sub_51b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_51a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_sub_51b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_51_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_sub_51b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_sub_51b_goodG2BSink(int data); data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_sub_51b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_sub_51b_goodB2GSink(int data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_51a.c", "text": "* Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int_fscanf_sub_51b_badSink(int data); void CWE191_Integer_Underflow__int_fscanf_sub_51_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_sub_51b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_sub_51b_goodG2BSink(int data); static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_sub_51b_goodG2BSink(data); } void CWE191_Integer_Underflow__int_fscanf_sub_51b_goodB2GSink(int data); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_08.c", "text": "data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); } if(staticReturnsTrue()) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_08.c", "text": "if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); } if(staticReturnsTrue()) { if(data < 0) { int result = data * 2; static void goodB2G1() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data); } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_sub_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_sub_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s02/CWE191_Integer_Underflow__int_fscanf_multiply_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_multiply_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_43.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__unsigned_int_fscanf_sub_43 #ifndef OMITBAD static void badSource(unsigned int &data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_43.cpp", "text": "#include \"std_testcase.h\" namespace CWE191_Integer_Underflow__unsigned_int_fscanf_sub_43 #ifndef OMITBAD static void badSource(unsigned int &data) { fscanf (stdin, \"%u\", &data); void bad() { unsigned int data; data = 0; badSource(data); { unsigned int result = data - 1; #ifndef OMITGOOD static void goodG2BSource(unsigned int &data) { data = -2; static void goodG2B() { unsigned int data; data = 0; goodG2BSource(data); { unsigned int result = data - 1; } static void goodB2GSource(unsigned int &data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_10.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_10_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_10.c", "text": "fscanf (stdin, \"%hd\", &data); if(globalTrue) { { short result = data - 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_10.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, \"%hd\", &data); if(globalTrue) { { short result = data - 1; static void goodB2G1() { short data; data = 0; if(globalTrue) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_82_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_82_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12.c", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12_bad() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { unsigned int result = data - 1; else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); use the GoodSink */ static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12.c", "text": "* GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_12_bad() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { unsigned int result = data - 1; else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); use the GoodSink */ static void goodB2G() { unsigned int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, \"%u\", &data); fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_32.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_32_bad() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_32.c", "text": "short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; fscanf (stdin, \"%hd\", &data); *dataPtr1 = data; } { short data = *dataPtr2; { short result = data - 1; static void goodG2B() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; data = -2; *dataPtr1 = data; } { short data = *dataPtr2; { short result = data - 1; static void goodB2G() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_81_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_81_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53a.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53b_badSink(unsigned int data); void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53b_badSink(unsigned int data); void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53b_goodG2BSink(unsigned int data); static void goodG2B() { unsigned int data; data = 0; data = -2; CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53b_goodB2GSink(unsigned int data); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_73b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_73b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02.c", "text": "fscanf (stdin, \"%u\", &data); if(1) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_02_bad() { unsigned int data; data = 0; if(1) { fscanf (stdin, \"%u\", &data); if(1) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; if(1) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_03.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_03_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_03.c", "text": "fscanf (stdin, \"%hd\", &data); if(5==5) { { short result = data - 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_03.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_03_bad() { short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); if(5==5) { { short result = data - 1; static void goodB2G1() { short data; data = 0; if(5==5) { fscanf (stdin, \"%hd\", &data); else { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_32.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_multiply_32_bad() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_32.c", "text": "{ short data = *dataPtr1; fscanf (stdin, \"%hd\", &data); *dataPtr1 = data; } { short data = *dataPtr2; if(data < 0) { short result = data * 2; static void goodG2B() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; data = -2; *dataPtr1 = data; } { short data = *dataPtr2; if(data < 0) { short result = data * 2; static void goodB2G() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_82_bad.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_82_bad.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10.c", "text": "fscanf (stdin, \"%u\", &data); if(globalTrue) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_10_bad() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); if(globalTrue) { { unsigned int result = data - 1; static void goodB2G1() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_15.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_15_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_15.c", "text": "fscanf (stdin, \"%hd\", &data); { case 7: { short result = data - 1; static void goodB2G1() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_15.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_15_bad() { short data; data = 0; { case 6: fscanf (stdin, \"%hd\", &data); { case 7: { short result = data - 1; static void goodB2G1() { short data; data = 0; { case 6: fscanf (stdin, \"%hd\", &data); break; default: if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_54b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_54b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_multiply_83_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_multiply_83_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_41.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_41.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_41.c", "text": "short result = data - 1; } } void CWE191_Integer_Underflow__short_fscanf_sub_41_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_41.c", "text": "void CWE191_Integer_Underflow__short_fscanf_sub_41_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data); badSink(data); #ifndef OMITGOOD static void goodG2BSink(short data) { { short result = data - 1; static void goodG2B() { short data; data = 0; data = -2; goodG2BSink(data); } static void goodB2GSink(short data) { if (data > SHRT_MIN) { short result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_sub_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_44.c", "text": "unsigned int result = data - 1; } } void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__unsigned_int_fscanf_sub_44.c", "text": "fscanf (stdin, \"%u\", &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(unsigned int data) { { unsigned int result = data - 1; static void goodG2B() { unsigned int data; void (*funcPtr) (unsigned int) = goodG2BSink; data = 0; data = -2; funcPtr(data); } static void goodB2GSink(unsigned int data) { if (data > 0) { unsigned int result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G() { unsigned int data; void (*funcPtr) (unsigned int) = goodB2GSink; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_01.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_01.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_sub_01.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_sub_01_bad() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s03/CWE191_Integer_Underflow__short_fscanf_sub_01.c", "text": "fscanf (stdin, \"%hd\", &data); { short result = data - 1; static void goodG2B() { short data; data = 0; data = -2; { short result = data - 1; static void goodB2G() { short data; data = 0; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_63a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_postdec_63b_badSink(char * dataPtr); void CWE191_Integer_Underflow__char_fscanf_postdec_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_63a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_postdec_63b_badSink(char * dataPtr); void CWE191_Integer_Underflow__char_fscanf_postdec_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_postdec_63b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_postdec_63b_goodG2BSink(char * data); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_postdec_63b_goodG2BSink(&data); } void CWE191_Integer_Underflow__char_fscanf_postdec_63b_goodB2GSink(char * data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_17.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_17.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_17.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_17_bad() { int i,j; unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_17.c", "text": "fscanf (stdin, \"%u\", &data); for(j = 0; j < 1; j++) { { data--; unsigned int result = data; static void goodB2G() { int i,k; unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_45.c", "text": "data--; char result = data; } } void CWE191_Integer_Underflow__char_fscanf_postdec_45_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_45.c", "text": "void CWE191_Integer_Underflow__char_fscanf_postdec_45_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_postdec_45_badData = data; static void goodG2BSink() { char data = CWE191_Integer_Underflow__char_fscanf_postdec_45_goodG2BData; { data--; char result = data; static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_postdec_45_goodG2BData = data; static void goodB2GSink() { char data = CWE191_Integer_Underflow__char_fscanf_postdec_45_goodB2GData; if (data > CHAR_MIN) { data--; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 61 Data flow: data returned from one function to another in different source files #ifndef OMITBAD unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b_badSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b.c", "text": "fscanf (stdin, \"%u\", &data); return data; #ifndef OMITGOOD unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b_goodG2BSource(unsigned int data) { data = -2; return data; } unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_61b_goodB2GSource(unsigned int data) fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_64a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__int_fscanf_postdec_64_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_64a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__int_fscanf_postdec_64_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_64a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__int_fscanf_postdec_64_bad() int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_postdec_64b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_postdec_64b_goodG2BSink(void * dataVoidPtr); data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_postdec_64b_goodG2BSink(&data); } void CWE191_Integer_Underflow__int_fscanf_postdec_64b_goodB2GSink(void * dataVoidPtr);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_64a.c", "text": "* Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int_fscanf_postdec_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__int_fscanf_postdec_64_bad() { int data; data = 0; fscanf(stdin, \"%d\", &data); CWE191_Integer_Underflow__int_fscanf_postdec_64b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_postdec_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { int data; data = 0; data = -2; CWE191_Integer_Underflow__int_fscanf_postdec_64b_goodG2BSink(&data); } void CWE191_Integer_Underflow__int_fscanf_postdec_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { int data; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_15.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_15.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_15.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_postdec_15_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_15.c", "text": "fscanf (stdin, \"%c\", &data); { case 7: { data--; char result = data; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_15.c", "text": "void CWE191_Integer_Underflow__char_fscanf_postdec_15_bad() { char data; data = ' '; { case 6: fscanf (stdin, \"%c\", &data); { case 7: { data--; char result = data; static void goodB2G1() { char data; data = ' '; { case 6: fscanf (stdin, \"%c\", &data); break; default: if (data > CHAR_MIN) { data--; char result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_16.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_16.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_16.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_postdec_16_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_16.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); while(1) { { data--; int64_t result = data; static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10.c", "text": "fscanf (stdin, \"%u\", &data); if(globalTrue) { { data--; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_10_bad() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); if(globalTrue) { { data--; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; if(globalTrue) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { data--; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_45.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_45.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_45.c", "text": "data--; int64_t result = data; } } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_45.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData = data; static void goodG2BSink() { int64_t data = CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_goodG2BData; { data--; int64_t result = data; static void goodG2B() { int64_t data; data = 0LL; data = -2; CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_goodG2BData = data; static void goodB2GSink() { int64_t data = CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_goodB2GData; if (data > LLONG_MIN) { data--; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__char_fscanf_postdec_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_postdec_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_42.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_42.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_42.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 42 Data flow: data returned from one function to another in the same source file #ifndef OMITBAD static short badSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_42.c", "text": "#ifndef OMITBAD static short badSource(short data) { fscanf (stdin, \"%hd\", &data); return data; } void CWE191_Integer_Underflow__short_fscanf_postdec_42_bad() { short data; data = 0; data = badSource(data); { data--; short result = data; #ifndef OMITGOOD static short goodG2BSource(short data) { data = -2; return data; static void goodG2B() { short data; data = 0; data = goodG2BSource(data); { data--; short result = data; } static short goodB2GSource(short data) fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_54c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_54c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_53c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_53c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) { unsigned int unionFirst; unsigned int unionSecond; } CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_bad() { unsigned int data; CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_unionType myUnion; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34.c", "text": "{ unsigned int unionFirst; unsigned int unionSecond; } CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_bad() { unsigned int data; CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_unionType myUnion; data = 0; fscanf (stdin, \"%u\", &data); myUnion.unionFirst = data; { unsigned int data = myUnion.unionSecond; { data--; unsigned int result = data; static void goodG2B() { unsigned int data; CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_unionType myUnion; data = 0; data = -2; myUnion.unionFirst = data; { unsigned int data = myUnion.unionSecond; { data--; unsigned int result = data; static void goodB2G() { unsigned int data; CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_34_unionType myUnion; data = 0; fscanf (stdin, \"%u\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_44.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_44.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_44.c", "text": "data--; int64_t result = data; } } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_44.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); funcPtr(data); #ifndef OMITGOOD static void goodG2BSink(int64_t data) { { data--; int64_t result = data; static void goodG2B() { int64_t data; void (*funcPtr) (int64_t) = goodG2BSink; data = 0LL; data = -2; funcPtr(data); } static void goodB2GSink(int64_t data) { if (data > LLONG_MIN) { data--; int64_t result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G() { int64_t data; void (*funcPtr) (int64_t) = goodB2GSink; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_32.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_32.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__short_fscanf_postdec_32.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__short_fscanf_postdec_32_bad() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; fscanf (stdin, \"%hd\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__short_fscanf_postdec_32.c", "text": "{ short data = *dataPtr1; fscanf (stdin, \"%hd\", &data); *dataPtr1 = data; } { short data = *dataPtr2; { data--; short result = data; static void goodG2B() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; data = -2; *dataPtr1 = data; } { short data = *dataPtr2; { data--; short result = data; static void goodB2G() { short data; short *dataPtr1 = &data; short *dataPtr2 = &data; data = 0; { short data = *dataPtr1; fscanf (stdin, \"%hd\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53a.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53b_badSink(unsigned int data); void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow * Flow Variant: 53 Data flow: data passed as an argument from one function through two others to a fourth; all four functions are in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53b_badSink(unsigned int data); void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data); CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53b_badSink(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53b_goodG2BSink(unsigned int data); static void goodG2B() { unsigned int data; data = 0; data = -2; CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53b_goodG2BSink(data); } void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_53b_goodB2GSink(unsigned int data); static void goodB2G() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_67a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_67a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_67a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); void CWE191_Integer_Underflow__int_fscanf_postdec_67_bad() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct;", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_67a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); void CWE191_Integer_Underflow__int_fscanf_postdec_67_bad() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_67a.c", "text": "#include \"std_testcase.h\" typedef struct _CWE191_Integer_Underflow__int_fscanf_postdec_67_structType { int structFirst; } CWE191_Integer_Underflow__int_fscanf_postdec_67_structType; #ifndef OMITBAD void CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); void CWE191_Integer_Underflow__int_fscanf_postdec_67_bad() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(myStruct); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_postdec_67b_goodG2BSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); static void goodG2B() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct; data = -2; myStruct.structFirst = data; CWE191_Integer_Underflow__int_fscanf_postdec_67b_goodG2BSink(myStruct); } void CWE191_Integer_Underflow__int_fscanf_postdec_67b_goodB2GSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); static void goodB2G() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct;", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_67a.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); void CWE191_Integer_Underflow__int_fscanf_postdec_67_bad() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data); myStruct.structFirst = data; CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(myStruct); #ifndef OMITGOOD void CWE191_Integer_Underflow__int_fscanf_postdec_67b_goodG2BSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); static void goodG2B() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct; data = 0; data = -2; myStruct.structFirst = data; CWE191_Integer_Underflow__int_fscanf_postdec_67b_goodG2BSink(myStruct); } void CWE191_Integer_Underflow__int_fscanf_postdec_67b_goodB2GSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct); static void goodB2G() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct; data = 0; fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int64_t_fscanf_postdec_54d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_postdec_54d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_12.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int_fscanf_postdec_12.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_12.c", "text": "void CWE191_Integer_Underflow__int_fscanf_postdec_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { data--; int result = data; else { if (data > INT_MIN) { data--; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__int_fscanf_postdec_12.c", "text": "data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); else { data = -2; if(globalReturnsTrueOrFalse()) { { data--; int result = data; else { if (data > INT_MIN) { data--; int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); use the GoodSink */ static void goodB2G() { int data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf(stdin, \"%d\", &data); } else { fscanf(stdin, \"%d\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: decrement * GoodSink: Ensure there will not be an underflow before decrementing data * BadSink : Decrement data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08_bad() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08.c", "text": "fscanf (stdin, \"%u\", &data); if(staticReturnsTrue()) { { data--; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s04/CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08.c", "text": "void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_08_bad() { unsigned int data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%u\", &data); if(staticReturnsTrue()) { { data--; unsigned int result = data; static void goodB2G1() { unsigned int data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, \"%u\", &data); else { if (data > 0) { data--; unsigned int result = data; } else { printLine(\"data value is too large to perform arithmetic safely.\"); static void goodB2G2() { unsigned int data; data = 0; fscanf (stdin, \"%u\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_31.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_31.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_31.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_31.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 31 Data flow using a copy of data within the same function #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_31_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); { char dataCopy = data; char data = dataCopy; { char result = data - 1; static void goodG2B() { char data; data = ' '; data = -2; { char dataCopy = data; char data = dataCopy; { char result = data - 1; static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_68b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_68b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_10.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_10.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_10.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_10_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_10.c", "text": "fscanf (stdin, \"%c\", &data); if(globalTrue) { { char result = data - 1; static void goodB2G1() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_10.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_10_bad() { char data; data = ' '; if(globalTrue) { fscanf (stdin, \"%c\", &data); if(globalTrue) { { char result = data - 1; static void goodB2G1() { char data; data = ' '; if(globalTrue) { fscanf (stdin, \"%c\", &data); else { if (data > CHAR_MIN) { char result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_66a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_66a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_66a.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_multiply_66b_badSink(int64_t dataArray[]); void CWE191_Integer_Underflow__int64_t_fscanf_multiply_66_bad() { int64_t data; int64_t dataArray[5]; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_66a.c", "text": "* Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_66b_badSink(int64_t dataArray[]); void CWE191_Integer_Underflow__int64_t_fscanf_multiply_66_bad() { int64_t data; int64_t dataArray[5]; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); dataArray[2] = data; CWE191_Integer_Underflow__int64_t_fscanf_multiply_66b_badSink(dataArray); #ifndef OMITGOOD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_66b_goodG2BSink(int64_t dataArray[]); static void goodG2B() { int64_t data; int64_t dataArray[5]; data = 0LL; data = -2; dataArray[2] = data; CWE191_Integer_Underflow__int64_t_fscanf_multiply_66b_goodG2BSink(dataArray); } void CWE191_Integer_Underflow__int64_t_fscanf_multiply_66b_goodB2GSink(int64_t dataArray[]); static void goodB2G() { int64_t data; int64_t dataArray[5]; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_14.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_14.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_14.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_14_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_14.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); } if(globalFive==5) { if(data < 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_14.c", "text": "void CWE191_Integer_Underflow__int64_t_fscanf_multiply_14_bad() { int64_t data; data = 0LL; if(globalFive==5) { fscanf (stdin, \"%\" SCNd64, &data); } if(globalFive==5) { if(data < 0) { int64_t result = data * 2; static void goodB2G1() { int64_t data; data = 0LL; if(globalFive==5) { fscanf (stdin, \"%\" SCNd64, &data); } else { if(data < 0) { if (data > (LLONG_MIN/2)) { int64_t result = data * 2; } else { printLine(\"data value is too small to perform multiplication.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_13.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_13.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_13.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_13_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_13.c", "text": "fscanf (stdin, \"%\" SCNd64, &data); if(GLOBAL_CONST_FIVE==5) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_13.c", "text": "#ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_sub_13_bad() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); if(GLOBAL_CONST_FIVE==5) { { int64_t result = data - 1; static void goodB2G1() { int64_t data; data = 0LL; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, \"%\" SCNd64, &data); else { if (data > LLONG_MIN) { int64_t result = data - 1; } else { printLine(\"data value is too large to perform subtraction.\"); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_52b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_52b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_53d.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_53d.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_33.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_33.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_33.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__char_fscanf_sub_33 void bad() { char data; char &dataRef = data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_33.cpp", "text": "* Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 33 Data flow: use of a C++ reference to data within the same function #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__char_fscanf_sub_33 void bad() { char data; char &dataRef = data; data = ' '; fscanf (stdin, \"%c\", &data); { char data = dataRef; { char result = data - 1; static void goodG2B() { char data; char &dataRef = data; data = ' '; data = -2; { char data = dataRef; { char result = data - 1; static void goodB2G() { char data; char &dataRef = data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_68a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_68a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_68a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_sub_68b_badSink(); void CWE191_Integer_Underflow__char_fscanf_sub_68_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_68a.c", "text": "* Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files #include \"std_testcase.h\" char CWE191_Integer_Underflow__char_fscanf_sub_68_badData; char CWE191_Integer_Underflow__char_fscanf_sub_68_goodG2BData; char CWE191_Integer_Underflow__char_fscanf_sub_68_goodB2GData; #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_68b_badSink(); void CWE191_Integer_Underflow__char_fscanf_sub_68_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_sub_68_badData = data; CWE191_Integer_Underflow__char_fscanf_sub_68b_badSink(); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_sub_68b_goodG2BSink(); void CWE191_Integer_Underflow__char_fscanf_sub_68b_goodB2GSink(); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_sub_68_goodG2BData = data; CWE191_Integer_Underflow__char_fscanf_sub_68b_goodG2BSink(); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_82.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_82.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_62b.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_62b.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_62b.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 62 Data flow: data flows using a C++ reference from one function to another in different source files #include <inttypes.h> #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__int64_t_fscanf_sub_62 #ifndef OMITBAD void badSource(int64_t &data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_62b.cpp", "text": "fscanf (stdin, \"%\" SCNd64, &data); #ifndef OMITGOOD void goodG2BSource(int64_t &data) { data = -2; } void goodB2GSource(int64_t &data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_53b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_53b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_64a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_64a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_64a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_multiply_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__char_fscanf_multiply_64_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_64a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 64 Data flow: void pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_multiply_64b_badSink(void * dataVoidPtr); void CWE191_Integer_Underflow__char_fscanf_multiply_64_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_multiply_64b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_multiply_64b_goodG2BSink(void * dataVoidPtr); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_multiply_64b_goodG2BSink(&data); } void CWE191_Integer_Underflow__char_fscanf_multiply_64b_goodB2GSink(void * dataVoidPtr); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_22a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_22a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badGlobal = 1; CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badSink(data); #ifndef OMITGOOD int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G1Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G2Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodG2BGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G1Sink(int64_t data); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_22a.c", "text": "int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badSink(int64_t data); void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_bad() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badGlobal = 1; CWE191_Integer_Underflow__int64_t_fscanf_sub_22_badSink(data); #ifndef OMITGOOD int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G1Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G2Global = 0; int CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodG2BGlobal = 0; void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G1Sink(int64_t data); static void goodB2G1() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G1Global = 0; CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G1Sink(data); } void CWE191_Integer_Underflow__int64_t_fscanf_sub_22_goodB2G2Sink(int64_t data); static void goodB2G2() { int64_t data; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_63a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_63a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_63a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_multiply_63b_badSink(char * dataPtr); void CWE191_Integer_Underflow__char_fscanf_multiply_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_63a.c", "text": "* @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 63 Data flow: pointer to data passed from one function to another in different source files #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_multiply_63b_badSink(char * dataPtr); void CWE191_Integer_Underflow__char_fscanf_multiply_63_bad() { char data; data = ' '; fscanf (stdin, \"%c\", &data); CWE191_Integer_Underflow__char_fscanf_multiply_63b_badSink(&data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_multiply_63b_goodG2BSink(char * data); static void goodG2B() { char data; data = ' '; data = -2; CWE191_Integer_Underflow__char_fscanf_multiply_63b_goodG2BSink(&data); } void CWE191_Integer_Underflow__char_fscanf_multiply_63b_goodB2GSink(char * data); static void goodB2G() { char data; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_64b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_64b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_52c.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_52c.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_multiply_83.h", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_multiply_83.h * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_43.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_43.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_43.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 43 Data flow: data flows using a C++ reference from one function to another in the same source file #include <inttypes.h> #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__int64_t_fscanf_multiply_43 #ifndef OMITBAD static void badSource(int64_t &data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_43.cpp", "text": "#include <inttypes.h> #include \"std_testcase.h\" namespace CWE191_Integer_Underflow__int64_t_fscanf_multiply_43 #ifndef OMITBAD static void badSource(int64_t &data) { fscanf (stdin, \"%\" SCNd64, &data); void bad() { int64_t data; data = 0LL; badSource(data); if(data < 0) { int64_t result = data * 2; #ifndef OMITGOOD static void goodG2BSource(int64_t &data) { data = -2; static void goodG2B() { int64_t data; data = 0LL; goodG2BSource(data); if(data < 0) { int64_t result = data * 2; } static void goodB2GSource(int64_t &data) fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_65b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_65b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_74a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_74a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_74a.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__int64_t_fscanf_multiply_74 void bad() { int64_t data; map<int, int64_t> dataMap; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_74a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 74 Data flow: data passed in a map from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__int64_t_fscanf_multiply_74 void bad() { int64_t data; map<int, int64_t> dataMap; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodG2B() { int64_t data; map<int, int64_t> dataMap; data = 0LL; data = -2; dataMap[0] = data; dataMap[1] = data; dataMap[2] = data; static void goodB2G() { int64_t data; map<int, int64_t> dataMap; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_81_goodB2G.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_81_goodB2G.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_sub_67b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_sub_67b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_34.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) { char unionFirst; char unionSecond; } CWE191_Integer_Underflow__char_fscanf_sub_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_34_bad() { char data; CWE191_Integer_Underflow__char_fscanf_sub_34_unionType myUnion; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_34.c", "text": "{ char unionFirst; char unionSecond; } CWE191_Integer_Underflow__char_fscanf_sub_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_34_bad() { char data; CWE191_Integer_Underflow__char_fscanf_sub_34_unionType myUnion; data = ' '; fscanf (stdin, \"%c\", &data); myUnion.unionFirst = data; { char data = myUnion.unionSecond; { char result = data - 1; static void goodG2B() { char data; CWE191_Integer_Underflow__char_fscanf_sub_34_unionType myUnion; data = ' '; data = -2; myUnion.unionFirst = data; { char data = myUnion.unionSecond; { char result = data - 1; static void goodB2G() { char data; CWE191_Integer_Underflow__char_fscanf_sub_34_unionType myUnion; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_82_goodG2B.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_82_goodG2B.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_62a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_62a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_72a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_72a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_72a.cpp /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__int64_t_fscanf_multiply_72 void bad() { int64_t data; vector<int64_t> dataVector; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_72a.cpp", "text": "* BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 72 Data flow: data passed in a vector from one function to another in different source files using namespace std; namespace CWE191_Integer_Underflow__int64_t_fscanf_multiply_72 void bad() { int64_t data; vector<int64_t> dataVector; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodG2B() { int64_t data; vector<int64_t> dataVector; data = 0LL; data = -2; dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); dataVector.insert(dataVector.end(), 1, data); static void goodB2G() { int64_t data; vector<int64_t> dataVector; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_65a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__char_fscanf_sub_65a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_65a.c", "text": "void CWE191_Integer_Underflow__char_fscanf_sub_65b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_sub_65_bad() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_sub_65b_badSink; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__char_fscanf_sub_65a.c", "text": "* Sinks: sub * GoodSink: Ensure there will not be an underflow before subtracting 1 from data * BadSink : Subtract 1 from data, which can cause an Underflow * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer #ifndef OMITBAD void CWE191_Integer_Underflow__char_fscanf_sub_65b_badSink(char data); void CWE191_Integer_Underflow__char_fscanf_sub_65_bad() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_sub_65b_badSink; data = ' '; fscanf (stdin, \"%c\", &data); funcPtr(data); #ifndef OMITGOOD void CWE191_Integer_Underflow__char_fscanf_sub_65b_goodG2BSink(char data); static void goodG2B() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_sub_65b_goodG2BSink; data = ' '; data = -2; funcPtr(data); } void CWE191_Integer_Underflow__char_fscanf_sub_65b_goodB2GSink(char data); static void goodB2G() { char data; void (*funcPtr) (char) = CWE191_Integer_Underflow__char_fscanf_sub_65b_goodB2GSink; data = ' '; fscanf (stdin, \"%c\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_61a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_61a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_34.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_34.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE191_Integer_Underflow__int64_t_fscanf_multiply_34.c /* * @description * CWE: 191 Integer Underflow * BadSource: fscanf Read data from the console using fscanf() * GoodSource: Set data to a small, non-zero number (negative two) * Sinks: multiply * GoodSink: Ensure there will not be an underflow before multiplying data by 2 * BadSink : If data is negative, multiply by 2, which can cause an underflow * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function) { int64_t unionFirst; int64_t unionSecond; } CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_bad() { int64_t data; CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_unionType myUnion; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE191_Integer_Underflow/s01/CWE191_Integer_Underflow__int64_t_fscanf_multiply_34.c", "text": "{ int64_t unionFirst; int64_t unionSecond; } CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_unionType; #ifndef OMITBAD void CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_bad() { int64_t data; CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_unionType myUnion; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data); myUnion.unionFirst = data; { int64_t data = myUnion.unionSecond; if(data < 0) { int64_t result = data * 2; static void goodG2B() { int64_t data; CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_unionType myUnion; data = 0LL; data = -2; myUnion.unionFirst = data; { int64_t data = myUnion.unionSecond; if(data < 0) { int64_t result = data * 2; static void goodB2G() { int64_t data; CWE191_Integer_Underflow__int64_t_fscanf_multiply_34_unionType myUnion; data = 0LL; fscanf (stdin, \"%\" SCNd64, &data);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptDeriveKey_11.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(globalReturnsTrue()) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptDeriveKey_11.c", "text": "do { memcpy(payload, PAYLOAD, payloadLen); break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); if(globalReturnsTrue()) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptEncrypt_01.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" void CWE325_Missing_Required_Cryptographic_Step__w32_CryptEncrypt_01_bad() { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptEncrypt_01.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" void CWE325_Missing_Required_Cryptographic_Step__w32_CryptEncrypt_01_bad() { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); static void good1() { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptHashData_10.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(globalTrue) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptHashData_10.c", "text": "do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); if(globalTrue) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptDeriveKey_02.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(1) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptDeriveKey_02.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" if(1) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptDeriveKey_02.c", "text": "do { memcpy(payload, PAYLOAD, payloadLen); break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); else { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); if(1) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptDeriveKey_17.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" for(j = 0; j < 1; j++) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); for(k = 0; k < 1; k++) { { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE325_Missing_Required_Cryptographic_Step/CWE325_Missing_Required_Cryptographic_Step__w32_CryptCreateHash_18.c", "text": "#pragma comment(lib, \"advapi32\") #define HASH_INPUT \"ABCDEFG123456\" #define PAYLOAD \"plaintext\" goto sink; sink: { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen); { break; } { break; } if(!CryptEncrypt(hKey, 0, 1, 0, payload, &payloadLen, sizeof(payload))) CryptReleaseContext(hCryptProv, 0); } printBytesLine(payload, payloadLen); goto sink; sink: { BYTE payload[100]; DWORD payloadLen = strlen(PAYLOAD); char hashData[100] = HASH_INPUT; do { memcpy(payload, PAYLOAD, payloadLen);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_17.c", "text": "} #endif #ifndef OMITGOOD static void good1() { int k; for(k = 0; k < 1; k++) { { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_17.c", "text": "#include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE475_Undefined_Behavior_for_Input_to_API__char_17_bad() { int j; for(j = 0; j < 1; j++) { { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_09.c", "text": "#ifndef OMITGOOD static void good1() { if(GLOBAL_CONST_FALSE) { printLine(\"Benign, fixed string\"); } else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_09.c", "text": "if(GLOBAL_CONST_TRUE) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_09.c", "text": "memmove(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); } } } static void good2() { if(GLOBAL_CONST_TRUE) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_09.c", "text": "if(GLOBAL_CONST_TRUE) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); if(GLOBAL_CONST_TRUE) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_09.c", "text": "* */ #include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_09_bad() { if(GLOBAL_CONST_TRUE) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_09.c", "text": "if(GLOBAL_CONST_TRUE) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "{ { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); } } else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "} } #endif #ifndef OMITGOOD static void good1() { if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "{ { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); } } else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); else { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "* */ #include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12_bad() { if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_12.c", "text": "if(globalReturnsTrueOrFalse()) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_16.c", "text": "} } #endif #ifndef OMITGOOD static void good1() { while(1) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_16.c", "text": "while(1) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t)); printWLine(data); while(1) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_16.c", "text": "* */ #include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_16_bad() { while(1) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__wchar_t_16.c", "text": "while(1) { { wchar_t dataBuffer[100] = L\"\"; wchar_t * data = dataBuffer; wcscpy(data, L\"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(wchar_t));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "#ifndef OMITGOOD static void good1() { switch(5) { case 6: printLine(\"Benign, fixed string\"); break; default: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(char)); printLine(data); default: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "printLine(data); } break; } } static void good2() { switch(6) { case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(char)); printLine(data); default: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(char)); printLine(data); case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "#include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE475_Undefined_Behavior_for_Input_to_API__char_15_bad() { switch(6) { case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(char));", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(char)); printLine(data); default: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_15.c", "text": "case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memcpy(data + 6, data + 4, 10*sizeof(char)); printLine(data); default: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\"); memmove(data + 6, data + 4, 10*sizeof(char)); printLine(data); case 6: { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_01.c", "text": "memcpy(data + 6, data + 4, 10*sizeof(char)); printLine(data); } } #endif #ifndef OMITGOOD static void good1() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE475_Undefined_Behavior_for_Input_to_API/CWE475_Undefined_Behavior_for_Input_to_API__char_01.c", "text": "* Flow Variant: 01 Baseline * * */ #include \"std_testcase.h\" #include <wchar.h> #ifndef OMITBAD void CWE475_Undefined_Behavior_for_Input_to_API__char_01_bad() { { char dataBuffer[100] = \"\"; char * data = dataBuffer; strcpy(data, \"abcdefghijklmnopqrstuvwxyz\");", "label": 0}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s07/CWE762_Mismatched_Memory_Management_Routines__realloc_delete_array_01_good1.cpp", "text": "class GoodClass { public: GoodClass(char * name) { this->name = NULL; this->name = (char *)realloc(this->name, strlen(name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~GoodClass() { free(name); } GoodClass(GoodClass &goodClassObject) { this->name = (char *)realloc(name, strlen(goodClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, goodClassObject.name);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s07/CWE762_Mismatched_Memory_Management_Routines__realloc_delete_array_01_good1.cpp", "text": "class GoodClass { public: GoodClass(char * name) { this->name = NULL; this->name = (char *)realloc(this->name, strlen(name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~GoodClass() { free(name); } GoodClass(GoodClass &goodClassObject) { this->name = (char *)realloc(name, strlen(goodClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, goodClassObject.name); } GoodClass& operator=(const GoodClass &goodClassObject) { if (&goodClassObject != this) { this->name = (char *)realloc(this->name, strlen(goodClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, goodClassObject.name);", "label": 0}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s07/CWE762_Mismatched_Memory_Management_Routines__realloc_delete_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = NULL; this->name = (char *)realloc(this->name, strlen(name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~BadClass() { delete name; } BadClass(BadClass &badClassObject) { this->name = (char *)realloc(this->name, strlen(badClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE762_Mismatched_Memory_Management_Routines/s07/CWE762_Mismatched_Memory_Management_Routines__realloc_delete_01_bad.cpp", "text": "class BadClass { public: BadClass(char * name) { this->name = NULL; this->name = (char *)realloc(this->name, strlen(name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, name); ~BadClass() { delete name; } BadClass(BadClass &badClassObject) { this->name = (char *)realloc(this->name, strlen(badClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name); } BadClass& operator=(const BadClass &badClassObject) { if (&badClassObject != this) { this->name = (char *)realloc(this->name, strlen(badClassObject.name)+1); if (this->name == NULL) {exit(-1);} strcpy(this->name, badClassObject.name);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_51b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_51b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_08.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_08.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_84a.cpp", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_84a.cpp * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_52a.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_52a.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_52a.c", "text": "void CWE617_Reachable_Assertion__fscanf_52b_badSink(int data); void CWE617_Reachable_Assertion__fscanf_52_bad()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_52a.c", "text": "void CWE617_Reachable_Assertion__fscanf_52b_badSink(int data); void CWE617_Reachable_Assertion__fscanf_52_bad() { int data; data = -1; fscanf(stdin, \"%d\", &data);", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_03.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_03.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_07.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_07.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE617_Reachable_Assertion/CWE617_Reachable_Assertion__fscanf_63b.c", "text": "/* TEMPLATE GENERATED TESTCASE FILE Filename: CWE617_Reachable_Assertion__fscanf_63b.c * BadSource: fscanf Read data from the console using fscanf()", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09.c", "text": "void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09_bad() { char * password; password = \"\"; if(GLOBAL_CONST_TRUE) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09.c", "text": "void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09_bad() { char * password; password = \"\"; if(GLOBAL_CONST_TRUE) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) } strcpy(password, \"Password1234!\"); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); static void goodG2B1() { char * password; password = \"\"; } else { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09.c", "text": "{ char * password; password = \"\"; } else { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) exit(1); } strcpy(password, \"Password1234!\"); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); static void goodG2B2() { char * password; password = \"\"; if(GLOBAL_CONST_TRUE) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_21.c", "text": "static int badStatic = 0; static char * badSource(char * password) { if(badStatic) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_21.c", "text": "if(badStatic) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) } strcpy(password, \"Password1234!\"); } return password; void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_21_bad() { char * password; password = \"\"; badStatic = 1; password = badSource(password); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); static int goodG2B2Static = 0; static char * goodG2B1Source(char * password) } else { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_21.c", "text": "exit(1); } if(!VirtualLock(password, 100*sizeof(char))) exit(1); } strcpy(password, \"Password1234!\"); } return password; static void goodG2B1() { char * password; password = \"\"; goodG2B1Static = 0; password = goodG2B1Source(password); HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); } static char * goodG2B2Source(char * password) { if(goodG2B2Static) { password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_44.c", "text": "#ifndef OMITBAD static void badSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); void CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_44_bad() { char * password; void (*funcPtr) (char *) = badSink; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_44.c", "text": "void (*funcPtr) (char *) = badSink; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) } strcpy(password, \"Password1234!\"); funcPtr(password); #ifndef OMITGOOD static void goodG2BSink(char * password) HANDLE pHandle; char * username = \"User\"; char * domain = \"Domain\"; if (LogonUserA( username, domain, password, printLine(\"Unable to login.\"); } free(password); static void goodG2B() { char * password; void (*funcPtr) (char *) = goodG2BSink; password = \"\"; password = (char *)malloc(100*sizeof(char)); if (password == NULL) exit(1); } if(!VirtualLock(password, 100*sizeof(char))) strcpy(password, \"Password1234!\");", "label": 1}
{"id": null, "file": "../../C/testcases/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory/CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_84_bad.cpp", "text": "{ CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_84_bad::CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_84_bad(char * passwordCopy) { password = passwordCopy; password = (char *)malloc(100*sizeof(char)); if (password == NULL) strcpy(password, \"Password1234!\");", "label": 1}
